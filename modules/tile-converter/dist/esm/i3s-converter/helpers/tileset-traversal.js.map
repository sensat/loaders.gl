{"version":3,"file":"tileset-traversal.js","names":["traverseDatasetWith","tile","traversalProps","processTile","postprocessTile","maxDepth","level","arguments","length","undefined","processResults","newTraversalProps","push","childTile","children"],"sources":["../../../../src/i3s-converter/helpers/tileset-traversal.ts"],"sourcesContent":["import {Tiles3DTileJSONPostprocessed} from '@loaders.gl/3d-tiles';\nimport {NodeIndexDocument} from './node-index-document';\nimport {Matrix4} from '@math.gl/core';\n\n/** Traversal props for the conversion stage */\nexport type TraversalConversionProps = {\n  /** Transformation matrix for the specific tile */\n  transform: Matrix4;\n  /** Parent nodes of the converted tile. Multiple nodes can be if one tile is converted to multiple nodes*/\n  parentNodes: NodeIndexDocument[];\n};\n\n/**\n * Travesal of 3DTile tiles tree with making specific actions with each tile\n * @param tile - 3DTiles tile JSON metadata\n * @param traversalProps - traversal props used to pass data through recursive calls\n * @param processTile - callback to make some actions with the current tile\n * @param postprocessTile - callback to make some action after processing of the current tile and all the subtree\n * @param maxDepth - max recursive calls number the travesal function will do. If not set, the traversal function will\n *                   go through all the tree.\n *                   This value is used to limit the convertion with only partial number of levels of the tileset\n * @param level - counter to keep recursive calls number of the tiles tree. This value used to be able to break\n *                traversal at the some level of the tree\n * @returns void\n */\nexport const traverseDatasetWith = async <TProps>(\n  tile: Tiles3DTileJSONPostprocessed,\n  traversalProps: TProps,\n  processTile: (tile: Tiles3DTileJSONPostprocessed, traversalProps: TProps) => Promise<TProps>,\n  postprocessTile?: (processResults: TProps[], currentTraversalProps: TProps) => Promise<void>,\n  maxDepth?: number,\n  level = 0\n): Promise<void> => {\n  if (maxDepth && level > maxDepth) {\n    return;\n  }\n  const processResults: TProps[] = [];\n  const newTraversalProps: TProps = await processTile(tile, traversalProps);\n  processResults.push(newTraversalProps);\n  for (const childTile of tile.children) {\n    await traverseDatasetWith(\n      childTile,\n      newTraversalProps,\n      processTile,\n      postprocessTile,\n      maxDepth,\n      level + 1\n    );\n  }\n  postprocessTile && (await postprocessTile(processResults, traversalProps));\n};\n"],"mappings":"AAyBA,OAAO,MAAMA,mBAAmB,GAAG,eAAAA,CACjCC,IAAkC,EAClCC,cAAsB,EACtBC,WAA4F,EAC5FC,eAA4F,EAC5FC,QAAiB,EAEC;EAAA,IADlBC,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAET,IAAIF,QAAQ,IAAIC,KAAK,GAAGD,QAAQ,EAAE;IAChC;EACF;EACA,MAAMK,cAAwB,GAAG,EAAE;EACnC,MAAMC,iBAAyB,GAAG,MAAMR,WAAW,CAACF,IAAI,EAAEC,cAAc,CAAC;EACzEQ,cAAc,CAACE,IAAI,CAACD,iBAAiB,CAAC;EACtC,KAAK,MAAME,SAAS,IAAIZ,IAAI,CAACa,QAAQ,EAAE;IACrC,MAAMd,mBAAmB,CACvBa,SAAS,EACTF,iBAAiB,EACjBR,WAAW,EACXC,eAAe,EACfC,QAAQ,EACRC,KAAK,GAAG,CACV,CAAC;EACH;EACAF,eAAe,KAAK,MAAMA,eAAe,CAACM,cAAc,EAAER,cAAc,CAAC,CAAC;AAC5E,CAAC"}