{"version":3,"file":"geometry-attributes.js","names":["concatenateTypedArrays","VALUES_PER_VERTEX","POSITIONS_AND_NORMALS_PER_TRIANGLE","generateAttributes","attributes","positions","normals","texCoords","colors","uvRegions","featureIndices","triangleCount","length","faceRange","Uint32Array","featureIds","featureCount","data","calculateFaceRangesAndFeaturesCount","attributeObjects","makeAttributeObjects","unifiedAttributeObjectsByFeatureIds","unifyObjectsByFeatureId","groupedAttributes","groupAttributesAndRangesByFeatureId","rangeIndex","featureIndex","currentFeatureId","getFrequentValue","slice","faceRangeList","uniqueFeatureIds","index","newFeatureId","includes","push","values","map","mostFrequentValue","maxCount","value","groupedData","positionsList","Float32Array","normalsList","colorsList","Uint8Array","texCoordsList","uvRegionsList","Uint16Array","startIndex","endIndex","positionsCount","getSliceAttributeCount","normalsCount","colorsCount","uvRegionsCount","texCoordsCount","featureId","sort","first","second","attributeName","itemsPerVertex4","texCoordsPerVertex","trianglesCount","vertexCount","sortedData","uniqueObjects","currentObject","existedObject","find","obj","unifiedObjects","firstAttributeObject","range","objIndex","sum","currentAttributesObject","groupedObject"],"sources":["../../../../src/i3s-converter/helpers/geometry-attributes.ts"],"sourcesContent":["import type {GeometryAttributes, ConvertedAttributes, GroupedByFeatureIdAttributes} from '../types';\nimport {concatenateTypedArrays} from '@loaders.gl/loader-utils';\n\nconst VALUES_PER_VERTEX = 3;\nconst POSITIONS_AND_NORMALS_PER_TRIANGLE = 9;\n\n/**\n * Generate geometry attributes with faceRange and featureCount\n * @param attributes\n * @returns attirbutes with featureCount, featureIds and changed faceRange.\n */\nexport function generateAttributes(attributes: ConvertedAttributes): GeometryAttributes {\n  const {positions, normals, texCoords, colors, uvRegions, featureIndices} = attributes;\n  const triangleCount = positions.length / POSITIONS_AND_NORMALS_PER_TRIANGLE;\n\n  if (!featureIndices.length) {\n    return {\n      faceRange: new Uint32Array([0, triangleCount - 1]),\n      featureIds: [0],\n      featureCount: 1,\n      positions,\n      normals,\n      texCoords,\n      colors,\n      uvRegions\n    };\n  }\n\n  const data = calculateFaceRangesAndFeaturesCount(featureIndices);\n  const attributeObjects = makeAttributeObjects({...data, ...attributes});\n  const unifiedAttributeObjectsByFeatureIds = unifyObjectsByFeatureId(attributeObjects);\n  const groupedAttributes = groupAttributesAndRangesByFeatureId(\n    unifiedAttributeObjectsByFeatureIds,\n    data.featureCount\n  );\n  return groupedAttributes;\n}\n\n/**\n * Calculates face Ranges and feature count based on featureIndices.\n * @param featureIndices\n * @returns Object with featureCount, reordered attributes and changed faceRange.\n */\nfunction calculateFaceRangesAndFeaturesCount(featureIndices: number[]): {\n  faceRange: Uint32Array;\n  featureCount: number;\n  featureIds: number[];\n} {\n  let rangeIndex = 1;\n  let featureIndex = 1;\n  let currentFeatureId = getFrequentValue(featureIndices.slice(0, VALUES_PER_VERTEX));\n  const faceRangeList: any[] = [];\n  const featureIds: any[] = [];\n  const uniqueFeatureIds = [currentFeatureId];\n\n  faceRangeList[0] = 0;\n  featureIds[0] = currentFeatureId;\n\n  for (let index = VALUES_PER_VERTEX; index < featureIndices.length; index += VALUES_PER_VERTEX) {\n    const newFeatureId = getFrequentValue(featureIndices.slice(index, index + VALUES_PER_VERTEX));\n    if (currentFeatureId !== newFeatureId) {\n      faceRangeList[rangeIndex] = index / VALUES_PER_VERTEX - 1;\n      faceRangeList[rangeIndex + 1] = index / VALUES_PER_VERTEX;\n      featureIds[featureIndex] = newFeatureId;\n\n      if (!uniqueFeatureIds.includes(newFeatureId)) {\n        uniqueFeatureIds.push(newFeatureId);\n      }\n\n      rangeIndex += 2;\n      featureIndex += 1;\n    }\n    currentFeatureId = newFeatureId;\n  }\n\n  faceRangeList[rangeIndex] = featureIndices.length / VALUES_PER_VERTEX - 1;\n\n  const faceRange = new Uint32Array(faceRangeList);\n  const featureCount = uniqueFeatureIds.length;\n\n  return {faceRange, featureCount, featureIds};\n}\n\n/**\n * Find most frequent value to avoid situation where one vertex can be part of multiple features (objects).\n * @param values\n */\nfunction getFrequentValue(values: number[]): number {\n  const map: {[key: number]: number} = {};\n\n  let mostFrequentValue = values[0];\n  let maxCount = 1;\n\n  for (const value of values) {\n    // Save item and it's frequency count to the map.\n    map[value] = (map[value] || 0) + 1;\n    // Find max count of frequency.\n    maxCount = maxCount > map[value] ? maxCount : map[value];\n    // Find the most frequent value.\n    mostFrequentValue = maxCount > map[value] ? mostFrequentValue : value;\n  }\n\n  return mostFrequentValue;\n}\n\n/**\n * Generate list of attribute object grouped by feature ids.\n * @param  attributes\n * @returns sorted list of attribute objects.\n */\nfunction makeAttributeObjects(attributes: GeometryAttributes): GroupedByFeatureIdAttributes[] {\n  const {\n    featureIds,\n    positions,\n    normals,\n    colors,\n    uvRegions,\n    texCoords,\n    faceRange = new Uint32Array(0)\n  } = attributes;\n  const groupedData: GroupedByFeatureIdAttributes[] = [];\n\n  let positionsList = new Float32Array(positions);\n  let normalsList = new Float32Array(normals);\n  let colorsList = new Uint8Array(colors);\n  let texCoordsList = new Float32Array(texCoords);\n  let uvRegionsList = new Uint16Array(uvRegions);\n\n  for (let index = 0; index < featureIds.length; index++) {\n    const startIndex = faceRange[index * 2];\n    const endIndex = faceRange[index * 2 + 1];\n\n    const positionsCount = getSliceAttributeCount('positions', startIndex, endIndex);\n    const normalsCount = getSliceAttributeCount('normals', startIndex, endIndex);\n    const colorsCount = getSliceAttributeCount('colors', startIndex, endIndex);\n    const uvRegionsCount = getSliceAttributeCount('uvRegions', startIndex, endIndex);\n    const texCoordsCount = getSliceAttributeCount('texCoords', startIndex, endIndex);\n\n    groupedData.push({\n      featureId: featureIds[index],\n      positions: positionsList.slice(0, positionsCount),\n      normals: normalsList.slice(0, normalsCount),\n      colors: colorsList.slice(0, colorsCount),\n      uvRegions: uvRegionsList.slice(0, uvRegionsCount),\n      texCoords: texCoordsList.slice(0, texCoordsCount)\n    });\n\n    positionsList = positionsList.slice(positionsCount);\n    normalsList = normalsList.slice(normalsCount);\n    colorsList = colorsList.slice(colorsCount);\n    uvRegionsList = uvRegionsList.slice(uvRegionsCount);\n    texCoordsList = texCoordsList.slice(texCoordsCount);\n  }\n\n  return groupedData.sort((first, second) => first.featureId - second.featureId);\n}\n\n/**\n * Generate sliced count for generating attribute objects depends on attribute name and range.\n * @param attributeName\n * @param startIndex\n * @param endIndex\n * @returns sliced count\n */\nfunction getSliceAttributeCount(\n  attributeName: string,\n  startIndex: number,\n  endIndex: number\n): number {\n  const itemsPerVertex4 = 4;\n  const texCoordsPerVertex = 2;\n\n  const trianglesCount = endIndex - startIndex + 1;\n  const vertexCount = trianglesCount * 3;\n\n  switch (attributeName) {\n    case 'positions':\n    case 'normals':\n      return trianglesCount * POSITIONS_AND_NORMALS_PER_TRIANGLE;\n    case 'colors':\n    case 'uvRegions':\n      return vertexCount * itemsPerVertex4;\n    case 'texCoords':\n      return vertexCount * texCoordsPerVertex;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Generates unique object list depends on feature ids and concantenate their attributes.\n * @param sortedData\n * @returns unique list of objects\n */\nfunction unifyObjectsByFeatureId(\n  sortedData: GroupedByFeatureIdAttributes[]\n): GroupedByFeatureIdAttributes[] {\n  const uniqueObjects: GroupedByFeatureIdAttributes[] = [];\n\n  for (let index = 0; index < sortedData.length; index++) {\n    const currentObject = sortedData[index];\n    const existedObject = uniqueObjects.find((obj) => obj.featureId === currentObject.featureId);\n\n    if (existedObject) {\n      existedObject.positions = concatenateTypedArrays(\n        existedObject.positions,\n        currentObject.positions\n      );\n      existedObject.normals = concatenateTypedArrays(existedObject.normals, currentObject.normals);\n      existedObject.colors = concatenateTypedArrays(existedObject.colors, currentObject.colors);\n      existedObject.texCoords = concatenateTypedArrays(\n        existedObject.texCoords,\n        currentObject.texCoords\n      );\n    } else {\n      uniqueObjects.push(currentObject);\n    }\n  }\n\n  return uniqueObjects;\n}\n\n/**\n * Generates attribute objects with new faceRange and reordered attributes.\n * @param unifiedObjects\n * @returns generated attributes with new faceRange.\n */\nfunction groupAttributesAndRangesByFeatureId(\n  unifiedObjects: GroupedByFeatureIdAttributes[],\n  featureCount: number\n): GeometryAttributes {\n  const firstAttributeObject = unifiedObjects[0];\n  const featureIds = [firstAttributeObject.featureId || 0];\n\n  let positions = new Float32Array(firstAttributeObject.positions);\n  let normals = new Float32Array(firstAttributeObject.normals);\n  let colors = new Uint8Array(firstAttributeObject.colors);\n  let uvRegions = new Uint16Array(firstAttributeObject.uvRegions);\n  let texCoords = new Float32Array(firstAttributeObject.texCoords);\n  const range = [0];\n\n  let objIndex = 0;\n  let sum = 0;\n\n  for (let index = 1; index < unifiedObjects.length; index++) {\n    const currentAttributesObject = unifiedObjects[index];\n    featureIds.push(currentAttributesObject.featureId || 0);\n\n    positions = concatenateTypedArrays(positions, currentAttributesObject.positions);\n    normals = concatenateTypedArrays(normals, currentAttributesObject.normals);\n    colors = concatenateTypedArrays(colors, currentAttributesObject.colors);\n    uvRegions = concatenateTypedArrays(uvRegions, currentAttributesObject.uvRegions);\n    texCoords = concatenateTypedArrays(texCoords, currentAttributesObject.texCoords);\n\n    const groupedObject = unifiedObjects[objIndex];\n    range.push(groupedObject.positions.length / POSITIONS_AND_NORMALS_PER_TRIANGLE - 1 + sum);\n    range.push(groupedObject.positions.length / POSITIONS_AND_NORMALS_PER_TRIANGLE + sum);\n\n    sum += groupedObject.positions.length / POSITIONS_AND_NORMALS_PER_TRIANGLE;\n    objIndex += 1;\n  }\n\n  range.push(positions.length / POSITIONS_AND_NORMALS_PER_TRIANGLE - 1);\n\n  const faceRange = new Uint32Array(range);\n  return {faceRange, featureIds, positions, normals, colors, uvRegions, texCoords, featureCount};\n}\n"],"mappings":"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"}