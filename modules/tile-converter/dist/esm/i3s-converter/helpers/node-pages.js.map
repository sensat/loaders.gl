{"version":3,"file":"node-pages.js","names":["join","transform","METADATA","metadataTemplate","isFileExists","openJson","NodePages","constructor","writeFileFunc","nodesPerPage","converter","_defineProperty","nodesCounter","nodePages","nodes","writeFile","length","useWriteFunction","func","getNodePageFileName","nodePageId","filePath","fileName","options","slpk","layers0Path","concat","toString","loadNodePage","fullName","console","log","getPageIndexByNodeId","id","Math","floor","getPageByNodeId","pageIndex","instantNodeWriting","getNodeById","nodePage","nodeIndex","addChildRelation","parentId","childId","_parentNode$children","undefined","parentNode","children","push","saveNode","node","index","currentNodePage","updateResourceInMesh","nodePageIndex","nodeToUpdate","updateAll","nodePageStr","JSON","stringify","writeQueue","enqueue","archiveKey","writePromise","compressList","saveMetadata","metadata","nodeCount","compress","save","entries","slpkPath","nodePagePath","mesh","isFinite","geometry","resource","data","Object","assign","updateMaterialByNodeId","materialId","material","definition","updateVertexCountByNodeId","vertexCount","updateNodeAttributeByNodeId","attribute","updateFeatureCountByNodeId","featureCount","updateTexelCountHintByNodeId","texelCountHint"],"sources":["../../../../src/i3s-converter/helpers/node-pages.ts"],"sourcesContent":["import {join} from 'path';\nimport transform from 'json-map-transform';\nimport {METADATA as metadataTemplate} from '../json-templates/metadata';\nimport {NodeInPage} from '@loaders.gl/i3s';\nimport {isFileExists, openJson} from '../../lib/utils/file-utils';\nimport I3SConverter from '../i3s-converter';\n\n/**\n * class NodePages - wrapper of nodePages array\n *\n * @example\n * import {writeFile} from './helpers/write-file';\n *\n * // create an instance of the class\n * const nodePages = new NodePages(writeFile, HARDCODED_NODES_PER_PAGE);\n * ...\n * // push root node\n * const parent = await nodePages.push({\n      lodThreshold: HARDCODED_MAX_SCREEN_THRESHOLD_SQ,\n      obb: coordinates.obb,\n      children: []\n    });\n * ...\n * // push node with parent relation\n * const nodeInPage = {\n      lodThreshold: HARDCODED_MAX_SCREEN_THRESHOLD_SQ,\n      obb: coordinates.obb,\n      children: [],\n      mesh: {\n        geometry: {\n          definition: 0\n        }\n      }\n    };\n * const node = await this.nodePages.push(nodeInPage, parent.index);\n * ...\n * // save all the nodePages in the end of pushing all the nodes\n * await this.nodePages.save(layers0path);\n */\nexport default class NodePages {\n  readonly nodesPerPage: number;\n  nodesCounter: number;\n  writeFile: (...args) => Promise<null | string>;\n  converter: I3SConverter;\n  readonly nodePages: {nodes: NodeInPage[]}[];\n  readonly length: number = 0;\n\n  /**\n   * @constructs\n   * Create a nodePages instance.\n   * @param writeFileFunc - function to save one nodePage into a file\n   * @param nodesPerPage - length limit for one nodePage. An additional nodePage is created when this limit is met\n   */\n  constructor(writeFileFunc, nodesPerPage, converter: I3SConverter) {\n    this.nodesPerPage = nodesPerPage;\n    this.nodesCounter = 0;\n    // @ts-expect-error\n    this.nodePages = [{}];\n    this.nodePages[0].nodes = [];\n    this.writeFile = writeFileFunc;\n    this.converter = converter;\n    this.length = 0;\n  }\n\n  /**\n   * Setup function to save node pages\n   * @param func - function which should be used to save node pages\n   */\n  useWriteFunction(func: (...args) => Promise<null | string>): void {\n    this.writeFile = func;\n  }\n\n  /**\n   * Get file path and file name of the node page with the particular id\n   * @param nodePageId - node page id\n   * @returns file path and file name\n   */\n  private getNodePageFileName(nodePageId): {filePath: string; fileName: string} {\n    let filePath;\n    let fileName;\n    if (this.converter.options.slpk) {\n      filePath = join(this.converter.layers0Path, 'nodepages');\n      fileName = `${nodePageId.toString()}.json`;\n    } else {\n      filePath = join(this.converter.layers0Path, 'nodepages', nodePageId.toString());\n      fileName = 'index.json';\n    }\n    return {filePath, fileName};\n  }\n\n  /**\n   * Load node page from a file on the disk\n   * @param nodePageId - node page id\n   * @returns - node page data\n   */\n  private async loadNodePage(nodePageId: number): Promise<{nodes: NodeInPage[]}> {\n    const {filePath, fileName} = this.getNodePageFileName(nodePageId);\n    const fullName = join(filePath, fileName);\n    if (await isFileExists(fullName)) {\n      console.log(`load ${fullName}.`); // eslint-disable-line\n      return (await openJson(filePath, fileName)) as {nodes: NodeInPage[]};\n    } else {\n      return {nodes: []};\n    }\n  }\n\n  /**\n   * Get nodepage id by node id\n   * @param id node id\n   * @returns node page id\n   */\n  private getPageIndexByNodeId(id: number): number {\n    return Math.floor(id / this.nodesPerPage);\n  }\n\n  /**\n   * Get node page data by node id\n   * @param id node id\n   * @returns node page data\n   */\n  private async getPageByNodeId(id: number): Promise<{nodes: NodeInPage[]}> {\n    const pageIndex = this.getPageIndexByNodeId(id);\n    if (this.converter.options.instantNodeWriting) {\n      return await this.loadNodePage(pageIndex);\n    }\n    return this.nodePages[pageIndex];\n  }\n\n  /**\n   * Get the node by its end-to-end index\n   * @param id - end-to-end index of the node\n   * @return the node object\n   */\n  async getNodeById(id: number, nodePage?: {nodes: NodeInPage[]}): Promise<NodeInPage> {\n    const nodeIndex = id % this.nodesPerPage;\n    nodePage = nodePage || (await this.getPageByNodeId(id));\n    return nodePage.nodes[nodeIndex];\n  }\n\n  /**\n   * Add a child id into the parent node.children array\n   * @param parentId - end-to-end parent node index\n   * @param childId - end-to-end child node index\n   */\n  private async addChildRelation(parentId: number | undefined, childId: number): Promise<void> {\n    if (parentId === null || parentId === undefined) {\n      return;\n    }\n    const parentNode = await this.getNodeById(parentId);\n    parentNode.children?.push(childId);\n    await this.saveNode(parentNode);\n  }\n\n  /**\n   * Put new node in nodePages array\n   * @param node - node object\n   * @param parentId - index of parent node\n   * @return\n   */\n  async push(node: NodeInPage, parentId?: number): Promise<NodeInPage> {\n    node.index = this.nodesCounter++;\n    if (!this.converter.options.instantNodeWriting) {\n      let currentNodePage = this.nodePages[this.nodePages.length - 1];\n      if (currentNodePage.nodes.length === this.nodesPerPage) {\n        currentNodePage = {nodes: []};\n        this.nodePages.push(currentNodePage);\n      }\n      currentNodePage.nodes.push(node);\n    }\n    await this.addChildRelation(parentId, node.index);\n    NodePages.updateResourceInMesh(node);\n    await this.saveNode(node);\n    return node;\n  }\n\n  /**\n   * Save node to the file on the disk\n   * @param node - node data\n   */\n  async saveNode(node: NodeInPage): Promise<void> {\n    if (!this.converter.options.instantNodeWriting) {\n      return;\n    } else {\n      const nodePageIndex = this.getPageIndexByNodeId(node.index);\n      const nodePage = await this.getPageByNodeId(node.index);\n      const {filePath, fileName} = this.getNodePageFileName(nodePageIndex);\n      const nodeToUpdate = await this.getNodeById(node.index, nodePage);\n      if (nodeToUpdate) {\n        NodePages.updateAll(nodeToUpdate, node);\n      } else {\n        nodePage.nodes.push(node);\n      }\n      const nodePageStr = JSON.stringify(nodePage);\n      if (this.converter.options.slpk) {\n        await this.converter.writeQueue.enqueue(\n          {\n            archiveKey: `nodePages/${nodePageIndex.toString()}.json.gz`,\n            writePromise: () =>\n              this.writeFile(filePath, nodePageStr, fileName, true, this.converter.compressList)\n          },\n          true\n        );\n      } else {\n        await this.converter.writeQueue.enqueue(\n          {\n            writePromise: () => this.writeFile(filePath, nodePageStr)\n          },\n          true\n        );\n      }\n    }\n  }\n\n  /**\n   * Save metadata file (for slpk only)\n   */\n  async saveMetadata(): Promise<void> {\n    const metadata = transform({nodeCount: this.nodesCounter}, metadataTemplate());\n    const compress = false;\n    await this.converter.writeQueue.enqueue({\n      archiveKey: 'metadata.json',\n      writePromise: () =>\n        this.writeFile(\n          this.converter.layers0Path,\n          JSON.stringify(metadata),\n          'metadata.json',\n          compress\n        )\n    });\n  }\n\n  /**\n   * Save all the node pages\n   * Run this method when all nodes is pushed in nodePages\n   */\n  async save(): Promise<void> {\n    if (this.converter.options.instantNodeWriting) {\n      await this.saveMetadata();\n      return;\n    }\n    if (this.converter.options.slpk) {\n      for (const [index, nodePage] of this.nodePages.entries()) {\n        const nodePageStr = JSON.stringify(nodePage);\n        const slpkPath = join(this.converter.layers0Path, 'nodepages');\n        await this.converter.writeQueue.enqueue({\n          archiveKey: `nodePages/${index.toString()}.json.gz`,\n          writePromise: () => this.writeFile(slpkPath, nodePageStr, `${index.toString()}.json`)\n        });\n      }\n      await this.saveMetadata();\n    } else {\n      for (const [index, nodePage] of this.nodePages.entries()) {\n        const nodePageStr = JSON.stringify(nodePage);\n        const nodePagePath = join(this.converter.layers0Path, 'nodepages', index.toString());\n        await this.converter.writeQueue.enqueue({\n          writePromise: () => this.writeFile(nodePagePath, nodePageStr)\n        });\n      }\n    }\n  }\n\n  /**\n   * Update resource index in node.mesh object\n   * @param node - node object\n   */\n  static updateResourceInMesh(node: NodeInPage): void {\n    if (node.mesh && isFinite(node.index)) {\n      node.mesh.geometry.resource = node.index;\n    }\n  }\n\n  /**\n   * Update all fields in the node excluding id\n   * @param node - node object\n   * @param data - NodeInPage data to replace original data\n   */\n  static updateAll(node: NodeInPage, data: NodeInPage): NodeInPage {\n    Object.assign(node, data, {index: node.index});\n    NodePages.updateResourceInMesh(node);\n    return node;\n  }\n\n  /**\n   * Update material in node.mesh object by node id\n   * @param id - end-to-end index of the node\n   * @param materialId - id from scene layer materialDefinitions\n   */\n  static updateMaterialByNodeId(node: NodeInPage, materialId: number): void {\n    if (!node.mesh) {\n      return;\n    }\n    node.mesh.material = {\n      definition: materialId,\n      resource: node.index\n    };\n  }\n\n  /**\n   * Update vertexCount in node.mesh.geometry object by node id\n   * @param id - end-to-end index of the node\n   * @param vertexCount - vertex count for particular node\n   */\n  static updateVertexCountByNodeId(node: NodeInPage, vertexCount: number): void {\n    if (!node.mesh) {\n      return;\n    }\n    node.mesh.geometry.vertexCount = vertexCount;\n  }\n\n  /**\n   * Update resource in node.mesh.attribute object by node id\n   * @param node - node object\n   */\n  static updateNodeAttributeByNodeId(node: NodeInPage): void {\n    if (!node.mesh || !node.index) {\n      return;\n    }\n    node.mesh.attribute.resource = node.index;\n  }\n\n  /**\n   * Update featureCount in node.mesh.geometry object by node id\n   * @param node - node object\n   * @param featureCount - features count of the node\n   */\n  static updateFeatureCountByNodeId(node: NodeInPage, featureCount: number): void {\n    if (!node.mesh) {\n      return;\n    }\n    node.mesh.geometry.featureCount = featureCount;\n  }\n\n  /**\n   * Update texelCountHint in node.mesh.material object by node id\n   * @param node - node object\n   * @param texelCountHint - texelCountHint of particular node\n   */\n  static updateTexelCountHintByNodeId(node: NodeInPage, texelCountHint: number): void {\n    if (!node.mesh || !node.mesh.material) {\n      return;\n    }\n    node.mesh.material.texelCountHint = texelCountHint;\n  }\n}\n"],"mappings":";AAAA,SAAQA,IAAI,QAAO,MAAM;AACzB,OAAOC,SAAS,MAAM,oBAAoB;AAC1C,SAAQC,QAAQ,IAAIC,gBAAgB,QAAO,4BAA4B;AAEvE,SAAQC,YAAY,EAAEC,QAAQ,QAAO,4BAA4B;AAmCjE,eAAe,MAAMC,SAAS,CAAC;EAc7BC,WAAWA,CAACC,aAAa,EAAEC,YAAY,EAAEC,SAAuB,EAAE;IAAAC,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA,iBARxC,CAAC;IASzB,IAAI,CAACF,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACG,YAAY,GAAG,CAAC;IAErB,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;IACrB,IAAI,CAACA,SAAS,CAAC,CAAC,CAAC,CAACC,KAAK,GAAG,EAAE;IAC5B,IAAI,CAACC,SAAS,GAAGP,aAAa;IAC9B,IAAI,CAACE,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACM,MAAM,GAAG,CAAC;EACjB;EAMAC,gBAAgBA,CAACC,IAAyC,EAAQ;IAChE,IAAI,CAACH,SAAS,GAAGG,IAAI;EACvB;EAOQC,mBAAmBA,CAACC,UAAU,EAAwC;IAC5E,IAAIC,QAAQ;IACZ,IAAIC,QAAQ;IACZ,IAAI,IAAI,CAACZ,SAAS,CAACa,OAAO,CAACC,IAAI,EAAE;MAC/BH,QAAQ,GAAGrB,IAAI,CAAC,IAAI,CAACU,SAAS,CAACe,WAAW,EAAE,WAAW,CAAC;MACxDH,QAAQ,MAAAI,MAAA,CAAMN,UAAU,CAACO,QAAQ,CAAC,CAAC,UAAO;IAC5C,CAAC,MAAM;MACLN,QAAQ,GAAGrB,IAAI,CAAC,IAAI,CAACU,SAAS,CAACe,WAAW,EAAE,WAAW,EAAEL,UAAU,CAACO,QAAQ,CAAC,CAAC,CAAC;MAC/EL,QAAQ,GAAG,YAAY;IACzB;IACA,OAAO;MAACD,QAAQ;MAAEC;IAAQ,CAAC;EAC7B;EAOA,MAAcM,YAAYA,CAACR,UAAkB,EAAkC;IAC7E,MAAM;MAACC,QAAQ;MAAEC;IAAQ,CAAC,GAAG,IAAI,CAACH,mBAAmB,CAACC,UAAU,CAAC;IACjE,MAAMS,QAAQ,GAAG7B,IAAI,CAACqB,QAAQ,EAAEC,QAAQ,CAAC;IACzC,IAAI,MAAMlB,YAAY,CAACyB,QAAQ,CAAC,EAAE;MAChCC,OAAO,CAACC,GAAG,SAAAL,MAAA,CAASG,QAAQ,MAAG,CAAC;MAChC,OAAQ,MAAMxB,QAAQ,CAACgB,QAAQ,EAAEC,QAAQ,CAAC;IAC5C,CAAC,MAAM;MACL,OAAO;QAACR,KAAK,EAAE;MAAE,CAAC;IACpB;EACF;EAOQkB,oBAAoBA,CAACC,EAAU,EAAU;IAC/C,OAAOC,IAAI,CAACC,KAAK,CAACF,EAAE,GAAG,IAAI,CAACxB,YAAY,CAAC;EAC3C;EAOA,MAAc2B,eAAeA,CAACH,EAAU,EAAkC;IACxE,MAAMI,SAAS,GAAG,IAAI,CAACL,oBAAoB,CAACC,EAAE,CAAC;IAC/C,IAAI,IAAI,CAACvB,SAAS,CAACa,OAAO,CAACe,kBAAkB,EAAE;MAC7C,OAAO,MAAM,IAAI,CAACV,YAAY,CAACS,SAAS,CAAC;IAC3C;IACA,OAAO,IAAI,CAACxB,SAAS,CAACwB,SAAS,CAAC;EAClC;EAOA,MAAME,WAAWA,CAACN,EAAU,EAAEO,QAAgC,EAAuB;IACnF,MAAMC,SAAS,GAAGR,EAAE,GAAG,IAAI,CAACxB,YAAY;IACxC+B,QAAQ,GAAGA,QAAQ,KAAK,MAAM,IAAI,CAACJ,eAAe,CAACH,EAAE,CAAC,CAAC;IACvD,OAAOO,QAAQ,CAAC1B,KAAK,CAAC2B,SAAS,CAAC;EAClC;EAOA,MAAcC,gBAAgBA,CAACC,QAA4B,EAAEC,OAAe,EAAiB;IAAA,IAAAC,oBAAA;IAC3F,IAAIF,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAKG,SAAS,EAAE;MAC/C;IACF;IACA,MAAMC,UAAU,GAAG,MAAM,IAAI,CAACR,WAAW,CAACI,QAAQ,CAAC;IACnD,CAAAE,oBAAA,GAAAE,UAAU,CAACC,QAAQ,cAAAH,oBAAA,uBAAnBA,oBAAA,CAAqBI,IAAI,CAACL,OAAO,CAAC;IAClC,MAAM,IAAI,CAACM,QAAQ,CAACH,UAAU,CAAC;EACjC;EAQA,MAAME,IAAIA,CAACE,IAAgB,EAAER,QAAiB,EAAuB;IACnEQ,IAAI,CAACC,KAAK,GAAG,IAAI,CAACxC,YAAY,EAAE;IAChC,IAAI,CAAC,IAAI,CAACF,SAAS,CAACa,OAAO,CAACe,kBAAkB,EAAE;MAC9C,IAAIe,eAAe,GAAG,IAAI,CAACxC,SAAS,CAAC,IAAI,CAACA,SAAS,CAACG,MAAM,GAAG,CAAC,CAAC;MAC/D,IAAIqC,eAAe,CAACvC,KAAK,CAACE,MAAM,KAAK,IAAI,CAACP,YAAY,EAAE;QACtD4C,eAAe,GAAG;UAACvC,KAAK,EAAE;QAAE,CAAC;QAC7B,IAAI,CAACD,SAAS,CAACoC,IAAI,CAACI,eAAe,CAAC;MACtC;MACAA,eAAe,CAACvC,KAAK,CAACmC,IAAI,CAACE,IAAI,CAAC;IAClC;IACA,MAAM,IAAI,CAACT,gBAAgB,CAACC,QAAQ,EAAEQ,IAAI,CAACC,KAAK,CAAC;IACjD9C,SAAS,CAACgD,oBAAoB,CAACH,IAAI,CAAC;IACpC,MAAM,IAAI,CAACD,QAAQ,CAACC,IAAI,CAAC;IACzB,OAAOA,IAAI;EACb;EAMA,MAAMD,QAAQA,CAACC,IAAgB,EAAiB;IAC9C,IAAI,CAAC,IAAI,CAACzC,SAAS,CAACa,OAAO,CAACe,kBAAkB,EAAE;MAC9C;IACF,CAAC,MAAM;MACL,MAAMiB,aAAa,GAAG,IAAI,CAACvB,oBAAoB,CAACmB,IAAI,CAACC,KAAK,CAAC;MAC3D,MAAMZ,QAAQ,GAAG,MAAM,IAAI,CAACJ,eAAe,CAACe,IAAI,CAACC,KAAK,CAAC;MACvD,MAAM;QAAC/B,QAAQ;QAAEC;MAAQ,CAAC,GAAG,IAAI,CAACH,mBAAmB,CAACoC,aAAa,CAAC;MACpE,MAAMC,YAAY,GAAG,MAAM,IAAI,CAACjB,WAAW,CAACY,IAAI,CAACC,KAAK,EAAEZ,QAAQ,CAAC;MACjE,IAAIgB,YAAY,EAAE;QAChBlD,SAAS,CAACmD,SAAS,CAACD,YAAY,EAAEL,IAAI,CAAC;MACzC,CAAC,MAAM;QACLX,QAAQ,CAAC1B,KAAK,CAACmC,IAAI,CAACE,IAAI,CAAC;MAC3B;MACA,MAAMO,WAAW,GAAGC,IAAI,CAACC,SAAS,CAACpB,QAAQ,CAAC;MAC5C,IAAI,IAAI,CAAC9B,SAAS,CAACa,OAAO,CAACC,IAAI,EAAE;QAC/B,MAAM,IAAI,CAACd,SAAS,CAACmD,UAAU,CAACC,OAAO,CACrC;UACEC,UAAU,eAAArC,MAAA,CAAe6B,aAAa,CAAC5B,QAAQ,CAAC,CAAC,aAAU;UAC3DqC,YAAY,EAAEA,CAAA,KACZ,IAAI,CAACjD,SAAS,CAACM,QAAQ,EAAEqC,WAAW,EAAEpC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAACZ,SAAS,CAACuD,YAAY;QACrF,CAAC,EACD,IACF,CAAC;MACH,CAAC,MAAM;QACL,MAAM,IAAI,CAACvD,SAAS,CAACmD,UAAU,CAACC,OAAO,CACrC;UACEE,YAAY,EAAEA,CAAA,KAAM,IAAI,CAACjD,SAAS,CAACM,QAAQ,EAAEqC,WAAW;QAC1D,CAAC,EACD,IACF,CAAC;MACH;IACF;EACF;EAKA,MAAMQ,YAAYA,CAAA,EAAkB;IAClC,MAAMC,QAAQ,GAAGlE,SAAS,CAAC;MAACmE,SAAS,EAAE,IAAI,CAACxD;IAAY,CAAC,EAAET,gBAAgB,CAAC,CAAC,CAAC;IAC9E,MAAMkE,QAAQ,GAAG,KAAK;IACtB,MAAM,IAAI,CAAC3D,SAAS,CAACmD,UAAU,CAACC,OAAO,CAAC;MACtCC,UAAU,EAAE,eAAe;MAC3BC,YAAY,EAAEA,CAAA,KACZ,IAAI,CAACjD,SAAS,CACZ,IAAI,CAACL,SAAS,CAACe,WAAW,EAC1BkC,IAAI,CAACC,SAAS,CAACO,QAAQ,CAAC,EACxB,eAAe,EACfE,QACF;IACJ,CAAC,CAAC;EACJ;EAMA,MAAMC,IAAIA,CAAA,EAAkB;IAC1B,IAAI,IAAI,CAAC5D,SAAS,CAACa,OAAO,CAACe,kBAAkB,EAAE;MAC7C,MAAM,IAAI,CAAC4B,YAAY,CAAC,CAAC;MACzB;IACF;IACA,IAAI,IAAI,CAACxD,SAAS,CAACa,OAAO,CAACC,IAAI,EAAE;MAC/B,KAAK,MAAM,CAAC4B,KAAK,EAAEZ,QAAQ,CAAC,IAAI,IAAI,CAAC3B,SAAS,CAAC0D,OAAO,CAAC,CAAC,EAAE;QACxD,MAAMb,WAAW,GAAGC,IAAI,CAACC,SAAS,CAACpB,QAAQ,CAAC;QAC5C,MAAMgC,QAAQ,GAAGxE,IAAI,CAAC,IAAI,CAACU,SAAS,CAACe,WAAW,EAAE,WAAW,CAAC;QAC9D,MAAM,IAAI,CAACf,SAAS,CAACmD,UAAU,CAACC,OAAO,CAAC;UACtCC,UAAU,eAAArC,MAAA,CAAe0B,KAAK,CAACzB,QAAQ,CAAC,CAAC,aAAU;UACnDqC,YAAY,EAAEA,CAAA,KAAM,IAAI,CAACjD,SAAS,CAACyD,QAAQ,EAAEd,WAAW,KAAAhC,MAAA,CAAK0B,KAAK,CAACzB,QAAQ,CAAC,CAAC,UAAO;QACtF,CAAC,CAAC;MACJ;MACA,MAAM,IAAI,CAACuC,YAAY,CAAC,CAAC;IAC3B,CAAC,MAAM;MACL,KAAK,MAAM,CAACd,KAAK,EAAEZ,QAAQ,CAAC,IAAI,IAAI,CAAC3B,SAAS,CAAC0D,OAAO,CAAC,CAAC,EAAE;QACxD,MAAMb,WAAW,GAAGC,IAAI,CAACC,SAAS,CAACpB,QAAQ,CAAC;QAC5C,MAAMiC,YAAY,GAAGzE,IAAI,CAAC,IAAI,CAACU,SAAS,CAACe,WAAW,EAAE,WAAW,EAAE2B,KAAK,CAACzB,QAAQ,CAAC,CAAC,CAAC;QACpF,MAAM,IAAI,CAACjB,SAAS,CAACmD,UAAU,CAACC,OAAO,CAAC;UACtCE,YAAY,EAAEA,CAAA,KAAM,IAAI,CAACjD,SAAS,CAAC0D,YAAY,EAAEf,WAAW;QAC9D,CAAC,CAAC;MACJ;IACF;EACF;EAMA,OAAOJ,oBAAoBA,CAACH,IAAgB,EAAQ;IAClD,IAAIA,IAAI,CAACuB,IAAI,IAAIC,QAAQ,CAACxB,IAAI,CAACC,KAAK,CAAC,EAAE;MACrCD,IAAI,CAACuB,IAAI,CAACE,QAAQ,CAACC,QAAQ,GAAG1B,IAAI,CAACC,KAAK;IAC1C;EACF;EAOA,OAAOK,SAASA,CAACN,IAAgB,EAAE2B,IAAgB,EAAc;IAC/DC,MAAM,CAACC,MAAM,CAAC7B,IAAI,EAAE2B,IAAI,EAAE;MAAC1B,KAAK,EAAED,IAAI,CAACC;IAAK,CAAC,CAAC;IAC9C9C,SAAS,CAACgD,oBAAoB,CAACH,IAAI,CAAC;IACpC,OAAOA,IAAI;EACb;EAOA,OAAO8B,sBAAsBA,CAAC9B,IAAgB,EAAE+B,UAAkB,EAAQ;IACxE,IAAI,CAAC/B,IAAI,CAACuB,IAAI,EAAE;MACd;IACF;IACAvB,IAAI,CAACuB,IAAI,CAACS,QAAQ,GAAG;MACnBC,UAAU,EAAEF,UAAU;MACtBL,QAAQ,EAAE1B,IAAI,CAACC;IACjB,CAAC;EACH;EAOA,OAAOiC,yBAAyBA,CAAClC,IAAgB,EAAEmC,WAAmB,EAAQ;IAC5E,IAAI,CAACnC,IAAI,CAACuB,IAAI,EAAE;MACd;IACF;IACAvB,IAAI,CAACuB,IAAI,CAACE,QAAQ,CAACU,WAAW,GAAGA,WAAW;EAC9C;EAMA,OAAOC,2BAA2BA,CAACpC,IAAgB,EAAQ;IACzD,IAAI,CAACA,IAAI,CAACuB,IAAI,IAAI,CAACvB,IAAI,CAACC,KAAK,EAAE;MAC7B;IACF;IACAD,IAAI,CAACuB,IAAI,CAACc,SAAS,CAACX,QAAQ,GAAG1B,IAAI,CAACC,KAAK;EAC3C;EAOA,OAAOqC,0BAA0BA,CAACtC,IAAgB,EAAEuC,YAAoB,EAAQ;IAC9E,IAAI,CAACvC,IAAI,CAACuB,IAAI,EAAE;MACd;IACF;IACAvB,IAAI,CAACuB,IAAI,CAACE,QAAQ,CAACc,YAAY,GAAGA,YAAY;EAChD;EAOA,OAAOC,4BAA4BA,CAACxC,IAAgB,EAAEyC,cAAsB,EAAQ;IAClF,IAAI,CAACzC,IAAI,CAACuB,IAAI,IAAI,CAACvB,IAAI,CAACuB,IAAI,CAACS,QAAQ,EAAE;MACrC;IACF;IACAhC,IAAI,CAACuB,IAAI,CAACS,QAAQ,CAACS,cAAc,GAAGA,cAAc;EACpD;AACF"}