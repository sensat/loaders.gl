{"version":3,"file":"geometry-converter.js","names":["Vector3","Matrix4","Vector4","Ellipsoid","DracoWriterWorker","assert","encode","concatenateArrayBuffers","concatenateTypedArrays","md5","v4","uuidv4","generateAttributes","createBoundingVolumesFromGeometry","prepareDataForAttributesConversion","handleBatchIdsExtensions","checkPropertiesLength","flattenPropertyTableByFeatureIds","GL","generateSyntheticIndices","DEFAULT_ROUGHNESS_FACTOR","DEFAULT_METALLIC_FACTOR","VALUES_PER_VERTEX","VALUES_PER_TEX_COORD","VALUES_PER_COLOR_ELEMENT","STRING_TYPE","SHORT_INT_TYPE","DOUBLE_TYPE","OBJECT_ID_TYPE","BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES","EXT_FEATURE_METADATA","EXT_MESH_FEATURES","scratchVector","convertB3dmToI3sGeometry","tileContent","addNodeToNodePage","propertyTable","featuresHashArray","attributeStorageInfo","draco","generateBoundingVolumes","shouldMergeMaterials","geoidHeightModel","workerSource","_tileContent$gltf","useCartesianPositions","materialAndTextureList","convertMaterials","gltf","materials","dataForAttributesConversion","convertedAttributesMap","convertAttributes","_generateBoundingVolumesFromGeometry","result","materialAndTexture","originarMaterialId","mergedMaterials","originalMaterialId","has","convertedAttributes","get","material","texture","nodeId","push","_makeNodeResources","length","attributes","values","boundingVolumes","positions","cartographicOrigin","obb","center","index","vertex","subarray","WGS84","cartesianToCartographic","Array","from","getHeight","subtract","set","_ref","_tileContent$gltf2","vertexCount","faceRange","featureIds","normals","colors","uvRegions","texCoords","featureCount","batchTableJson","makeFeatureIdsUnique","featureIndices","header","Uint32Array","typedFeatureIds","generateBigUint64Array","fileBuffer","Uint8Array","buffer","ArrayBuffer","compressedGeometry","generateCompressedGeometry","Float32Array","convertPropertyTableToAttributeBuffers","geometry","hasUvRegions","Boolean","sharedResources","getSharedResources","meshMaterial","attributesData","nodes","images","cartesianModelMatrix","attributesMap","Map","Uint16Array","featureIndicesGroups","mergedMaterial","convertNodes","attrKey","keys","delete","reduce","acc","value","concat","matrix","arguments","undefined","node","convertNode","getCompositeTransformationMatrix","transformationMatrix","nodeMatrix","rotation","scale","translation","multiplyRight","translate","rotateXYZ","mesh","convertMesh","children","primitive","primitives","outputAttributes","materialUvRegion","_outputAttributes","_outputAttributes$mer","id","find","_ref2","_primitive$material","uvRegion","mode","TRIANGLES","TRIANGLE_STRIP","indices","normalizeIndices","transformVertexArray","vertices","POSITION","attributeSpecificTransformation","transformVertexPositions","NORMAL","transformVertexNormals","flattenTexCoords","TEXCOORD_0","flattenColors","COLOR_0","createUvRegion","flattenBatchIds","getBatchIds","_primitive$indices","TypedArrayConstructor","constructor","newIndices","triangleIndex","currentTriangle","slice","i","reverse","args","newVertices","coordIndex","vertexVector","x","y","z","calleeArgs","transform","transformAsVector","newTexCoords","fill","texCoord","colorsAttribute","components","newColors","colorIndex","color","colorUint8","j","batchedIds","newBatchIds","batchIds","possibleBatchIdAttributeName","sourceMaterials","sourceMaterial","convertMaterial","mergeAllMaterials","newMaterial","splice","mergedIndices","mergeMaterials","_newMaterial$mergedMa","_newMaterial$mergedMa2","newWidth","accum","_ref3","textureSize","width","newHeight","_ref4","Math","max","height","currentX","aTextureMetadata","newX","BYTES_PER_ELEMENT","image","getDefaultMaterial","material1","material2","_material1$texture","_material2$texture","bufferView","buffer1","Buffer","data","buffer2","joinImages","sharpData","direction","toFormat","mimeType","toBuffer","error","console","log","pbrMetallicRoughness","baseColorTexture","textureSetDefinitionId","_sourceMaterial$emiss","_sourceMaterial$pbrMe","_sourceMaterial$pbrMe2","_sourceMaterial$pbrMe3","doubleSided","emissiveFactor","map","c","round","alphaMode","convertAlphaMode","roughnessFactor","metallicFactor","source","emissiveTexture","Number","isFinite","_sourceMaterial$pbrMe4","baseColorFactor","gltfAlphaMode","gltfMaterials","i3sResources","materialDefinitionInfos","gltfMaterial","materialDefinitionInfo","textureDefinitionInfo","convertGLTFMaterialToI3sSharedResources","textureDefinitionInfos","_gltfMaterial$pbrMeta","extractSharedResourcesTextureInfo","colorFactor","extractSharedResourcesMaterialInfo","matDielectricColorComponent","black","unitVector","dielectricSpecular","baseColorVector","firstOperand","multiply","diffuse","lerp","specular","params","toArray","renderMode","_texture$source","_texture$source2","_texture$source3","_texture$source4","encoding","generateImageId","size","_texture$source5","levelCountOfTexture","indexOfLevel","indexOfTextureInStore","zerosCount","toString","rightHalf","repeat","shiftedLevelCountOfTexture","shiftedIndexOfLevel","shiftedWidth","shiftedHeight","leftHalf","imageId","BigInt","batchTable","replaceMap","getFeaturesReplaceMap","replaceIndicesByUnique","featureMap","oldFeatureId","uniqueFeatureId","getOrCreateUniqueFeatureId","generateStringFromBatchTableByIndex","str","key","batchTableStr","hash","includes","indexOf","indicesArray","attributeBuffers","needFlattenPropertyTable","properties","propertyTableWithObjectIds","OBJECTID","propertyName","type","getAttributeType","attributeBuffer","generateAttributeBuffer","generateShortIntegerAttributeBuffer","generateDoubleAttributeBuffer","generateStringAttributeBuffer","attribute","attr","name","attributeValues","valueType","count","valuesArray","padding","Float64Array","batchAttributes","stringCountArray","totalNumberOfBytes","stringSizesArray","stringBufferArray","currentString","String","currentStringBuffer","currentStringSize","totalBytes","BigUint64Array","dracoWorkerSoure","featureIndex","generateFeatureIndexAttribute","compressedAttributes","attributesMetadata","Int32Array","options","reuseWorkers","_nodeWorkers","method","orderedFeatureIndices","fillIndex","startIndex","endIndex","getPropertyTable","extensionName","extension","getPropertyTableExtension","warn","getPropertyTableFromExtFeatureMetadata","_tileContent$gltf3","_tileContent$gltf5","_tileContent$gltf5$ex","extensionsWithPropertyTables","extensionsUsed","extensionItem","_tileContent$gltf4","extensions","featureTextures","featureTables","_Object$keys","firstFeatureTableName","Object","featureTable"],"sources":["../../../../src/i3s-converter/helpers/geometry-converter.ts"],"sourcesContent":["import type {B3DMContent, FeatureTableJson} from '@loaders.gl/3d-tiles';\nimport type {\n  GLTF_EXT_feature_metadata,\n  GLTF_EXT_mesh_features,\n  GLTFAccessorPostprocessed,\n  GLTFMaterialPostprocessed,\n  GLTFNodePostprocessed,\n  GLTFMeshPrimitivePostprocessed,\n  GLTFMeshPostprocessed,\n  GLTFTexturePostprocessed\n} from '@loaders.gl/gltf';\n\nimport {Vector3, Matrix4, Vector4} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nimport {DracoWriterWorker} from '@loaders.gl/draco';\nimport {assert, encode} from '@loaders.gl/core';\nimport {concatenateArrayBuffers, concatenateTypedArrays} from '@loaders.gl/loader-utils';\nimport md5 from 'md5';\nimport {v4 as uuidv4} from 'uuid';\nimport {generateAttributes} from './geometry-attributes';\nimport {createBoundingVolumesFromGeometry} from './coordinate-converter';\nimport {\n  ConvertedAttributes,\n  I3SConvertedResources,\n  I3SMaterialWithTexture,\n  MergedMaterial,\n  SharedResourcesArrays\n} from '../types';\nimport {\n  AttributeStorageInfo,\n  I3SMaterialDefinition,\n  MaterialDefinitionInfo,\n  TextureDefinitionInfo\n} from '@loaders.gl/i3s';\nimport {NumberArray, TypedArray} from '@loaders.gl/loader-utils';\nimport {Geoid} from '@math.gl/geoid';\n/** Usage of worker here brings more overhead than advantage */\nimport {\n  B3DMAttributesData /*, transformI3SAttributesOnWorker*/,\n  TextureImageProperties\n} from '../../i3s-attributes-worker';\nimport {prepareDataForAttributesConversion} from './gltf-attributes';\nimport {handleBatchIdsExtensions} from './batch-ids-extensions';\nimport {checkPropertiesLength, flattenPropertyTableByFeatureIds} from './feature-attributes';\nimport {GL} from '@loaders.gl/math';\n\n/*\n  At the moment of writing the type TypedArrayConstructor is not exported in '@math.gl/types'.\n  So the following import is replaced with the local import\n  import type {TypedArrayConstructor} from '@math.gl/types'; \n*/\nimport type {TypedArrayConstructor} from '../types';\nimport {generateSyntheticIndices} from '../../lib/utils/geometry-utils';\n\n// Spec - https://github.com/Esri/i3s-spec/blob/master/docs/1.7/pbrMetallicRoughness.cmn.md\nconst DEFAULT_ROUGHNESS_FACTOR = 1;\nconst DEFAULT_METALLIC_FACTOR = 1;\n\nconst VALUES_PER_VERTEX = 3;\nconst VALUES_PER_TEX_COORD = 2;\nconst VALUES_PER_COLOR_ELEMENT = 4;\n\nconst STRING_TYPE = 'string';\nconst SHORT_INT_TYPE = 'Int32';\nconst DOUBLE_TYPE = 'Float64';\nconst OBJECT_ID_TYPE = 'Oid32';\n/*\n * 'CUSTOM_ATTRIBUTE_2' - Attribute name which includes batch info and used by New York map.\n * _BATCHID - Default attribute name which includes batch info.\n * BATCHID - Legacy attribute name which includes batch info.\n */\nconst BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES = ['CUSTOM_ATTRIBUTE_2', '_BATCHID', 'BATCHID'];\n\nconst EXT_FEATURE_METADATA = 'EXT_feature_metadata';\nconst EXT_MESH_FEATURES = 'EXT_mesh_features';\n\nlet scratchVector = new Vector3();\n\n/**\n * Convert binary data from b3dm file to i3s resources\n *\n * @param tileContent - 3d tile content\n * @param addNodeToNodePage - function to add new node to node pages\n * @param propertyTable - batch table (corresponding to feature attributes data)\n * @param featuresHashArray - hash array of features that is needed to not to mix up same features in parent and child nodes\n * @param attributeStorageInfo - attributes metadata from 3DSceneLayer json\n * @param draco - is converter should create draco compressed geometry\n * @param generateBoundingVolumes - is converter should create accurate bounding voulmes from geometry attributes\n * @param shouldMergeMaterials - Try to merge similar materials to be able to merge meshes into one node\n * @param geoidHeightModel - model to convert elevation from elipsoidal to geoid\n * @param workerSource - source code of used workers\n * @returns Array of node resources to create one or more i3s nodes\n */\nexport default async function convertB3dmToI3sGeometry(\n  tileContent: B3DMContent,\n  addNodeToNodePage: () => Promise<number>,\n  propertyTable: FeatureTableJson | null,\n  featuresHashArray: string[],\n  attributeStorageInfo: AttributeStorageInfo[] | undefined,\n  draco: boolean,\n  generateBoundingVolumes: boolean,\n  shouldMergeMaterials: boolean,\n  geoidHeightModel: Geoid,\n  workerSource: {[key: string]: string}\n): Promise<I3SConvertedResources[] | null> {\n  const useCartesianPositions = generateBoundingVolumes;\n  const materialAndTextureList: I3SMaterialWithTexture[] = await convertMaterials(\n    tileContent.gltf?.materials,\n    shouldMergeMaterials\n  );\n\n  const dataForAttributesConversion = prepareDataForAttributesConversion(tileContent);\n  const convertedAttributesMap: Map<string, ConvertedAttributes> = await convertAttributes(\n    dataForAttributesConversion,\n    materialAndTextureList,\n    useCartesianPositions\n  );\n  /** Usage of worker here brings more overhead than advantage */\n  // const convertedAttributesMap: Map<string, ConvertedAttributes> =\n  //   await transformI3SAttributesOnWorker(dataForAttributesConversion, {\n  //     reuseWorkers: true,\n  //     _nodeWorkers: true,\n  //     useCartesianPositions,\n  //     source: workerSource.I3SAttributes\n  //   });\n\n  if (generateBoundingVolumes) {\n    _generateBoundingVolumesFromGeometry(convertedAttributesMap, geoidHeightModel);\n  }\n\n  const result: I3SConvertedResources[] = [];\n  for (const materialAndTexture of materialAndTextureList) {\n    const originarMaterialId = materialAndTexture.mergedMaterials[0].originalMaterialId;\n    if (!convertedAttributesMap.has(originarMaterialId)) {\n      continue; // eslint-disable-line no-continue\n    }\n    const convertedAttributes = convertedAttributesMap.get(originarMaterialId);\n    if (!convertedAttributes) {\n      continue;\n    }\n    const {material, texture} = materialAndTexture;\n    const nodeId = await addNodeToNodePage();\n    result.push(\n      await _makeNodeResources({\n        convertedAttributes,\n        material,\n        texture,\n        tileContent,\n        nodeId,\n        featuresHashArray,\n        propertyTable,\n        attributeStorageInfo,\n        draco,\n        workerSource\n      })\n    );\n  }\n\n  if (!result.length) {\n    return null;\n  }\n  return result;\n}\n\n/**\n * Create bounding volumes based on positions\n * @param convertedAttributesMap - geometry attributes map\n * @param geoidHeightModel - geoid height model to convert elevation from elipsoidal to geoid\n */\nfunction _generateBoundingVolumesFromGeometry(\n  convertedAttributesMap: Map<string, ConvertedAttributes>,\n  geoidHeightModel: Geoid\n) {\n  for (const attributes of convertedAttributesMap.values()) {\n    const boundingVolumes = createBoundingVolumesFromGeometry(\n      attributes.positions,\n      geoidHeightModel\n    );\n\n    attributes.boundingVolumes = boundingVolumes;\n    const cartographicOrigin = boundingVolumes.obb.center;\n\n    for (let index = 0; index < attributes.positions.length; index += VALUES_PER_VERTEX) {\n      const vertex = attributes.positions.subarray(index, index + VALUES_PER_VERTEX);\n      Ellipsoid.WGS84.cartesianToCartographic(Array.from(vertex), scratchVector);\n      scratchVector[2] =\n        scratchVector[2] - geoidHeightModel.getHeight(scratchVector[1], scratchVector[0]);\n      scratchVector = scratchVector.subtract(cartographicOrigin);\n      attributes.positions.set(scratchVector, index);\n    }\n  }\n}\n\n/**\n *\n * @param params\n * @param params.convertedAttributes - Converted geometry attributes\n * @param params.material - I3S PBR-like material definition\n * @param params.texture - texture content\n * @param params.tileContent - B3DM decoded content\n * @param params.nodeId - new node ID\n * @param params.featuresHashArray - hash array of features that is needed to not to mix up same features in parent and child nodes\n * @param params.propertyTable - batch table (corresponding to feature attributes data)\n * @param params.attributeStorageInfo - attributes metadata from 3DSceneLayer json\n * @param params.draco - is converter should create draco compressed geometry\n * @param params.workerSource - source code of used workers\n * @returns Array of I3S node resources\n */\nasync function _makeNodeResources({\n  convertedAttributes,\n  material,\n  texture,\n  tileContent,\n  nodeId,\n  featuresHashArray,\n  propertyTable,\n  attributeStorageInfo,\n  draco,\n  workerSource\n}: {\n  convertedAttributes: ConvertedAttributes;\n  material: I3SMaterialDefinition;\n  texture?: {};\n  tileContent: B3DMContent;\n  nodeId: number;\n  featuresHashArray: string[];\n  propertyTable: FeatureTableJson | null;\n  attributeStorageInfo?: AttributeStorageInfo[];\n  draco: boolean;\n  workerSource: {[key: string]: string};\n}): Promise<I3SConvertedResources> {\n  const boundingVolumes = convertedAttributes.boundingVolumes;\n  const vertexCount = convertedAttributes.positions.length / VALUES_PER_VERTEX;\n  const {faceRange, featureIds, positions, normals, colors, uvRegions, texCoords, featureCount} =\n    generateAttributes(convertedAttributes);\n\n  if (tileContent.batchTableJson) {\n    makeFeatureIdsUnique(\n      featureIds,\n      convertedAttributes.featureIndices,\n      featuresHashArray,\n      tileContent.batchTableJson\n    );\n  }\n\n  const header = new Uint32Array(2);\n  const typedFeatureIds = generateBigUint64Array(featureIds);\n\n  header.set([vertexCount, featureCount], 0);\n  const fileBuffer = new Uint8Array(\n    concatenateArrayBuffers(\n      header.buffer,\n      positions.buffer,\n      normals.buffer,\n      texture ? texCoords.buffer : new ArrayBuffer(0),\n      colors.buffer,\n      uvRegions,\n      typedFeatureIds.buffer,\n      faceRange.buffer\n    )\n  );\n  const compressedGeometry = draco\n    ? generateCompressedGeometry(\n        vertexCount,\n        convertedAttributes,\n        {\n          positions,\n          normals,\n          texCoords: texture ? texCoords : new Float32Array(0),\n          colors,\n          uvRegions,\n          featureIds,\n          faceRange\n        },\n        workerSource.draco\n      )\n    : null;\n\n  let attributes: ArrayBuffer[] = [];\n\n  if (attributeStorageInfo && propertyTable) {\n    attributes = convertPropertyTableToAttributeBuffers(\n      featureIds,\n      propertyTable,\n      attributeStorageInfo\n    );\n  }\n\n  return {\n    nodeId,\n    geometry: fileBuffer,\n    compressedGeometry,\n    texture,\n    hasUvRegions: Boolean(uvRegions.length),\n    sharedResources: getSharedResources(tileContent.gltf?.materials || [], nodeId),\n    meshMaterial: material,\n    vertexCount,\n    attributes,\n    featureCount,\n    boundingVolumes\n  };\n}\n\n/**\n * Convert attributes from the gltf nodes tree to i3s plain geometry\n * @param attributesData - geometry attributes from gltf\n * @param materialAndTextureList - array of data about materials and textures of the content\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets.\n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @returns map of converted geometry attributes\n */\nexport async function convertAttributes(\n  attributesData: B3DMAttributesData,\n  materialAndTextureList: I3SMaterialWithTexture[],\n  useCartesianPositions: boolean\n): Promise<Map<string, ConvertedAttributes>> {\n  const {nodes, images, cartographicOrigin, cartesianModelMatrix} = attributesData;\n  const attributesMap = new Map<string, ConvertedAttributes>();\n\n  for (const materialAndTexture of materialAndTextureList) {\n    const attributes = {\n      positions: new Float32Array(0),\n      normals: new Float32Array(0),\n      texCoords: new Float32Array(0),\n      colors: new Uint8Array(0),\n      uvRegions: new Uint16Array(0),\n      featureIndicesGroups: [],\n      featureIndices: [],\n      boundingVolumes: null,\n      mergedMaterials: materialAndTexture.mergedMaterials\n    };\n    for (const mergedMaterial of materialAndTexture.mergedMaterials) {\n      attributesMap.set(mergedMaterial.originalMaterialId, attributes);\n    }\n  }\n\n  convertNodes(\n    nodes,\n    images,\n    cartographicOrigin,\n    cartesianModelMatrix,\n    attributesMap,\n    useCartesianPositions\n  );\n\n  for (const attrKey of attributesMap.keys()) {\n    const attributes = attributesMap.get(attrKey);\n    if (!attributes) {\n      continue;\n    }\n    if (attributes.positions.length === 0) {\n      attributesMap.delete(attrKey);\n      continue; // eslint-disable-line no-continue\n    }\n    if (attributes.featureIndicesGroups) {\n      attributes.featureIndices = attributes.featureIndicesGroups.reduce((acc, value) =>\n        acc.concat(value)\n      );\n      delete attributes.featureIndicesGroups;\n    }\n  }\n\n  return attributesMap;\n}\n\n/**\n * Gltf has hierarchical structure of nodes. This function converts nodes starting from those which are in gltf scene object.\n *   The goal is applying tranformation matrix for all children. Functions \"convertNodes\" and \"convertNode\" work together recursively.\n * @param nodes - gltf nodes array\n * @param images - gltf images array\n * @param cartographicOrigin - cartographic origin of bounding volume\n * @param cartesianModelMatrix - cartesian model matrix to convert coordinates to cartographic\n * @param attributesMap - for recursive concatenation of attributes\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets.\n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @param matrix - transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @returns {void}\n */\nfunction convertNodes(\n  nodes: GLTFNodePostprocessed[],\n  images: (TextureImageProperties | null)[],\n  cartographicOrigin: Vector3,\n  cartesianModelMatrix: Matrix4,\n  attributesMap: Map<string, ConvertedAttributes>,\n  useCartesianPositions: boolean,\n  matrix: Matrix4 = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n) {\n  if (nodes) {\n    for (const node of nodes) {\n      convertNode(\n        node,\n        images,\n        cartographicOrigin,\n        cartesianModelMatrix,\n        attributesMap,\n        useCartesianPositions,\n        matrix\n      );\n    }\n  }\n}\n\n/**\n * Generate transformation matrix for node\n * Aapply all gltf transformations to initial transformation matrix.\n * @param node\n * @param matrix\n */\nfunction getCompositeTransformationMatrix(node: GLTFNodePostprocessed, matrix: Matrix4) {\n  let transformationMatrix = matrix;\n\n  const {matrix: nodeMatrix, rotation, scale, translation} = node;\n\n  if (nodeMatrix) {\n    transformationMatrix = matrix.multiplyRight(nodeMatrix);\n  }\n\n  if (translation) {\n    transformationMatrix = transformationMatrix.translate(translation);\n  }\n\n  if (rotation) {\n    transformationMatrix = transformationMatrix.rotateXYZ(rotation);\n  }\n\n  if (scale) {\n    transformationMatrix = transformationMatrix.scale(scale);\n  }\n\n  return transformationMatrix;\n}\n\n/**\n * Convert all primitives of node and all children nodes\n * @param node - gltf node\n * @param images - gltf images array\n * @param cartographicOrigin - cartographic origin of bounding volume\n * @param cartesianModelMatrix - cartesian model matrix to convert coordinates to cartographic\n * @param {Map} attributesMap Map<{positions: Float32Array, normals: Float32Array, texCoords: Float32Array, colors: Uint8Array, featureIndices: Array}> - for recursive concatenation of\n *   attributes\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets.\n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @param {Matrix4} matrix - transformation matrix - cumulative transformation matrix formed from all parent node matrices\n */\nfunction convertNode(\n  node: GLTFNodePostprocessed,\n  images: (TextureImageProperties | null)[],\n  cartographicOrigin: Vector3,\n  cartesianModelMatrix: Matrix4,\n  attributesMap: Map<string, ConvertedAttributes>,\n  useCartesianPositions,\n  matrix = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n) {\n  const transformationMatrix = getCompositeTransformationMatrix(node, matrix);\n\n  const mesh = node.mesh;\n\n  if (mesh) {\n    convertMesh(\n      mesh,\n      images,\n      cartographicOrigin,\n      cartesianModelMatrix,\n      attributesMap,\n      useCartesianPositions,\n      transformationMatrix\n    );\n  }\n\n  convertNodes(\n    node.children || [],\n    images,\n    cartographicOrigin,\n    cartesianModelMatrix,\n    attributesMap,\n    useCartesianPositions,\n    transformationMatrix\n  );\n}\n\n/**\n * Convert all primitives of the mesh\n * @param mesh - gltf mesh data\n * @param images - gltf images array\n * @param cartographicOrigin - cartographic origin of bounding volume\n * @param cartesianModelMatrix - cartesian model matrix to convert coordinates to cartographic\n * @param attributesMap Map<{positions: Float32Array, normals: Float32Array, texCoords: Float32Array, colors: Uint8Array, featureIndices: Array}> - for recursive concatenation of\n *   attributes\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets. \n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @param attributesMap Map<{positions: Float32Array, normals: Float32Array, texCoords: Float32Array, colors: Uint8Array, featureIndices: Array}> - for recursive concatenation of\n *   attributes\n \n * @param {Matrix4} matrix - transformation matrix - cumulative transformation matrix formed from all parent node matrices\n */\nfunction convertMesh(\n  mesh: GLTFMeshPostprocessed,\n  images: (TextureImageProperties | null)[],\n  cartographicOrigin: Vector3,\n  cartesianModelMatrix: Matrix4,\n  attributesMap: Map<string, ConvertedAttributes>,\n  useCartesianPositions = false,\n  matrix = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n) {\n  for (const primitive of mesh.primitives) {\n    let outputAttributes: ConvertedAttributes | null | undefined = null;\n    let materialUvRegion: Uint16Array | undefined;\n    if (primitive.material) {\n      outputAttributes = attributesMap.get(primitive.material.id);\n      materialUvRegion = outputAttributes?.mergedMaterials.find(\n        ({originalMaterialId}) => originalMaterialId === primitive.material?.id\n      )?.uvRegion;\n    } else if (attributesMap.has('default')) {\n      outputAttributes = attributesMap.get('default');\n    }\n    assert(outputAttributes !== null, 'Primitive - material mapping failed');\n    // Per the spec https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_mesh_primitive_mode\n    // GL.TRIANGLES is default. So in case `mode` is `undefined`, it is 'TRIANGLES'\n    assert(\n      primitive.mode === undefined ||\n        primitive.mode === GL.TRIANGLES ||\n        primitive.mode === GL.TRIANGLE_STRIP,\n      `Primitive - unsupported mode ${primitive.mode}`\n    );\n    const attributes = primitive.attributes;\n    if (!outputAttributes) {\n      continue;\n    }\n\n    const indices = normalizeIndices(primitive);\n    outputAttributes.positions = concatenateTypedArrays(\n      outputAttributes.positions,\n      transformVertexArray({\n        vertices: attributes.POSITION.value,\n        cartographicOrigin,\n        cartesianModelMatrix,\n        nodeMatrix: matrix,\n        indices,\n        attributeSpecificTransformation: transformVertexPositions,\n        useCartesianPositions\n      })\n    );\n    outputAttributes.normals = concatenateTypedArrays(\n      outputAttributes.normals,\n      transformVertexArray({\n        vertices: attributes.NORMAL && attributes.NORMAL.value,\n        cartographicOrigin,\n        cartesianModelMatrix,\n        nodeMatrix: matrix,\n        indices,\n        attributeSpecificTransformation: transformVertexNormals,\n        useCartesianPositions: false\n      })\n    );\n    outputAttributes.texCoords = concatenateTypedArrays(\n      outputAttributes.texCoords,\n      flattenTexCoords(attributes.TEXCOORD_0 && attributes.TEXCOORD_0.value, indices)\n    );\n\n    outputAttributes.colors = concatenateTypedArrays(\n      outputAttributes.colors,\n      flattenColors(attributes.COLOR_0, indices)\n    );\n\n    if (materialUvRegion) {\n      outputAttributes.uvRegions = concatenateTypedArrays(\n        outputAttributes.uvRegions,\n        createUvRegion(materialUvRegion, indices)\n      );\n    }\n\n    outputAttributes.featureIndicesGroups = outputAttributes.featureIndicesGroups || [];\n    outputAttributes.featureIndicesGroups.push(\n      flattenBatchIds(getBatchIds(attributes, primitive, images), indices)\n    );\n  }\n}\n/**\n * Converts TRIANGLE-STRIPS to independent TRIANGLES\n * @param primitive - the primitive to get the indices from\n * @returns indices of vertices of the independent triangles\n */\nfunction normalizeIndices(primitive: GLTFMeshPrimitivePostprocessed): TypedArray {\n  let indices: TypedArray | undefined = primitive.indices?.value;\n  if (!indices) {\n    const positions = primitive.attributes.POSITION.value;\n    return generateSyntheticIndices(positions.length / VALUES_PER_VERTEX);\n  }\n\n  if (indices && primitive.mode === GL.TRIANGLE_STRIP) {\n    /*\n    TRIANGLE_STRIP geometry contains n+2 vertices for n triangles;\n    TRIANGLE geometry contains n*3 vertices for n triangles.\n    The conversion from TRIANGLE_STRIP to TRIANGLE implies duplicating adjacent vertices.\n    */\n    const TypedArrayConstructor = indices.constructor as TypedArrayConstructor;\n    const newIndices = new TypedArrayConstructor((indices.length - 2) * 3);\n\n    // Copy the first triangle indices with no modification like [i0, i1, i2, ...] -> [i0, i1, i2, ...]\n    let triangleIndex = 0;\n    let currentTriangle = indices.slice(0, 3);\n    newIndices.set(currentTriangle, 0);\n\n    // The rest triangle indices are being taken from strips using the following logic:\n    // [i1, i2, i3, i4, i5, i6, ...] -> [i3, i2, i1,   i2, i3, i4,   i5, i4, i3,   i4, i5, i6, ...]\n    for (let i = 1; i + 2 < indices.length; i++) {\n      triangleIndex += 3;\n      currentTriangle = indices.slice(i, i + 3);\n      if (i % 2 === 0) {\n        newIndices.set(currentTriangle, triangleIndex);\n      } else {\n        // The following \"reverce\" is necessary to calculate normals correctly\n        newIndices.set(currentTriangle.reverse(), triangleIndex);\n      }\n    }\n    indices = newIndices;\n  }\n  return indices as TypedArray;\n}\n\n/**\n * Convert vertices attributes (POSITIONS or NORMALS) to i3s compatible format\n * @param args\n * @param args.vertices - gltf primitive POSITION or NORMAL attribute\n * @param args.cartographicOrigin - cartographic origin coordinates\n * @param args.cartesianModelMatrix - a cartesian model matrix to transform coordnates from cartesian to cartographic format\n * @param args.nodeMatrix - a gltf node transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @param args.indices - gltf primitive indices\n * @param args.attributeSpecificTransformation - function to do attribute - specific transformations\n * @param args.useCartesianPositions - use coordinates as it is.\n * @returns\n */\nfunction transformVertexArray(args: {\n  vertices: TypedArray;\n  cartographicOrigin: number[];\n  cartesianModelMatrix: number[];\n  nodeMatrix: Matrix4;\n  indices: TypedArray;\n  attributeSpecificTransformation: Function;\n  useCartesianPositions: boolean;\n}): Float32Array {\n  const {vertices, indices, attributeSpecificTransformation} = args;\n  const newVertices = new Float32Array(indices.length * VALUES_PER_VERTEX);\n  if (!vertices) {\n    return newVertices;\n  }\n  for (let i = 0; i < indices.length; i++) {\n    const coordIndex = indices[i] * VALUES_PER_VERTEX;\n    const vertex = vertices.subarray(coordIndex, coordIndex + VALUES_PER_VERTEX);\n    let vertexVector = new Vector3(Array.from(vertex));\n\n    vertexVector = attributeSpecificTransformation(vertexVector, args);\n\n    newVertices[i * VALUES_PER_VERTEX] = vertexVector.x;\n    newVertices[i * VALUES_PER_VERTEX + 1] = vertexVector.y;\n    newVertices[i * VALUES_PER_VERTEX + 2] = vertexVector.z;\n  }\n  return newVertices;\n}\n\n/**\n * Trasform positions vector with the attribute specific transformations\n * @param vertexVector - source positions vector to transform\n * @param calleeArgs\n * @param calleeArgs.cartesianModelMatrix - a cartesian model matrix to transform coordnates from cartesian to cartographic format\n * @param calleeArgs.cartographicOrigin - cartographic origin coordinates\n * @param calleeArgs.nodeMatrix - a gltf node transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @param calleeArgs.useCartesianPositions - use coordinates as it is.\n * @returns transformed positions vector\n */\nfunction transformVertexPositions(vertexVector, calleeArgs): number[] {\n  const {cartesianModelMatrix, cartographicOrigin, nodeMatrix, useCartesianPositions} = calleeArgs;\n\n  if (nodeMatrix) {\n    vertexVector = vertexVector.transform(nodeMatrix);\n  }\n\n  vertexVector = vertexVector.transform(cartesianModelMatrix);\n\n  if (useCartesianPositions) {\n    return vertexVector;\n  }\n\n  Ellipsoid.WGS84.cartesianToCartographic(\n    [vertexVector[0], vertexVector[1], vertexVector[2]],\n    vertexVector\n  );\n  vertexVector = vertexVector.subtract(cartographicOrigin);\n  return vertexVector;\n}\n\n/**\n * Trasform normals vector with the attribute specific transformations\n * @param vertexVector - source normals vector to transform\n * @param calleeArgs\n * @param calleeArgs.cartesianModelMatrix - a cartesian model matrix to transform coordnates from cartesian to cartographic format\n * @param calleeArgs.nodeMatrix - a gltf node transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @returns transformed normals vector\n */\nfunction transformVertexNormals(vertexVector, calleeArgs): number[] {\n  const {cartesianModelMatrix, nodeMatrix} = calleeArgs;\n\n  if (nodeMatrix) {\n    vertexVector = vertexVector.transformAsVector(nodeMatrix);\n  }\n\n  vertexVector = vertexVector.transformAsVector(cartesianModelMatrix);\n  return vertexVector;\n}\n\n/**\n * Convert uv0 (texture coordinates) from coords based on indices to plain arrays, compatible with i3s\n * @param texCoords - gltf primitive TEXCOORD_0 attribute\n * @param indices - gltf primitive indices\n * @returns flattened texture coordinates\n */\nfunction flattenTexCoords(texCoords: TypedArray, indices: TypedArray): Float32Array {\n  const newTexCoords = new Float32Array(indices.length * VALUES_PER_TEX_COORD);\n  if (!texCoords) {\n    // We need dummy UV0s because it is required in 1.6\n    // https://github.com/Esri/i3s-spec/blob/master/docs/1.6/vertexAttribute.cmn.md\n    newTexCoords.fill(1);\n    return newTexCoords;\n  }\n  for (let i = 0; i < indices.length; i++) {\n    const coordIndex = indices[i] * VALUES_PER_TEX_COORD;\n    const texCoord = texCoords.subarray(coordIndex, coordIndex + VALUES_PER_TEX_COORD);\n    newTexCoords[i * VALUES_PER_TEX_COORD] = texCoord[0];\n    newTexCoords[i * VALUES_PER_TEX_COORD + 1] = texCoord[1];\n  }\n  return newTexCoords;\n}\n\n/**\n * Convert color from COLOR_0 based on indices to plain arrays, compatible with i3s\n * @param colorsAttribute - gltf primitive COLOR_0 attribute\n * @param indices - gltf primitive indices\n * @returns flattened colors attribute\n */\nfunction flattenColors(\n  colorsAttribute: GLTFAccessorPostprocessed,\n  indices: TypedArray\n): Uint8Array {\n  const components = colorsAttribute?.components || VALUES_PER_COLOR_ELEMENT;\n  const newColors = new Uint8Array(indices.length * components);\n  if (!colorsAttribute) {\n    // Vertex color multiplies by material color so it must be normalized 1 by default\n    newColors.fill(255);\n    return newColors;\n  }\n  const colors = colorsAttribute.value;\n  for (let i = 0; i < indices.length; i++) {\n    const colorIndex = indices[i] * components;\n    const color = colors.subarray(colorIndex, colorIndex + components);\n    const colorUint8 = new Uint8Array(components);\n    for (let j = 0; j < color.length; j++) {\n      colorUint8[j] = color[j] * 255;\n    }\n    newColors.set(colorUint8, i * components);\n  }\n  return newColors;\n}\n\n/**\n * Create per-vertex uv-region array\n * @param materialUvRegion - uv-region fragment for a single vertex\n * @param indices - geometry indices data\n * @returns - uv-region array\n */\nfunction createUvRegion(materialUvRegion: Uint16Array, indices: TypedArray): Uint16Array {\n  const result = new Uint16Array(indices.length * 4);\n  for (let i = 0; i < result.length; i += 4) {\n    result.set(materialUvRegion, i);\n  }\n  return result;\n}\n\n/**\n * Flatten batchedIds list based on indices to right ordered array, compatible with i3s\n * @param batchedIds - gltf primitive\n * @param indices - gltf primitive indices\n * @returns flattened batch ids\n */\nfunction flattenBatchIds(batchedIds: NumberArray, indices: TypedArray): number[] {\n  if (!batchedIds.length || !indices.length) {\n    return [];\n  }\n  const newBatchIds: number[] = [];\n  for (let i = 0; i < indices.length; i++) {\n    const coordIndex = indices[i];\n    newBatchIds.push(batchedIds[coordIndex]);\n  }\n  return newBatchIds;\n}\n\n/**\n * Get batchIds for featureIds creation\n * @param attributes - gltf accessors\n * @param primitive - gltf primitive data\n * @param images - gltf texture images\n */\nfunction getBatchIds(\n  attributes: {\n    [key: string]: GLTFAccessorPostprocessed;\n  },\n  primitive: GLTFMeshPrimitivePostprocessed,\n  images: (TextureImageProperties | null)[]\n): NumberArray {\n  const batchIds: NumberArray = handleBatchIdsExtensions(attributes, primitive, images);\n\n  if (batchIds.length) {\n    return batchIds;\n  }\n\n  for (let index = 0; index < BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES.length; index++) {\n    const possibleBatchIdAttributeName = BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES[index];\n    if (\n      attributes[possibleBatchIdAttributeName] &&\n      attributes[possibleBatchIdAttributeName].value\n    ) {\n      return attributes[possibleBatchIdAttributeName].value;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Convert GLTF material to I3S material definitions and textures\n * @param sourceMaterials Source GLTF materials\n * @param shouldMergeMaterials - if true - the converter will try to merge similar materials\n *                               to be able to merge primitives having those materials\n * @returns Array of Couples I3SMaterialDefinition + texture content\n */\nasync function convertMaterials(\n  sourceMaterials: GLTFMaterialPostprocessed[] = [],\n  shouldMergeMaterials: boolean\n): Promise<I3SMaterialWithTexture[]> {\n  let materials: I3SMaterialWithTexture[] = [];\n  for (const sourceMaterial of sourceMaterials) {\n    materials.push(convertMaterial(sourceMaterial));\n  }\n\n  if (shouldMergeMaterials) {\n    materials = await mergeAllMaterials(materials);\n  }\n\n  return materials;\n}\n\n/**\n * Merge materials when possible\n * @param materials materials array\n * @returns merged materials array\n */\nasync function mergeAllMaterials(\n  materials: I3SMaterialWithTexture[]\n): Promise<I3SMaterialWithTexture[]> {\n  const result: I3SMaterialWithTexture[] = [];\n  while (materials.length > 0) {\n    let newMaterial = materials.splice(0, 1)[0];\n    const mergedIndices: number[] = [];\n    for (let i = 0; i < materials.length; i++) {\n      const material = materials[i];\n      if (\n        (newMaterial.texture && material.texture) ||\n        (!newMaterial.texture && !material.texture)\n      ) {\n        newMaterial = await mergeMaterials(newMaterial, material);\n        mergedIndices.push(i);\n      }\n    }\n    if (newMaterial.texture && mergedIndices.length) {\n      const newWidth = newMaterial.mergedMaterials?.reduce(\n        (accum, {textureSize}) => accum + (textureSize?.width || 0),\n        0\n      );\n      const newHeight = newMaterial.mergedMaterials?.reduce(\n        (accum, {textureSize}) => Math.max(accum, textureSize?.height || 0),\n        0\n      );\n      let currentX = -1;\n      for (const aTextureMetadata of newMaterial.mergedMaterials) {\n        if (aTextureMetadata.textureSize) {\n          const newX =\n            currentX +\n            1 +\n            (aTextureMetadata.textureSize.width / newWidth) *\n              2 ** (Uint16Array.BYTES_PER_ELEMENT * 8) -\n            1;\n          aTextureMetadata.uvRegion = new Uint16Array([\n            currentX + 1,\n            0,\n            newX,\n            (aTextureMetadata.textureSize.height / newHeight) *\n              2 ** (Uint16Array.BYTES_PER_ELEMENT * 8) -\n              1\n          ]);\n          currentX = newX;\n        }\n      }\n\n      newMaterial.texture.image.width = newWidth;\n      newMaterial.texture.image.height = newHeight;\n    }\n    for (const index of mergedIndices.reverse()) {\n      materials.splice(index, 1);\n    }\n    result.push(newMaterial);\n  }\n\n  if (!result.length) {\n    result.push({\n      material: getDefaultMaterial(),\n      mergedMaterials: [{originalMaterialId: 'default'}]\n    });\n  }\n  return result;\n}\n\n/**\n * Merge 2 materials including texture\n * @param material1\n * @param material2\n * @returns\n */\nasync function mergeMaterials(\n  material1: I3SMaterialWithTexture,\n  material2: I3SMaterialWithTexture\n): Promise<I3SMaterialWithTexture> {\n  if (\n    material1.texture?.bufferView &&\n    material2.texture?.bufferView &&\n    material1.mergedMaterials &&\n    material2.mergedMaterials\n  ) {\n    const buffer1 = Buffer.from(material1.texture.bufferView.data);\n    const buffer2 = Buffer.from(material2.texture.bufferView.data);\n    try {\n      // @ts-ignore\n      const {joinImages} = await import('join-images');\n      const sharpData = await joinImages([buffer1, buffer2], {direction: 'horizontal'});\n      material1.texture.bufferView.data = await sharpData\n        .toFormat(material1.texture.mimeType === 'image/png' ? 'png' : 'jpeg')\n        .toBuffer();\n    } catch (error) {\n      console.log(\n        'Join images into a texture atlas has failed. Consider usage `--split-nodes` option. (See documentation https://loaders.gl/modules/tile-converter/docs/cli-reference/tile-converter)'\n      );\n      throw error;\n    }\n    // @ts-ignore\n    material1.material.pbrMetallicRoughness.baseColorTexture.textureSetDefinitionId = 1;\n  }\n  material1.mergedMaterials = material1.mergedMaterials.concat(material2.mergedMaterials);\n  return material1;\n}\n\n/**\n * Convert texture and material from gltf 2.0 material object\n * @param sourceMaterial - material object\n * @returns I3S material definition and texture\n */\nfunction convertMaterial(sourceMaterial: GLTFMaterialPostprocessed): I3SMaterialWithTexture {\n  const material: I3SMaterialDefinition = {\n    doubleSided: sourceMaterial.doubleSided,\n    emissiveFactor: sourceMaterial.emissiveFactor?.map((c) => Math.round(c * 255)) as [\n      number,\n      number,\n      number\n    ],\n    // It is in upper case in GLTF: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#alpha-coverage\n    // But it is in lower case in I3S: https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n    alphaMode: convertAlphaMode(sourceMaterial.alphaMode),\n    pbrMetallicRoughness: {\n      roughnessFactor:\n        sourceMaterial?.pbrMetallicRoughness?.roughnessFactor || DEFAULT_ROUGHNESS_FACTOR,\n      metallicFactor:\n        sourceMaterial?.pbrMetallicRoughness?.metallicFactor || DEFAULT_METALLIC_FACTOR\n    }\n  };\n\n  let texture;\n  if (sourceMaterial?.pbrMetallicRoughness?.baseColorTexture) {\n    texture = sourceMaterial.pbrMetallicRoughness.baseColorTexture.texture.source;\n    material.pbrMetallicRoughness.baseColorTexture = {\n      textureSetDefinitionId: 0\n    };\n  } else if (sourceMaterial.emissiveTexture) {\n    texture = sourceMaterial.emissiveTexture.texture.source;\n    // ArcGIS webscene doesn't show emissiveTexture but shows baseColorTexture\n    material.pbrMetallicRoughness.baseColorTexture = {\n      textureSetDefinitionId: 0\n    };\n  }\n\n  sourceMaterial.id = Number.isFinite(sourceMaterial.id) ? sourceMaterial.id : uuidv4();\n  let mergedMaterials: MergedMaterial[] = [{originalMaterialId: sourceMaterial.id}];\n  if (!texture) {\n    // Should use default baseColorFactor if it is not present in source material\n    // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-pbrmetallicroughness\n    const baseColorFactor = sourceMaterial?.pbrMetallicRoughness?.baseColorFactor;\n    material.pbrMetallicRoughness.baseColorFactor =\n      ((baseColorFactor && baseColorFactor.map((c) => Math.round(c * 255))) as [\n        number,\n        number,\n        number,\n        number\n      ]) || undefined;\n  } else {\n    mergedMaterials[0].textureSize = {width: texture.image.width, height: texture.image.height};\n  }\n\n  return {material, texture, mergedMaterials};\n}\n\n/**\n * Converts from `alphaMode` material property from GLTF to I3S format\n * @param gltfAlphaMode Gltf material `alphaMode` property\n * @returns I3SMaterialDefinition.alphaMode property\n */\nfunction convertAlphaMode(\n  gltfAlphaMode?: 'OPAQUE' | 'MASK' | 'BLEND' | string\n): 'opaque' | 'mask' | 'blend' {\n  switch (gltfAlphaMode) {\n    case 'OPAQUE':\n      return 'opaque';\n    case 'MASK':\n      return 'mask';\n    case 'BLEND':\n      return 'blend';\n    default:\n      return 'opaque';\n  }\n}\n\n/**\n * Form default I3SMaterialDefinition\n * @returns I3S material definition\n */\nfunction getDefaultMaterial(): I3SMaterialDefinition {\n  return {\n    alphaMode: 'opaque',\n    pbrMetallicRoughness: {\n      metallicFactor: 1,\n      roughnessFactor: 1\n    }\n  };\n}\n\n/**\n * Form \"sharedResources\" from gltf materials array\n * @param gltfMaterials - GLTF materials array\n * @param nodeId - I3S node ID\n * @returns {materialDefinitionInfos: Object[], textureDefinitionInfos: Object[]} -\n * 2 arrays in format of i3s sharedResources data https://github.com/Esri/i3s-spec/blob/master/docs/1.7/sharedResource.cmn.md\n */\nfunction getSharedResources(\n  gltfMaterials: GLTFMaterialPostprocessed[],\n  nodeId: number\n): SharedResourcesArrays {\n  const i3sResources: SharedResourcesArrays = {};\n\n  if (!gltfMaterials || !gltfMaterials.length) {\n    return i3sResources;\n  }\n\n  i3sResources.materialDefinitionInfos = [];\n  for (const gltfMaterial of gltfMaterials) {\n    const {materialDefinitionInfo, textureDefinitionInfo} = convertGLTFMaterialToI3sSharedResources(\n      gltfMaterial,\n      nodeId\n    );\n    i3sResources.materialDefinitionInfos.push(materialDefinitionInfo);\n    if (textureDefinitionInfo) {\n      i3sResources.textureDefinitionInfos = i3sResources.textureDefinitionInfos || [];\n      i3sResources.textureDefinitionInfos.push(textureDefinitionInfo);\n    }\n  }\n  return i3sResources;\n}\n\n/**\n * Convert gltf material into I3S sharedResources data\n * @param gltfMaterial - gltf material data\n * @param nodeId - I3S node ID\n * @returns - Couple {materialDefinitionInfo, textureDefinitionInfo} extracted from gltf material data\n */\nfunction convertGLTFMaterialToI3sSharedResources(\n  gltfMaterial: GLTFMaterialPostprocessed,\n  nodeId: number\n): {\n  materialDefinitionInfo: MaterialDefinitionInfo;\n  textureDefinitionInfo: TextureDefinitionInfo | null;\n} {\n  const texture =\n    gltfMaterial?.pbrMetallicRoughness?.baseColorTexture || gltfMaterial.emissiveTexture;\n  let textureDefinitionInfo: TextureDefinitionInfo | null = null;\n  if (texture) {\n    textureDefinitionInfo = extractSharedResourcesTextureInfo(texture.texture, nodeId);\n  }\n  const {baseColorFactor, metallicFactor} = gltfMaterial?.pbrMetallicRoughness || {};\n  let colorFactor = baseColorFactor;\n  // If alpha channel is 0 try to get emissive factor from gltf material.\n  if ((!baseColorFactor || baseColorFactor[3] === 0) && gltfMaterial.emissiveFactor) {\n    colorFactor = gltfMaterial.emissiveFactor;\n    colorFactor[3] = colorFactor[3] || 1;\n  }\n\n  return {\n    materialDefinitionInfo: extractSharedResourcesMaterialInfo(\n      colorFactor || [1, 1, 1, 1],\n      metallicFactor\n    ),\n    textureDefinitionInfo\n  };\n}\n\n/**\n * Form \"materialDefinition\" which is part of \"sharedResouces\"\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materials\n * See formulas in appendix \"Appendix B: BRDF Implementation\":\n * const dielectricSpecular = rgb(0.04, 0.04, 0.04)\n * const black = rgb(0, 0, 0)\n * cdiff = lerp(baseColor.rgb * (1 - dielectricSpecular.r), black, metallic)\n * F0 = lerp(dieletricSpecular, baseColor.rgb, metallic)\n *\n * Assumption: F0 - specular in i3s (\"specular reflection\" <-> \"reflectance value at normal incidence\")\n * cdiff - diffuse in i3s (\"Diffuse color\" <-> \"'c' diffuse\" (c means color?))\n * @param baseColorFactor - RGBA color in 0..1 format\n * @param metallicFactor - \"metallicFactor\" attribute of gltf material object\n * @returns material definition info for I3S shared resource\n */\nfunction extractSharedResourcesMaterialInfo(\n  baseColorFactor: number[],\n  metallicFactor: number = 1\n): MaterialDefinitionInfo {\n  const matDielectricColorComponent = 0.04 / 255; // Color from rgb (255) to 0..1 resolution\n  // All color resolutions are 0..1\n  const black = new Vector4(0, 0, 0, 1);\n  const unitVector = new Vector4(1, 1, 1, 1);\n  const dielectricSpecular = new Vector4(\n    matDielectricColorComponent,\n    matDielectricColorComponent,\n    matDielectricColorComponent,\n    0\n  );\n  const baseColorVector = new Vector4(baseColorFactor);\n  // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n  // Formulas for Cdiff & F0\n  const firstOperand = unitVector.subtract(dielectricSpecular).multiply(baseColorVector);\n  const diffuse = firstOperand.lerp(firstOperand, black, metallicFactor);\n  dielectricSpecular[3] = 1;\n  const specular = dielectricSpecular.lerp(dielectricSpecular, baseColorVector, metallicFactor);\n  return {\n    params: {\n      // @ts-expect-error NumericArray\n      diffuse: diffuse.toArray(),\n      // @ts-expect-error NumericArray\n      specular: specular.toArray(),\n      renderMode: 'solid'\n    }\n  };\n}\n\n/**\n * Form \"textureDefinition\" which is part of \"sharedResouces\"\n * @param texture - texture image info\n * @param nodeId - I3S node ID\n * @returns texture definition infor for shared resource\n */\nfunction extractSharedResourcesTextureInfo(\n  texture: GLTFTexturePostprocessed,\n  nodeId: number\n): TextureDefinitionInfo {\n  return {\n    encoding: texture?.source?.mimeType ? [texture.source.mimeType] : undefined,\n    images: [\n      {\n        // 'i3s' has just size which is width of the image. Images are supposed to be square.\n        // https://github.com/Esri/i3s-spec/blob/master/docs/1.7/image.cmn.md\n        id: generateImageId(texture, nodeId),\n        size: texture.source?.image.width,\n        length: texture.source?.image.data.length ? [texture.source?.image.data.length] : undefined\n      }\n    ]\n  };\n}\n\n/**\n * Formula for calculating imageId:\n * https://github.com/Esri/i3s-spec/blob/0a6366a9249b831db8436c322f8d27521e86cf07/format/Indexed%203d%20Scene%20Layer%20Format%20Specification.md#generating-image-ids\n * @param texture - texture image info\n * @param nodeId - I3S node ID\n * @returns calculate image ID according to the spec\n */\nfunction generateImageId(texture: GLTFTexturePostprocessed, nodeId: number) {\n  const {width, height} = texture.source?.image || {};\n  if (!width || !height) {\n    return '';\n  }\n  const levelCountOfTexture = 1;\n  const indexOfLevel = 0;\n  const indexOfTextureInStore = nodeId + 1;\n\n  const zerosCount = 32 - indexOfTextureInStore.toString(2).length;\n  const rightHalf = '0'.repeat(zerosCount).concat(indexOfTextureInStore.toString(2));\n\n  const shiftedLevelCountOfTexture = levelCountOfTexture << 28;\n  const shiftedIndexOfLevel = indexOfLevel << 24;\n  const shiftedWidth = (width - 1) << 12;\n  const shiftedHeight = (height - 1) << 0;\n\n  const leftHalf = shiftedLevelCountOfTexture + shiftedIndexOfLevel + shiftedWidth + shiftedHeight;\n  const imageId = BigInt(`0b${leftHalf.toString(2)}${rightHalf}`);\n  return imageId.toString();\n}\n\n/**\n * Make all feature ids unique through all nodes in layout.\n * @param featureIds\n * @param featureIndices\n * @param featuresHashArray\n * @param batchTable\n * @returns {void}\n */\nfunction makeFeatureIdsUnique(\n  featureIds: number[],\n  featureIndices: number[],\n  featuresHashArray: string[],\n  batchTable: {[key: string]: any}\n) {\n  const replaceMap = getFeaturesReplaceMap(featureIds, batchTable, featuresHashArray);\n  replaceIndicesByUnique(featureIndices, replaceMap);\n  replaceIndicesByUnique(featureIds, replaceMap);\n}\n\n/**\n * Generate replace map to make featureIds unique.\n * @param featureIds\n * @param batchTable\n * @param featuresHashArray\n * @returns\n */\nfunction getFeaturesReplaceMap(\n  featureIds: any[],\n  batchTable: object,\n  featuresHashArray: any[]\n): Record<string, any> {\n  const featureMap: Record<string, any> = {};\n\n  for (let index = 0; index < featureIds.length; index++) {\n    const oldFeatureId = featureIds[index];\n    const uniqueFeatureId = getOrCreateUniqueFeatureId(index, batchTable, featuresHashArray);\n    featureMap[oldFeatureId.toString()] = uniqueFeatureId;\n  }\n\n  return featureMap;\n}\n\n/**\n * Generates string for unique batch id creation.\n * @param batchTable\n * @param index\n * @returns\n */\nfunction generateStringFromBatchTableByIndex(batchTable: object, index: number): string {\n  let str = '';\n  for (const key in batchTable) {\n    str += batchTable[key][index];\n  }\n  return str;\n}\n\n/**\n * Return already exited featureId or creates and returns new to support unique feature ids throw nodes.\n * @param index\n * @param batchTable\n * @param featuresHashArray\n * @returns\n */\nfunction getOrCreateUniqueFeatureId(\n  index: number,\n  batchTable: object,\n  featuresHashArray: any[]\n): number {\n  const batchTableStr = generateStringFromBatchTableByIndex(batchTable, index);\n  const hash = md5(batchTableStr);\n\n  if (featuresHashArray.includes(hash)) {\n    return featuresHashArray.indexOf(hash);\n  }\n  return featuresHashArray.push(hash) - 1;\n}\n\n/**\n * Do replacement of indices for making them unique through all nodes.\n * @param indicesArray\n * @param featureMap\n * @returns\n */\nfunction replaceIndicesByUnique(indicesArray: any[], featureMap: Record<string, []>) {\n  for (let index = 0; index < indicesArray.length; index++) {\n    indicesArray[index] = featureMap[indicesArray[index]];\n  }\n}\n\n/**\n * Convert property table data to attribute buffers.\n * @param featureIds\n * @param propertyTable - table with metadata for particular feature.\n * @param attributeStorageInfo\n * @returns - Array of file buffers.\n */\nfunction convertPropertyTableToAttributeBuffers(\n  featureIds: number[],\n  propertyTable: FeatureTableJson,\n  attributeStorageInfo: AttributeStorageInfo[]\n): any[] {\n  const attributeBuffers: ArrayBuffer[] = [];\n\n  const needFlattenPropertyTable = checkPropertiesLength(featureIds, propertyTable);\n  const properties = needFlattenPropertyTable\n    ? flattenPropertyTableByFeatureIds(featureIds, propertyTable)\n    : propertyTable;\n\n  const propertyTableWithObjectIds = {\n    OBJECTID: featureIds,\n    ...properties\n  };\n\n  for (const propertyName in propertyTableWithObjectIds) {\n    const type = getAttributeType(propertyName, attributeStorageInfo);\n    const value = propertyTableWithObjectIds[propertyName];\n    const attributeBuffer = generateAttributeBuffer(type, value);\n\n    attributeBuffers.push(attributeBuffer);\n  }\n\n  return attributeBuffers;\n}\n\n/**\n * Generates attribute buffer based on attribute type\n * @param type\n * @param value\n */\nfunction generateAttributeBuffer(type: string, value: any): ArrayBuffer {\n  let attributeBuffer: ArrayBuffer;\n\n  switch (type) {\n    case OBJECT_ID_TYPE:\n    case SHORT_INT_TYPE:\n      attributeBuffer = generateShortIntegerAttributeBuffer(value);\n      break;\n    case DOUBLE_TYPE:\n      attributeBuffer = generateDoubleAttributeBuffer(value);\n      break;\n    case STRING_TYPE:\n      attributeBuffer = generateStringAttributeBuffer(value);\n      break;\n    default:\n      attributeBuffer = generateStringAttributeBuffer(value);\n  }\n\n  return attributeBuffer;\n}\n\n/**\n * Return attribute type.\n * @param key\n * @param attributeStorageInfo\n * @returns attribute type.\n */\nfunction getAttributeType(key: string, attributeStorageInfo: any[]): string {\n  const attribute = attributeStorageInfo.find((attr) => attr.name === key);\n  return attribute.attributeValues.valueType;\n}\n\n/**\n * Convert short integer to attribute arrayBuffer.\n * @param featureIds\n * @returns - Buffer with objectId data.\n */\nfunction generateShortIntegerAttributeBuffer(featureIds: any[]): ArrayBuffer {\n  const count = new Uint32Array([featureIds.length]);\n  const valuesArray = new Uint32Array(featureIds);\n  return concatenateArrayBuffers(count.buffer, valuesArray.buffer);\n}\n\n/**\n * Convert double to attribute arrayBuffer.\n * @param featureIds\n * @returns - Buffer with objectId data.\n */\nfunction generateDoubleAttributeBuffer(featureIds: any[]): ArrayBuffer {\n  const count = new Uint32Array([featureIds.length]);\n  const padding = new Uint8Array(4);\n  const valuesArray = new Float64Array(featureIds);\n\n  return concatenateArrayBuffers(count.buffer, padding.buffer, valuesArray.buffer);\n}\n\n/**\n * Convert batch table attributes to array buffer with batch table data.\n * @param batchAttributes\n * @returns - Buffer with batch table data.\n */\nfunction generateStringAttributeBuffer(batchAttributes: any[]): ArrayBuffer {\n  const stringCountArray = new Uint32Array([batchAttributes.length]);\n  let totalNumberOfBytes = 0;\n  const stringSizesArray = new Uint32Array(batchAttributes.length);\n  const stringBufferArray: ArrayBuffer[] = [];\n\n  for (let index = 0; index < batchAttributes.length; index++) {\n    const currentString = `${String(batchAttributes[index])}\\0`;\n    const currentStringBuffer = Buffer.from(currentString);\n    const currentStringSize = currentStringBuffer.length;\n    totalNumberOfBytes += currentStringSize;\n    stringSizesArray[index] = currentStringSize;\n    stringBufferArray.push(currentStringBuffer);\n  }\n\n  const totalBytes = new Uint32Array([totalNumberOfBytes]);\n\n  return concatenateArrayBuffers(\n    stringCountArray.buffer,\n    totalBytes.buffer,\n    stringSizesArray.buffer,\n    ...stringBufferArray\n  );\n}\n\n/**\n * Convert featureIds to BigUint64Array.\n * @param featureIds\n * @returns - Array of feature ids in BigUint64 format.\n */\nfunction generateBigUint64Array(featureIds: any[]): BigUint64Array {\n  const typedFeatureIds = new BigUint64Array(featureIds.length);\n  for (let index = 0; index < featureIds.length; index++) {\n    typedFeatureIds[index] = BigInt(featureIds[index]);\n  }\n  return typedFeatureIds;\n}\n\n/**\n * Generates draco compressed geometry\n * @param {Number} vertexCount\n * @param {Object} convertedAttributes - get rid of this argument here\n * @param {Object} attributes - geometry attributes to compress\n * @param {string} dracoWorkerSoure - draco worker source code\n * @returns {Promise<object>} - COmpressed geometry.\n */\nasync function generateCompressedGeometry(\n  vertexCount: number,\n  convertedAttributes: Record<string, any>,\n  attributes: Record<string, any>,\n  dracoWorkerSoure: string\n): Promise<ArrayBuffer> {\n  const {positions, normals, texCoords, colors, uvRegions, featureIds, faceRange} = attributes;\n  const indices = new Uint32Array(vertexCount);\n\n  for (let index = 0; index < indices.length; index++) {\n    indices.set([index], index);\n  }\n\n  const featureIndices = new Uint32Array(\n    convertedAttributes.featureIndices.length ? convertedAttributes.featureIndices : vertexCount\n  );\n\n  const featureIndex = generateFeatureIndexAttribute(featureIndices, faceRange);\n\n  const compressedAttributes: {\n    positions: TypedArray;\n    normals: TypedArray;\n    colors: TypedArray;\n    'feature-index': TypedArray;\n    texCoords?: TypedArray;\n    'uv-region'?: TypedArray;\n  } = {\n    positions,\n    normals,\n    colors,\n    'feature-index': featureIndex\n  };\n\n  if (texCoords.length) {\n    compressedAttributes.texCoords = texCoords;\n  }\n\n  const attributesMetadata = {\n    'feature-index': {\n      'i3s-attribute-type': 'feature-index',\n      'i3s-feature-ids': new Int32Array(featureIds)\n    }\n  };\n\n  if (uvRegions.length) {\n    compressedAttributes['uv-region'] = uvRegions;\n    attributesMetadata['uv-region'] = {\n      'i3s-attribute-type': 'uv-region'\n    };\n  }\n\n  return encode({attributes: compressedAttributes, indices}, DracoWriterWorker, {\n    ...DracoWriterWorker.options,\n    source: dracoWorkerSoure,\n    reuseWorkers: true,\n    _nodeWorkers: true,\n    draco: {\n      method: 'MESH_SEQUENTIAL_ENCODING',\n      attributesMetadata\n    }\n  });\n}\n\n/**\n * Generates ordered feature indices based on face range\n * @param featureIndex\n * @param faceRange\n * @returns\n */\nfunction generateFeatureIndexAttribute(\n  featureIndex: Uint32Array,\n  faceRange: Uint32Array\n): Uint32Array {\n  const orderedFeatureIndices = new Uint32Array(featureIndex.length);\n  let fillIndex = 0;\n  let startIndex = 0;\n\n  for (let index = 1; index < faceRange.length; index += 2) {\n    const endIndex = (faceRange[index] + 1) * VALUES_PER_VERTEX;\n\n    orderedFeatureIndices.fill(fillIndex, startIndex, endIndex);\n\n    fillIndex++;\n    startIndex = endIndex + 1;\n  }\n\n  return orderedFeatureIndices;\n}\n\n/**\n * Find property table in tile\n * For example it can be batchTable for b3dm files or property table in gLTF extension.\n * @param sourceTile\n * @return batch table from b3dm / feature properties from EXT_FEATURE_METADATA\n */\nexport function getPropertyTable(tileContent: B3DMContent): FeatureTableJson | null {\n  const batchTableJson = tileContent?.batchTableJson;\n\n  if (batchTableJson) {\n    return batchTableJson;\n  }\n\n  const {extensionName, extension} = getPropertyTableExtension(tileContent);\n\n  switch (extensionName) {\n    case EXT_MESH_FEATURES: {\n      console.warn('The I3S converter does not yet support the EXT_mesh_features extension');\n      return null;\n    }\n    case EXT_FEATURE_METADATA: {\n      return getPropertyTableFromExtFeatureMetadata(extension as GLTF_EXT_feature_metadata);\n    }\n    default:\n      return null;\n  }\n}\n\n/**\n * Check extensions which can be with property table inside.\n * @param sourceTile\n */\nfunction getPropertyTableExtension(\n  tileContent: B3DMContent\n): GLTF_EXT_feature_metadata | GLTF_EXT_mesh_features {\n  const extensionsWithPropertyTables = [EXT_FEATURE_METADATA, EXT_MESH_FEATURES];\n  const extensionsUsed = tileContent?.gltf?.extensionsUsed;\n\n  if (!extensionsUsed) {\n    return {extensionName: null, extension: null};\n  }\n\n  let extensionName: string = '';\n\n  for (const extensionItem of tileContent?.gltf?.extensionsUsed || []) {\n    if (extensionsWithPropertyTables.includes(extensionItem)) {\n      extensionName = extensionItem;\n      break;\n    }\n  }\n\n  const extension = tileContent?.gltf?.extensions?.[extensionName];\n\n  return {extensionName, extension};\n}\n\n/**\n * Handle EXT_feature_metadata to get property table\n * @param extension\n * TODO add EXT_feature_metadata feature textures support.\n */\nfunction getPropertyTableFromExtFeatureMetadata(\n  extension: GLTF_EXT_feature_metadata\n): FeatureTableJson | null {\n  if (extension?.featureTextures) {\n    console.warn(\n      'The I3S converter does not yet support the EXT_feature_metadata feature textures'\n    );\n    return null;\n  }\n\n  if (extension?.featureTables) {\n    /**\n     * Take only first feature table to generate attributes storage info object.\n     * TODO: Think about getting data from all feature tables?\n     * It can be tricky just because 3dTiles is able to have multiple featureId attributes and multiple feature tables.\n     * In I3S we should decide which featureIds attribute will be passed to geometry data.\n     */\n    const firstFeatureTableName = Object.keys(extension.featureTables)?.[0];\n\n    if (firstFeatureTableName) {\n      const featureTable = extension?.featureTables[firstFeatureTableName];\n      const propertyTable = {};\n\n      for (const propertyName in featureTable.properties) {\n        propertyTable[propertyName] = featureTable.properties[propertyName].data;\n      }\n\n      return propertyTable;\n    }\n  }\n\n  console.warn(\"The I3S converter couldn't handle EXT_feature_metadata extension\");\n  return null;\n}\n"],"mappings":"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"}