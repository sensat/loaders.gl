{"version":3,"file":"texture-atlas.js","names":["convertTextureAtlas","texCoords","uvRegions","convertedTexCoords","Float32Array","length","normalisedRegions","normalizeRegions","index","uv","subarray","regions","slice","fractatedUV","fract","subtracted","multiplicationResult","convertedUV","Math","floor","MAX_UINT_16_VALUE","normalizedRegions"],"sources":["../../../../src/3d-tiles-converter/helpers/texture-atlas.ts"],"sourcesContent":["/**\n * Apply uvRegions to texture coordinates.\n * Spec - https://github.com/Esri/i3s-spec/blob/master/docs/1.7/geometryUVRegion.cmn.md\n * Shader formula vec2 uv = fract(texCoords) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;\n * @param texCoords\n * @param uvRegions\n */\nexport function convertTextureAtlas(texCoords: Float32Array, uvRegions: Uint16Array): Float32Array {\n  const convertedTexCoords = new Float32Array(texCoords.length);\n  const normalisedRegions = normalizeRegions(uvRegions);\n\n  for (let index = 0; index < texCoords.length; index += 2) {\n    const uv = texCoords.subarray(index, index + 2);\n    const regions = normalisedRegions.slice(index * 2, index * 2 + 4);\n    // fract(texCoords)\n    const fractatedUV = fract([uv[0], uv[1]]);\n    // (uvRegions.zw - uvRegions.xy)\n    const subtracted = [regions[2] - regions[0], regions[3] - regions[1]];\n    // fract(texCoords) * (uvRegions.zw - uvRegions.xy)\n    const multiplicationResult = [fractatedUV[0] * subtracted[0], fractatedUV[1] * subtracted[1]];\n    // fract(texCoords) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;\n    const convertedUV = [\n      multiplicationResult[0] + regions[0],\n      multiplicationResult[1] + regions[1]\n    ];\n\n    convertedTexCoords[index] = convertedUV[0];\n    convertedTexCoords[index + 1] = convertedUV[1];\n  }\n\n  return convertedTexCoords;\n}\n\n/**\n * Do fractation of UV array.\n * @param uv\n */\nfunction fract(uv: [number, number]): [number, number] {\n  return [uv[0] - Math.floor(uv[0]), uv[1] - Math.floor(uv[1])];\n}\n\n/**\n * Normalize uvRegions by dividing by the maximum Uint16 value\n * @param regions\n */\nfunction normalizeRegions(regions: Uint16Array): number[] {\n  const MAX_UINT_16_VALUE = 65535;\n  const normalizedRegions: number[] = [];\n\n  for (let index = 0; index < regions.length; index++) {\n    normalizedRegions[index] = regions[index] / MAX_UINT_16_VALUE;\n  }\n\n  return normalizedRegions;\n}\n"],"mappings":"AAOA,OAAO,SAASA,mBAAmBA,CAACC,SAAuB,EAAEC,SAAsB,EAAgB;EACjG,MAAMC,kBAAkB,GAAG,IAAIC,YAAY,CAACH,SAAS,CAACI,MAAM,CAAC;EAC7D,MAAMC,iBAAiB,GAAGC,gBAAgB,CAACL,SAAS,CAAC;EAErD,KAAK,IAAIM,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGP,SAAS,CAACI,MAAM,EAAEG,KAAK,IAAI,CAAC,EAAE;IACxD,MAAMC,EAAE,GAAGR,SAAS,CAACS,QAAQ,CAACF,KAAK,EAAEA,KAAK,GAAG,CAAC,CAAC;IAC/C,MAAMG,OAAO,GAAGL,iBAAiB,CAACM,KAAK,CAACJ,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;IAEjE,MAAMK,WAAW,GAAGC,KAAK,CAAC,CAACL,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAEzC,MAAMM,UAAU,GAAG,CAACJ,OAAO,CAAC,CAAC,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC,CAAC;IAErE,MAAMK,oBAAoB,GAAG,CAACH,WAAW,CAAC,CAAC,CAAC,GAAGE,UAAU,CAAC,CAAC,CAAC,EAAEF,WAAW,CAAC,CAAC,CAAC,GAAGE,UAAU,CAAC,CAAC,CAAC,CAAC;IAE7F,MAAME,WAAW,GAAG,CAClBD,oBAAoB,CAAC,CAAC,CAAC,GAAGL,OAAO,CAAC,CAAC,CAAC,EACpCK,oBAAoB,CAAC,CAAC,CAAC,GAAGL,OAAO,CAAC,CAAC,CAAC,CACrC;IAEDR,kBAAkB,CAACK,KAAK,CAAC,GAAGS,WAAW,CAAC,CAAC,CAAC;IAC1Cd,kBAAkB,CAACK,KAAK,GAAG,CAAC,CAAC,GAAGS,WAAW,CAAC,CAAC,CAAC;EAChD;EAEA,OAAOd,kBAAkB;AAC3B;AAMA,SAASW,KAAKA,CAACL,EAAoB,EAAoB;EACrD,OAAO,CAACA,EAAE,CAAC,CAAC,CAAC,GAAGS,IAAI,CAACC,KAAK,CAACV,EAAE,CAAC,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,GAAGS,IAAI,CAACC,KAAK,CAACV,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/D;AAMA,SAASF,gBAAgBA,CAACI,OAAoB,EAAY;EACxD,MAAMS,iBAAiB,GAAG,KAAK;EAC/B,MAAMC,iBAA2B,GAAG,EAAE;EAEtC,KAAK,IAAIb,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGG,OAAO,CAACN,MAAM,EAAEG,KAAK,EAAE,EAAE;IACnDa,iBAAiB,CAACb,KAAK,CAAC,GAAGG,OAAO,CAACH,KAAK,CAAC,GAAGY,iBAAiB;EAC/D;EAEA,OAAOC,iBAAiB;AAC1B"}