{"version":3,"file":"b3dm-converter.js","names":["encodeSync","GLTFScenegraph","GLTFWriter","Tile3DWriter","Matrix4","Vector3","Ellipsoid","convertTextureAtlas","generateSyntheticIndices","Z_UP_TO_Y_UP_MATRIX","scratchVector","B3dmConverter","constructor","_defineProperty","convert","i3sAttributesData","featureAttributes","arguments","length","undefined","gltf","buildGltf","b3dm","gltfEncoded","Uint8Array","type","featuresLength","_getFeaturesLength","batchTable","tileContent","textureFormat","material","attributes","indices","originalIndices","cartesianOrigin","cartographicOrigin","modelMatrix","gltfBuilder","textureIndex","_addI3sTextureToGltf","pbrMaterialInfo","_convertI3sMaterialToGltfMaterial","materialIndex","addMaterial","positions","positionsValue","value","uvRegions","texCoords","_normalizePositions","_createBatchIds","normals","_checkNormals","size","meshIndex","addMesh","mode","transformMatrix","_generateTransformMatrix","nodeIndex","addNode","matrix","sceneIndex","addScene","nodeIndices","setDefaultScene","createBinaryChunk","gltfBuffer","texture","selectedTexture","pbrMetallicRoughness","baseColorTexture","source","image","mimeType","_deduceMimeTypeFromFormat","imageIndex","addImage","addTexture","colors","newPositionsValue","Float32Array","index","vertex","subarray","cartesianOriginVector","vertexVector","Array","from","transform","add","WGS84","cartographicToCartesian","subtract","set","translateOriginMatrix","translate","result","multiplyLeft","i3sContent","featureIds","OBJECTID","objectIds","i","featureId","batchId","indexOf","_BATCHID","byteOffset","format","console","warn","concat","isTextureIndexExists","alphaMode","doubleSided","metallicFactor","roughnessFactor","texCoord","baseColorFactor","_setGltfTexture","materialDefinition","emissiveTexture","metallicRoughnessTexture","normalTexture","occlusionTexture","firstKey","Object","keys","find"],"sources":["../../../../src/3d-tiles-converter/helpers/b3dm-converter.ts"],"sourcesContent":["import type {I3SAttributesData} from '../../3d-tiles-attributes-worker';\n\nimport {encodeSync} from '@loaders.gl/core';\nimport {GLTFScenegraph, GLTFWriter} from '@loaders.gl/gltf';\nimport {Tile3DWriter} from '@loaders.gl/3d-tiles';\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {convertTextureAtlas} from './texture-atlas';\nimport {generateSyntheticIndices} from '../../lib/utils/geometry-utils';\n\nconst Z_UP_TO_Y_UP_MATRIX = new Matrix4([1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\nconst scratchVector = new Vector3();\n\n/**\n * Converts content of an I3S node to *.b3dm's file content\n */\nexport default class B3dmConverter {\n  // @ts-expect-error\n  rtcCenter: Float32Array;\n  i3sTile: any;\n\n  /**\n   * The starter of content conversion\n   * @param i3sTile - Tile3D instance for I3S node\n   * @returns - encoded content\n   */\n  async convert(\n    i3sAttributesData: I3SAttributesData,\n    featureAttributes: any = null\n  ): Promise<ArrayBuffer> {\n    const gltf = await this.buildGltf(i3sAttributesData, featureAttributes);\n    const b3dm = encodeSync(\n      {\n        gltfEncoded: new Uint8Array(gltf),\n        type: 'b3dm',\n        featuresLength: this._getFeaturesLength(featureAttributes),\n        batchTable: featureAttributes\n      },\n      Tile3DWriter\n    );\n    return b3dm;\n  }\n\n  /**\n   * Build and encode gltf\n   * @param i3sTile - Tile3D instance for I3S node\n   * @returns - encoded glb content\n   */\n  async buildGltf(\n    i3sAttributesData: I3SAttributesData,\n    featureAttributes: any\n  ): Promise<ArrayBuffer> {\n    const {tileContent, textureFormat} = i3sAttributesData;\n    const {\n      material,\n      attributes,\n      indices: originalIndices,\n      cartesianOrigin,\n      cartographicOrigin,\n      modelMatrix\n    } = tileContent;\n    const gltfBuilder = new GLTFScenegraph();\n\n    const textureIndex = await this._addI3sTextureToGltf(tileContent, textureFormat, gltfBuilder);\n    const pbrMaterialInfo = this._convertI3sMaterialToGltfMaterial(material, textureIndex);\n    const materialIndex = gltfBuilder.addMaterial(pbrMaterialInfo);\n\n    const positions = attributes.positions;\n    const positionsValue = positions.value;\n\n    if (attributes.uvRegions && attributes.texCoords) {\n      attributes.texCoords.value = convertTextureAtlas(\n        attributes.texCoords.value,\n        attributes.uvRegions.value\n      );\n    }\n\n    attributes.positions.value = this._normalizePositions(\n      positionsValue,\n      cartesianOrigin,\n      cartographicOrigin,\n      modelMatrix\n    );\n    this._createBatchIds(tileContent, featureAttributes);\n    if (attributes.normals && !this._checkNormals(attributes.normals.value)) {\n      delete attributes.normals;\n    }\n    const indices =\n      originalIndices || generateSyntheticIndices(positionsValue.length / positions.size);\n    const meshIndex = gltfBuilder.addMesh({\n      attributes,\n      indices,\n      material: materialIndex,\n      mode: 4\n    });\n    const transformMatrix = this._generateTransformMatrix(cartesianOrigin);\n    const nodeIndex = gltfBuilder.addNode({meshIndex, matrix: transformMatrix});\n    const sceneIndex = gltfBuilder.addScene({nodeIndices: [nodeIndex]});\n    gltfBuilder.setDefaultScene(sceneIndex);\n\n    gltfBuilder.createBinaryChunk();\n\n    const gltfBuffer = encodeSync(gltfBuilder.gltf, GLTFWriter);\n\n    return gltfBuffer;\n  }\n\n  /**\n   * Update gltfBuilder with texture from I3S tile\n   * @param {object} i3sTile - Tile3D object\n   * @param {GLTFScenegraph} gltfBuilder - gltfScenegraph instance to construct GLTF\n   * @returns {Promise<number | null>} - GLTF texture index\n   */\n  async _addI3sTextureToGltf(tileContent, textureFormat, gltfBuilder) {\n    const {texture, material, attributes} = tileContent;\n    let textureIndex = null;\n    let selectedTexture = texture;\n    if (!texture && material) {\n      selectedTexture =\n        material.pbrMetallicRoughness &&\n        material.pbrMetallicRoughness.baseColorTexture &&\n        material.pbrMetallicRoughness.baseColorTexture.texture.source.image;\n    }\n    if (selectedTexture) {\n      const mimeType = this._deduceMimeTypeFromFormat(textureFormat);\n      const imageIndex = gltfBuilder.addImage(selectedTexture, mimeType);\n      textureIndex = gltfBuilder.addTexture({imageIndex});\n      delete attributes.colors;\n    }\n    return textureIndex;\n  }\n\n  /**\n   * Generate a positions array which is correct for 3DTiles/GLTF format\n   * @param {Float64Array} positionsValue - the input geometry positions array\n   * @param {number[]} cartesianOrigin - the tile center in the cartesian coordinate system\n   * @param {number[]} cartographicOrigin - the tile center in the cartographic coordinate system\n   * @param {number[]} modelMatrix - the model matrix of geometry\n   * @returns {Float32Array} - the output geometry positions array\n   */\n  _normalizePositions(positionsValue, cartesianOrigin, cartographicOrigin, modelMatrix) {\n    const newPositionsValue = new Float32Array(positionsValue.length);\n    for (let index = 0; index < positionsValue.length; index += 3) {\n      const vertex = positionsValue.subarray(index, index + 3);\n      const cartesianOriginVector = new Vector3(cartesianOrigin);\n      let vertexVector = new Vector3(Array.from(vertex))\n        .transform(modelMatrix)\n        .add(cartographicOrigin);\n      Ellipsoid.WGS84.cartographicToCartesian(vertexVector, scratchVector);\n      vertexVector = scratchVector.subtract(cartesianOriginVector);\n      newPositionsValue.set(vertexVector, index);\n    }\n    return newPositionsValue;\n  }\n\n  /**\n   * Generate the transformation matrix for GLTF node:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-node\n   * 1. Create the translate transformation from cartesianOrigin (the positions array stores offsets from this cartesianOrigin)\n   * 2. Create the rotation transformation to rotate model from z-up coordinates (I3S specific) to y-up coordinates (GLTF specific)\n   * @param {number[]} cartesianOrigin - the tile center in the cartesian coordinate system\n   * @returns {Matrix4} - an array of 16 numbers (4x4 matrix)\n   */\n  _generateTransformMatrix(cartesianOrigin) {\n    const translateOriginMatrix = new Matrix4().translate(cartesianOrigin);\n    const result = translateOriginMatrix.multiplyLeft(Z_UP_TO_Y_UP_MATRIX);\n    return result;\n  }\n\n  /**\n   * Create _BATCHID attribute\n   * @param {Object} i3sContent - the source object\n   * @returns {void}\n   */\n  _createBatchIds(i3sContent, featureAttributes) {\n    const {featureIds} = i3sContent;\n    const {OBJECTID: objectIds} = featureAttributes || {};\n    if (!featureIds || !objectIds) {\n      return;\n    }\n\n    for (let i = 0; i < featureIds.length; i++) {\n      const featureId = featureIds[i];\n      const batchId = objectIds.indexOf(featureId);\n      featureIds[i] = batchId;\n    }\n\n    i3sContent.attributes._BATCHID = {\n      size: 1,\n      byteOffset: 0,\n      value: featureIds\n    };\n  }\n\n  /**\n   * Deduce mime type by format from `textureSetDefinition.formats[0].format`\n   * https://github.com/Esri/i3s-spec/blob/master/docs/1.7/textureSetDefinitionFormat.cmn.md\n   * @param {string} format - format name\n   * @returns {string} mime type.\n   */\n  _deduceMimeTypeFromFormat(format) {\n    switch (format) {\n      case 'jpg':\n        return 'image/jpeg';\n      case 'png':\n        return 'image/png';\n      case 'ktx2':\n        return 'image/ktx2';\n      default:\n        console.warn(`Unexpected texture format in I3S: ${format}`); // eslint-disable-line no-console, no-undef\n        return 'image/jpeg';\n    }\n  }\n\n  /**\n   * Convert i3s material to GLTF compatible material\n   * @param {object} material - i3s material definition\n   * @param {number | null} textureIndex - texture index in GLTF\n   * @returns {object} GLTF material\n   */\n  _convertI3sMaterialToGltfMaterial(material, textureIndex) {\n    const isTextureIndexExists = textureIndex !== null;\n\n    if (!material) {\n      material = {\n        alphaMode: 'OPAQUE',\n        doubleSided: false,\n        pbrMetallicRoughness: {\n          metallicFactor: 0,\n          roughnessFactor: 1\n        }\n      };\n\n      if (isTextureIndexExists) {\n        material.pbrMetallicRoughness.baseColorTexture = {\n          index: textureIndex,\n          texCoord: 0\n        };\n      } else {\n        material.pbrMetallicRoughness.baseColorFactor = [1, 1, 1, 1];\n      }\n\n      return material;\n    }\n\n    if (textureIndex !== null) {\n      material = this._setGltfTexture(material, textureIndex);\n    }\n\n    return material;\n  }\n\n  /**\n   * Set texture properties in material with GLTF textureIndex\n   * @param {object} materialDefinition - i3s material definition\n   * @param {number} textureIndex - texture index in GLTF\n   * @returns {void}\n   */\n  _setGltfTexture(materialDefinition, textureIndex) {\n    const material = {\n      ...materialDefinition,\n      pbrMetallicRoughness: {...materialDefinition.pbrMetallicRoughness}\n    };\n    // I3SLoader now support loading only one texture. This elseif sequence will assign this texture to one of\n    // properties defined in materialDefinition\n    if (\n      materialDefinition.pbrMetallicRoughness &&\n      materialDefinition.pbrMetallicRoughness.baseColorTexture\n    ) {\n      material.pbrMetallicRoughness.baseColorTexture = {\n        index: textureIndex,\n        texCoord: 0\n      };\n    } else if (materialDefinition.emissiveTexture) {\n      material.emissiveTexture = {\n        index: textureIndex,\n        texCoord: 0\n      };\n    } else if (\n      materialDefinition.pbrMetallicRoughness &&\n      materialDefinition.pbrMetallicRoughness.metallicRoughnessTexture\n    ) {\n      material.pbrMetallicRoughness.metallicRoughnessTexture = {\n        index: textureIndex,\n        texCoord: 0\n      };\n    } else if (materialDefinition.normalTexture) {\n      material.normalTexture = {\n        index: textureIndex,\n        texCoord: 0\n      };\n    } else if (materialDefinition.occlusionTexture) {\n      material.occlusionTexture = {\n        index: textureIndex,\n        texCoord: 0\n      };\n    }\n    return material;\n  }\n\n  /*\n   * Returns Features length based on attribute array in attribute object.\n   * @param {Object} attributes\n   * @returns {Number} Features length .\n   */\n  _getFeaturesLength(attributes) {\n    if (!attributes) {\n      return 0;\n    }\n    const firstKey = Object.keys(attributes)[0];\n    return firstKey ? attributes[firstKey].length : 0;\n  }\n\n  /* Checks that normals buffer is correct\n   * @param {TypedArray} normals\n   * @returns {boolean} true - normals are correct; false - normals are incorrect\n   */\n  _checkNormals(normals) {\n    // If all normals === 0, the resulting tileset is all in black colors on Cesium\n    return normals.find((value) => value);\n  }\n}\n"],"mappings":"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"}