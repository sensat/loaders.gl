{"version":3,"file":"geometry-converter.js","names":["_core","require","_geospatial","_draco","_core2","_loaderUtils","_md","_interopRequireDefault","_uuid","_geometryAttributes","_coordinateConverter","_gltfAttributes","_batchIdsExtensions","_featureAttributes","_math","_geometryUtils","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","_interopRequireWildcard","obj","__esModule","_typeof","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","_defineProperty2","getOwnPropertyDescriptors","defineProperties","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","return","minLen","_arrayLikeToArray","toString","slice","constructor","name","from","test","arr","len","arr2","DEFAULT_ROUGHNESS_FACTOR","DEFAULT_METALLIC_FACTOR","VALUES_PER_VERTEX","VALUES_PER_TEX_COORD","VALUES_PER_COLOR_ELEMENT","STRING_TYPE","SHORT_INT_TYPE","DOUBLE_TYPE","OBJECT_ID_TYPE","BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES","EXT_FEATURE_METADATA","EXT_MESH_FEATURES","scratchVector","Vector3","convertB3dmToI3sGeometry","_x","_x2","_x3","_x4","_x5","_x6","_x7","_x8","_x9","_x10","_convertB3dmToI3sGeometry","_asyncToGenerator2","_regenerator","mark","_callee","tileContent","addNodeToNodePage","propertyTable","featuresHashArray","attributeStorageInfo","draco","generateBoundingVolumes","shouldMergeMaterials","geoidHeightModel","workerSource","_tileContent$gltf4","useCartesianPositions","materialAndTextureList","dataForAttributesConversion","convertedAttributesMap","result","_iterator6","_step6","materialAndTexture","originarMaterialId","convertedAttributes","material","texture","nodeId","wrap","_callee$","_context","prev","convertMaterials","gltf","materials","sent","prepareDataForAttributesConversion","convertAttributes","_generateBoundingVolumesFromGeometry","mergedMaterials","originalMaterialId","abrupt","t0","_makeNodeResources","t1","t2","finish","stop","_iterator","values","_step","attributes","boundingVolumes","createBoundingVolumesFromGeometry","positions","cartographicOrigin","obb","center","index","vertex","subarray","Ellipsoid","WGS84","cartesianToCartographic","getHeight","subtract","_x11","_makeNodeResources2","_callee2","_ref","_tileContent$gltf5","vertexCount","_generateAttributes","faceRange","featureIds","normals","colors","uvRegions","texCoords","featureCount","header","typedFeatureIds","fileBuffer","compressedGeometry","_callee2$","_context2","generateAttributes","batchTableJson","makeFeatureIdsUnique","featureIndices","Uint32Array","generateBigUint64Array","Uint8Array","concatenateArrayBuffers","buffer","ArrayBuffer","generateCompressedGeometry","Float32Array","convertPropertyTableToAttributeBuffers","geometry","hasUvRegions","Boolean","sharedResources","getSharedResources","meshMaterial","_x12","_x13","_x14","_convertAttributes","_callee3","attributesData","nodes","images","cartesianModelMatrix","attributesMap","_iterator7","_step7","_iterator9","_step9","mergedMaterial","_iterator8","_step8","attrKey","_attributes","_callee3$","_context3","Map","Uint16Array","featureIndicesGroups","convertNodes","delete","reduce","acc","concat","matrix","undefined","Matrix4","_iterator2","_step2","node","convertNode","getCompositeTransformationMatrix","transformationMatrix","nodeMatrix","rotation","scale","translation","multiplyRight","translate","rotateXYZ","mesh","convertMesh","children","_iterator3","primitives","_step3","_loop","primitive","outputAttributes","materialUvRegion","_outputAttributes","_outputAttributes$mer","id","find","_ref2","_primitive$material","uvRegion","assert","mode","GL","TRIANGLES","TRIANGLE_STRIP","indices","normalizeIndices","concatenateTypedArrays","transformVertexArray","vertices","POSITION","attributeSpecificTransformation","transformVertexPositions","NORMAL","transformVertexNormals","flattenTexCoords","TEXCOORD_0","flattenColors","COLOR_0","createUvRegion","flattenBatchIds","getBatchIds","_ret","_primitive$indices","generateSyntheticIndices","TypedArrayConstructor","newIndices","triangleIndex","currentTriangle","reverse","args","newVertices","coordIndex","vertexVector","x","y","z","calleeArgs","transform","transformAsVector","newTexCoords","fill","texCoord","colorsAttribute","components","newColors","colorIndex","color","colorUint8","j","batchedIds","newBatchIds","batchIds","handleBatchIdsExtensions","possibleBatchIdAttributeName","_convertMaterials","_callee4","sourceMaterials","_iterator10","_step10","sourceMaterial","_args4","_callee4$","_context4","convertMaterial","mergeAllMaterials","_x15","_mergeAllMaterials","_callee5","newMaterial","mergedIndices","_newMaterial$mergedMa","_newMaterial$mergedMa2","newWidth","newHeight","currentX","_iterator11","_step11","aTextureMetadata","newX","_iterator12","_step12","_callee5$","_context5","splice","mergeMaterials","accum","_ref5","textureSize","width","_ref6","Math","max","height","pow","BYTES_PER_ELEMENT","image","getDefaultMaterial","_x16","_x17","_mergeMaterials","_callee6","material1","material2","_material1$texture","_material2$texture","buffer1","buffer2","_yield$import","joinImages","sharpData","_callee6$","_context6","bufferView","Buffer","data","Promise","resolve","then","direction","toFormat","mimeType","toBuffer","console","log","pbrMetallicRoughness","baseColorTexture","textureSetDefinitionId","_sourceMaterial$emiss","_sourceMaterial$pbrMe","_sourceMaterial$pbrMe2","_sourceMaterial$pbrMe3","doubleSided","emissiveFactor","map","c","round","alphaMode","convertAlphaMode","roughnessFactor","metallicFactor","emissiveTexture","Number","isFinite","uuidv4","_sourceMaterial$pbrMe4","baseColorFactor","gltfAlphaMode","gltfMaterials","i3sResources","materialDefinitionInfos","_iterator4","_step4","gltfMaterial","_convertGLTFMaterialT","convertGLTFMaterialToI3sSharedResources","materialDefinitionInfo","textureDefinitionInfo","textureDefinitionInfos","_gltfMaterial$pbrMeta","extractSharedResourcesTextureInfo","_ref3","colorFactor","extractSharedResourcesMaterialInfo","matDielectricColorComponent","black","Vector4","unitVector","dielectricSpecular","baseColorVector","firstOperand","multiply","diffuse","lerp","specular","params","toArray","renderMode","_texture$source","_texture$source2","_texture$source3","_texture$source4","encoding","generateImageId","size","_texture$source5","_ref4","levelCountOfTexture","indexOfLevel","indexOfTextureInStore","zerosCount","rightHalf","repeat","shiftedLevelCountOfTexture","shiftedIndexOfLevel","shiftedWidth","shiftedHeight","leftHalf","imageId","BigInt","batchTable","replaceMap","getFeaturesReplaceMap","replaceIndicesByUnique","featureMap","oldFeatureId","uniqueFeatureId","getOrCreateUniqueFeatureId","generateStringFromBatchTableByIndex","str","batchTableStr","hash","md5","includes","indexOf","indicesArray","attributeBuffers","needFlattenPropertyTable","checkPropertiesLength","properties","flattenPropertyTableByFeatureIds","propertyTableWithObjectIds","OBJECTID","propertyName","type","getAttributeType","attributeBuffer","generateAttributeBuffer","generateShortIntegerAttributeBuffer","generateDoubleAttributeBuffer","generateStringAttributeBuffer","attribute","attr","attributeValues","valueType","count","valuesArray","padding","Float64Array","batchAttributes","stringCountArray","totalNumberOfBytes","stringSizesArray","stringBufferArray","currentString","String","currentStringBuffer","currentStringSize","totalBytes","BigUint64Array","_x18","_x19","_x20","_x21","_generateCompressedGeometry","_callee7","dracoWorkerSoure","featureIndex","compressedAttributes","attributesMetadata","_callee7$","_context7","generateFeatureIndexAttribute","Int32Array","encode","DracoWriterWorker","options","reuseWorkers","_nodeWorkers","method","orderedFeatureIndices","fillIndex","startIndex","endIndex","getPropertyTable","_getPropertyTableExte","getPropertyTableExtension","extensionName","extension","warn","getPropertyTableFromExtFeatureMetadata","_tileContent$gltf","_tileContent$gltf2","_tileContent$gltf2$ex","_tileContent$gltf3","extensionsWithPropertyTables","extensionsUsed","_iterator5","_step5","extensionItem","extensions","featureTextures","featureTables","_Object$keys","firstFeatureTableName","featureTable"],"sources":["../../../../src/i3s-converter/helpers/geometry-converter.ts"],"sourcesContent":["import type {B3DMContent, FeatureTableJson} from '@loaders.gl/3d-tiles';\nimport type {\n  GLTF_EXT_feature_metadata,\n  GLTF_EXT_mesh_features,\n  GLTFAccessorPostprocessed,\n  GLTFMaterialPostprocessed,\n  GLTFNodePostprocessed,\n  GLTFMeshPrimitivePostprocessed,\n  GLTFMeshPostprocessed,\n  GLTFTexturePostprocessed\n} from '@loaders.gl/gltf';\n\nimport {Vector3, Matrix4, Vector4} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nimport {DracoWriterWorker} from '@loaders.gl/draco';\nimport {assert, encode} from '@loaders.gl/core';\nimport {concatenateArrayBuffers, concatenateTypedArrays} from '@loaders.gl/loader-utils';\nimport md5 from 'md5';\nimport {v4 as uuidv4} from 'uuid';\nimport {generateAttributes} from './geometry-attributes';\nimport {createBoundingVolumesFromGeometry} from './coordinate-converter';\nimport {\n  ConvertedAttributes,\n  I3SConvertedResources,\n  I3SMaterialWithTexture,\n  MergedMaterial,\n  SharedResourcesArrays\n} from '../types';\nimport {\n  AttributeStorageInfo,\n  I3SMaterialDefinition,\n  MaterialDefinitionInfo,\n  TextureDefinitionInfo\n} from '@loaders.gl/i3s';\nimport {NumberArray, TypedArray} from '@loaders.gl/loader-utils';\nimport {Geoid} from '@math.gl/geoid';\n/** Usage of worker here brings more overhead than advantage */\nimport {\n  B3DMAttributesData /*, transformI3SAttributesOnWorker*/,\n  TextureImageProperties\n} from '../../i3s-attributes-worker';\nimport {prepareDataForAttributesConversion} from './gltf-attributes';\nimport {handleBatchIdsExtensions} from './batch-ids-extensions';\nimport {checkPropertiesLength, flattenPropertyTableByFeatureIds} from './feature-attributes';\nimport {GL} from '@loaders.gl/math';\n\n/*\n  At the moment of writing the type TypedArrayConstructor is not exported in '@math.gl/types'.\n  So the following import is replaced with the local import\n  import type {TypedArrayConstructor} from '@math.gl/types'; \n*/\nimport type {TypedArrayConstructor} from '../types';\nimport {generateSyntheticIndices} from '../../lib/utils/geometry-utils';\n\n// Spec - https://github.com/Esri/i3s-spec/blob/master/docs/1.7/pbrMetallicRoughness.cmn.md\nconst DEFAULT_ROUGHNESS_FACTOR = 1;\nconst DEFAULT_METALLIC_FACTOR = 1;\n\nconst VALUES_PER_VERTEX = 3;\nconst VALUES_PER_TEX_COORD = 2;\nconst VALUES_PER_COLOR_ELEMENT = 4;\n\nconst STRING_TYPE = 'string';\nconst SHORT_INT_TYPE = 'Int32';\nconst DOUBLE_TYPE = 'Float64';\nconst OBJECT_ID_TYPE = 'Oid32';\n/*\n * 'CUSTOM_ATTRIBUTE_2' - Attribute name which includes batch info and used by New York map.\n * _BATCHID - Default attribute name which includes batch info.\n * BATCHID - Legacy attribute name which includes batch info.\n */\nconst BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES = ['CUSTOM_ATTRIBUTE_2', '_BATCHID', 'BATCHID'];\n\nconst EXT_FEATURE_METADATA = 'EXT_feature_metadata';\nconst EXT_MESH_FEATURES = 'EXT_mesh_features';\n\nlet scratchVector = new Vector3();\n\n/**\n * Convert binary data from b3dm file to i3s resources\n *\n * @param tileContent - 3d tile content\n * @param addNodeToNodePage - function to add new node to node pages\n * @param propertyTable - batch table (corresponding to feature attributes data)\n * @param featuresHashArray - hash array of features that is needed to not to mix up same features in parent and child nodes\n * @param attributeStorageInfo - attributes metadata from 3DSceneLayer json\n * @param draco - is converter should create draco compressed geometry\n * @param generateBoundingVolumes - is converter should create accurate bounding voulmes from geometry attributes\n * @param shouldMergeMaterials - Try to merge similar materials to be able to merge meshes into one node\n * @param geoidHeightModel - model to convert elevation from elipsoidal to geoid\n * @param workerSource - source code of used workers\n * @returns Array of node resources to create one or more i3s nodes\n */\nexport default async function convertB3dmToI3sGeometry(\n  tileContent: B3DMContent,\n  addNodeToNodePage: () => Promise<number>,\n  propertyTable: FeatureTableJson | null,\n  featuresHashArray: string[],\n  attributeStorageInfo: AttributeStorageInfo[] | undefined,\n  draco: boolean,\n  generateBoundingVolumes: boolean,\n  shouldMergeMaterials: boolean,\n  geoidHeightModel: Geoid,\n  workerSource: {[key: string]: string}\n): Promise<I3SConvertedResources[] | null> {\n  const useCartesianPositions = generateBoundingVolumes;\n  const materialAndTextureList: I3SMaterialWithTexture[] = await convertMaterials(\n    tileContent.gltf?.materials,\n    shouldMergeMaterials\n  );\n\n  const dataForAttributesConversion = prepareDataForAttributesConversion(tileContent);\n  const convertedAttributesMap: Map<string, ConvertedAttributes> = await convertAttributes(\n    dataForAttributesConversion,\n    materialAndTextureList,\n    useCartesianPositions\n  );\n  /** Usage of worker here brings more overhead than advantage */\n  // const convertedAttributesMap: Map<string, ConvertedAttributes> =\n  //   await transformI3SAttributesOnWorker(dataForAttributesConversion, {\n  //     reuseWorkers: true,\n  //     _nodeWorkers: true,\n  //     useCartesianPositions,\n  //     source: workerSource.I3SAttributes\n  //   });\n\n  if (generateBoundingVolumes) {\n    _generateBoundingVolumesFromGeometry(convertedAttributesMap, geoidHeightModel);\n  }\n\n  const result: I3SConvertedResources[] = [];\n  for (const materialAndTexture of materialAndTextureList) {\n    const originarMaterialId = materialAndTexture.mergedMaterials[0].originalMaterialId;\n    if (!convertedAttributesMap.has(originarMaterialId)) {\n      continue; // eslint-disable-line no-continue\n    }\n    const convertedAttributes = convertedAttributesMap.get(originarMaterialId);\n    if (!convertedAttributes) {\n      continue;\n    }\n    const {material, texture} = materialAndTexture;\n    const nodeId = await addNodeToNodePage();\n    result.push(\n      await _makeNodeResources({\n        convertedAttributes,\n        material,\n        texture,\n        tileContent,\n        nodeId,\n        featuresHashArray,\n        propertyTable,\n        attributeStorageInfo,\n        draco,\n        workerSource\n      })\n    );\n  }\n\n  if (!result.length) {\n    return null;\n  }\n  return result;\n}\n\n/**\n * Create bounding volumes based on positions\n * @param convertedAttributesMap - geometry attributes map\n * @param geoidHeightModel - geoid height model to convert elevation from elipsoidal to geoid\n */\nfunction _generateBoundingVolumesFromGeometry(\n  convertedAttributesMap: Map<string, ConvertedAttributes>,\n  geoidHeightModel: Geoid\n) {\n  for (const attributes of convertedAttributesMap.values()) {\n    const boundingVolumes = createBoundingVolumesFromGeometry(\n      attributes.positions,\n      geoidHeightModel\n    );\n\n    attributes.boundingVolumes = boundingVolumes;\n    const cartographicOrigin = boundingVolumes.obb.center;\n\n    for (let index = 0; index < attributes.positions.length; index += VALUES_PER_VERTEX) {\n      const vertex = attributes.positions.subarray(index, index + VALUES_PER_VERTEX);\n      Ellipsoid.WGS84.cartesianToCartographic(Array.from(vertex), scratchVector);\n      scratchVector[2] =\n        scratchVector[2] - geoidHeightModel.getHeight(scratchVector[1], scratchVector[0]);\n      scratchVector = scratchVector.subtract(cartographicOrigin);\n      attributes.positions.set(scratchVector, index);\n    }\n  }\n}\n\n/**\n *\n * @param params\n * @param params.convertedAttributes - Converted geometry attributes\n * @param params.material - I3S PBR-like material definition\n * @param params.texture - texture content\n * @param params.tileContent - B3DM decoded content\n * @param params.nodeId - new node ID\n * @param params.featuresHashArray - hash array of features that is needed to not to mix up same features in parent and child nodes\n * @param params.propertyTable - batch table (corresponding to feature attributes data)\n * @param params.attributeStorageInfo - attributes metadata from 3DSceneLayer json\n * @param params.draco - is converter should create draco compressed geometry\n * @param params.workerSource - source code of used workers\n * @returns Array of I3S node resources\n */\nasync function _makeNodeResources({\n  convertedAttributes,\n  material,\n  texture,\n  tileContent,\n  nodeId,\n  featuresHashArray,\n  propertyTable,\n  attributeStorageInfo,\n  draco,\n  workerSource\n}: {\n  convertedAttributes: ConvertedAttributes;\n  material: I3SMaterialDefinition;\n  texture?: {};\n  tileContent: B3DMContent;\n  nodeId: number;\n  featuresHashArray: string[];\n  propertyTable: FeatureTableJson | null;\n  attributeStorageInfo?: AttributeStorageInfo[];\n  draco: boolean;\n  workerSource: {[key: string]: string};\n}): Promise<I3SConvertedResources> {\n  const boundingVolumes = convertedAttributes.boundingVolumes;\n  const vertexCount = convertedAttributes.positions.length / VALUES_PER_VERTEX;\n  const {faceRange, featureIds, positions, normals, colors, uvRegions, texCoords, featureCount} =\n    generateAttributes(convertedAttributes);\n\n  if (tileContent.batchTableJson) {\n    makeFeatureIdsUnique(\n      featureIds,\n      convertedAttributes.featureIndices,\n      featuresHashArray,\n      tileContent.batchTableJson\n    );\n  }\n\n  const header = new Uint32Array(2);\n  const typedFeatureIds = generateBigUint64Array(featureIds);\n\n  header.set([vertexCount, featureCount], 0);\n  const fileBuffer = new Uint8Array(\n    concatenateArrayBuffers(\n      header.buffer,\n      positions.buffer,\n      normals.buffer,\n      texture ? texCoords.buffer : new ArrayBuffer(0),\n      colors.buffer,\n      uvRegions,\n      typedFeatureIds.buffer,\n      faceRange.buffer\n    )\n  );\n  const compressedGeometry = draco\n    ? generateCompressedGeometry(\n        vertexCount,\n        convertedAttributes,\n        {\n          positions,\n          normals,\n          texCoords: texture ? texCoords : new Float32Array(0),\n          colors,\n          uvRegions,\n          featureIds,\n          faceRange\n        },\n        workerSource.draco\n      )\n    : null;\n\n  let attributes: ArrayBuffer[] = [];\n\n  if (attributeStorageInfo && propertyTable) {\n    attributes = convertPropertyTableToAttributeBuffers(\n      featureIds,\n      propertyTable,\n      attributeStorageInfo\n    );\n  }\n\n  return {\n    nodeId,\n    geometry: fileBuffer,\n    compressedGeometry,\n    texture,\n    hasUvRegions: Boolean(uvRegions.length),\n    sharedResources: getSharedResources(tileContent.gltf?.materials || [], nodeId),\n    meshMaterial: material,\n    vertexCount,\n    attributes,\n    featureCount,\n    boundingVolumes\n  };\n}\n\n/**\n * Convert attributes from the gltf nodes tree to i3s plain geometry\n * @param attributesData - geometry attributes from gltf\n * @param materialAndTextureList - array of data about materials and textures of the content\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets.\n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @returns map of converted geometry attributes\n */\nexport async function convertAttributes(\n  attributesData: B3DMAttributesData,\n  materialAndTextureList: I3SMaterialWithTexture[],\n  useCartesianPositions: boolean\n): Promise<Map<string, ConvertedAttributes>> {\n  const {nodes, images, cartographicOrigin, cartesianModelMatrix} = attributesData;\n  const attributesMap = new Map<string, ConvertedAttributes>();\n\n  for (const materialAndTexture of materialAndTextureList) {\n    const attributes = {\n      positions: new Float32Array(0),\n      normals: new Float32Array(0),\n      texCoords: new Float32Array(0),\n      colors: new Uint8Array(0),\n      uvRegions: new Uint16Array(0),\n      featureIndicesGroups: [],\n      featureIndices: [],\n      boundingVolumes: null,\n      mergedMaterials: materialAndTexture.mergedMaterials\n    };\n    for (const mergedMaterial of materialAndTexture.mergedMaterials) {\n      attributesMap.set(mergedMaterial.originalMaterialId, attributes);\n    }\n  }\n\n  convertNodes(\n    nodes,\n    images,\n    cartographicOrigin,\n    cartesianModelMatrix,\n    attributesMap,\n    useCartesianPositions\n  );\n\n  for (const attrKey of attributesMap.keys()) {\n    const attributes = attributesMap.get(attrKey);\n    if (!attributes) {\n      continue;\n    }\n    if (attributes.positions.length === 0) {\n      attributesMap.delete(attrKey);\n      continue; // eslint-disable-line no-continue\n    }\n    if (attributes.featureIndicesGroups) {\n      attributes.featureIndices = attributes.featureIndicesGroups.reduce((acc, value) =>\n        acc.concat(value)\n      );\n      delete attributes.featureIndicesGroups;\n    }\n  }\n\n  return attributesMap;\n}\n\n/**\n * Gltf has hierarchical structure of nodes. This function converts nodes starting from those which are in gltf scene object.\n *   The goal is applying tranformation matrix for all children. Functions \"convertNodes\" and \"convertNode\" work together recursively.\n * @param nodes - gltf nodes array\n * @param images - gltf images array\n * @param cartographicOrigin - cartographic origin of bounding volume\n * @param cartesianModelMatrix - cartesian model matrix to convert coordinates to cartographic\n * @param attributesMap - for recursive concatenation of attributes\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets.\n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @param matrix - transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @returns {void}\n */\nfunction convertNodes(\n  nodes: GLTFNodePostprocessed[],\n  images: (TextureImageProperties | null)[],\n  cartographicOrigin: Vector3,\n  cartesianModelMatrix: Matrix4,\n  attributesMap: Map<string, ConvertedAttributes>,\n  useCartesianPositions: boolean,\n  matrix: Matrix4 = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n) {\n  if (nodes) {\n    for (const node of nodes) {\n      convertNode(\n        node,\n        images,\n        cartographicOrigin,\n        cartesianModelMatrix,\n        attributesMap,\n        useCartesianPositions,\n        matrix\n      );\n    }\n  }\n}\n\n/**\n * Generate transformation matrix for node\n * Aapply all gltf transformations to initial transformation matrix.\n * @param node\n * @param matrix\n */\nfunction getCompositeTransformationMatrix(node: GLTFNodePostprocessed, matrix: Matrix4) {\n  let transformationMatrix = matrix;\n\n  const {matrix: nodeMatrix, rotation, scale, translation} = node;\n\n  if (nodeMatrix) {\n    transformationMatrix = matrix.multiplyRight(nodeMatrix);\n  }\n\n  if (translation) {\n    transformationMatrix = transformationMatrix.translate(translation);\n  }\n\n  if (rotation) {\n    transformationMatrix = transformationMatrix.rotateXYZ(rotation);\n  }\n\n  if (scale) {\n    transformationMatrix = transformationMatrix.scale(scale);\n  }\n\n  return transformationMatrix;\n}\n\n/**\n * Convert all primitives of node and all children nodes\n * @param node - gltf node\n * @param images - gltf images array\n * @param cartographicOrigin - cartographic origin of bounding volume\n * @param cartesianModelMatrix - cartesian model matrix to convert coordinates to cartographic\n * @param {Map} attributesMap Map<{positions: Float32Array, normals: Float32Array, texCoords: Float32Array, colors: Uint8Array, featureIndices: Array}> - for recursive concatenation of\n *   attributes\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets.\n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @param {Matrix4} matrix - transformation matrix - cumulative transformation matrix formed from all parent node matrices\n */\nfunction convertNode(\n  node: GLTFNodePostprocessed,\n  images: (TextureImageProperties | null)[],\n  cartographicOrigin: Vector3,\n  cartesianModelMatrix: Matrix4,\n  attributesMap: Map<string, ConvertedAttributes>,\n  useCartesianPositions,\n  matrix = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n) {\n  const transformationMatrix = getCompositeTransformationMatrix(node, matrix);\n\n  const mesh = node.mesh;\n\n  if (mesh) {\n    convertMesh(\n      mesh,\n      images,\n      cartographicOrigin,\n      cartesianModelMatrix,\n      attributesMap,\n      useCartesianPositions,\n      transformationMatrix\n    );\n  }\n\n  convertNodes(\n    node.children || [],\n    images,\n    cartographicOrigin,\n    cartesianModelMatrix,\n    attributesMap,\n    useCartesianPositions,\n    transformationMatrix\n  );\n}\n\n/**\n * Convert all primitives of the mesh\n * @param mesh - gltf mesh data\n * @param images - gltf images array\n * @param cartographicOrigin - cartographic origin of bounding volume\n * @param cartesianModelMatrix - cartesian model matrix to convert coordinates to cartographic\n * @param attributesMap Map<{positions: Float32Array, normals: Float32Array, texCoords: Float32Array, colors: Uint8Array, featureIndices: Array}> - for recursive concatenation of\n *   attributes\n * @param useCartesianPositions - convert positions to absolute cartesian coordinates instead of cartographic offsets. \n * Cartesian coordinates will be required for creating bounding voulmest from geometry positions\n * @param attributesMap Map<{positions: Float32Array, normals: Float32Array, texCoords: Float32Array, colors: Uint8Array, featureIndices: Array}> - for recursive concatenation of\n *   attributes\n \n * @param {Matrix4} matrix - transformation matrix - cumulative transformation matrix formed from all parent node matrices\n */\nfunction convertMesh(\n  mesh: GLTFMeshPostprocessed,\n  images: (TextureImageProperties | null)[],\n  cartographicOrigin: Vector3,\n  cartesianModelMatrix: Matrix4,\n  attributesMap: Map<string, ConvertedAttributes>,\n  useCartesianPositions = false,\n  matrix = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n) {\n  for (const primitive of mesh.primitives) {\n    let outputAttributes: ConvertedAttributes | null | undefined = null;\n    let materialUvRegion: Uint16Array | undefined;\n    if (primitive.material) {\n      outputAttributes = attributesMap.get(primitive.material.id);\n      materialUvRegion = outputAttributes?.mergedMaterials.find(\n        ({originalMaterialId}) => originalMaterialId === primitive.material?.id\n      )?.uvRegion;\n    } else if (attributesMap.has('default')) {\n      outputAttributes = attributesMap.get('default');\n    }\n    assert(outputAttributes !== null, 'Primitive - material mapping failed');\n    // Per the spec https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_mesh_primitive_mode\n    // GL.TRIANGLES is default. So in case `mode` is `undefined`, it is 'TRIANGLES'\n    assert(\n      primitive.mode === undefined ||\n        primitive.mode === GL.TRIANGLES ||\n        primitive.mode === GL.TRIANGLE_STRIP,\n      `Primitive - unsupported mode ${primitive.mode}`\n    );\n    const attributes = primitive.attributes;\n    if (!outputAttributes) {\n      continue;\n    }\n\n    const indices = normalizeIndices(primitive);\n    outputAttributes.positions = concatenateTypedArrays(\n      outputAttributes.positions,\n      transformVertexArray({\n        vertices: attributes.POSITION.value,\n        cartographicOrigin,\n        cartesianModelMatrix,\n        nodeMatrix: matrix,\n        indices,\n        attributeSpecificTransformation: transformVertexPositions,\n        useCartesianPositions\n      })\n    );\n    outputAttributes.normals = concatenateTypedArrays(\n      outputAttributes.normals,\n      transformVertexArray({\n        vertices: attributes.NORMAL && attributes.NORMAL.value,\n        cartographicOrigin,\n        cartesianModelMatrix,\n        nodeMatrix: matrix,\n        indices,\n        attributeSpecificTransformation: transformVertexNormals,\n        useCartesianPositions: false\n      })\n    );\n    outputAttributes.texCoords = concatenateTypedArrays(\n      outputAttributes.texCoords,\n      flattenTexCoords(attributes.TEXCOORD_0 && attributes.TEXCOORD_0.value, indices)\n    );\n\n    outputAttributes.colors = concatenateTypedArrays(\n      outputAttributes.colors,\n      flattenColors(attributes.COLOR_0, indices)\n    );\n\n    if (materialUvRegion) {\n      outputAttributes.uvRegions = concatenateTypedArrays(\n        outputAttributes.uvRegions,\n        createUvRegion(materialUvRegion, indices)\n      );\n    }\n\n    outputAttributes.featureIndicesGroups = outputAttributes.featureIndicesGroups || [];\n    outputAttributes.featureIndicesGroups.push(\n      flattenBatchIds(getBatchIds(attributes, primitive, images), indices)\n    );\n  }\n}\n/**\n * Converts TRIANGLE-STRIPS to independent TRIANGLES\n * @param primitive - the primitive to get the indices from\n * @returns indices of vertices of the independent triangles\n */\nfunction normalizeIndices(primitive: GLTFMeshPrimitivePostprocessed): TypedArray {\n  let indices: TypedArray | undefined = primitive.indices?.value;\n  if (!indices) {\n    const positions = primitive.attributes.POSITION.value;\n    return generateSyntheticIndices(positions.length / VALUES_PER_VERTEX);\n  }\n\n  if (indices && primitive.mode === GL.TRIANGLE_STRIP) {\n    /*\n    TRIANGLE_STRIP geometry contains n+2 vertices for n triangles;\n    TRIANGLE geometry contains n*3 vertices for n triangles.\n    The conversion from TRIANGLE_STRIP to TRIANGLE implies duplicating adjacent vertices.\n    */\n    const TypedArrayConstructor = indices.constructor as TypedArrayConstructor;\n    const newIndices = new TypedArrayConstructor((indices.length - 2) * 3);\n\n    // Copy the first triangle indices with no modification like [i0, i1, i2, ...] -> [i0, i1, i2, ...]\n    let triangleIndex = 0;\n    let currentTriangle = indices.slice(0, 3);\n    newIndices.set(currentTriangle, 0);\n\n    // The rest triangle indices are being taken from strips using the following logic:\n    // [i1, i2, i3, i4, i5, i6, ...] -> [i3, i2, i1,   i2, i3, i4,   i5, i4, i3,   i4, i5, i6, ...]\n    for (let i = 1; i + 2 < indices.length; i++) {\n      triangleIndex += 3;\n      currentTriangle = indices.slice(i, i + 3);\n      if (i % 2 === 0) {\n        newIndices.set(currentTriangle, triangleIndex);\n      } else {\n        // The following \"reverce\" is necessary to calculate normals correctly\n        newIndices.set(currentTriangle.reverse(), triangleIndex);\n      }\n    }\n    indices = newIndices;\n  }\n  return indices as TypedArray;\n}\n\n/**\n * Convert vertices attributes (POSITIONS or NORMALS) to i3s compatible format\n * @param args\n * @param args.vertices - gltf primitive POSITION or NORMAL attribute\n * @param args.cartographicOrigin - cartographic origin coordinates\n * @param args.cartesianModelMatrix - a cartesian model matrix to transform coordnates from cartesian to cartographic format\n * @param args.nodeMatrix - a gltf node transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @param args.indices - gltf primitive indices\n * @param args.attributeSpecificTransformation - function to do attribute - specific transformations\n * @param args.useCartesianPositions - use coordinates as it is.\n * @returns\n */\nfunction transformVertexArray(args: {\n  vertices: TypedArray;\n  cartographicOrigin: number[];\n  cartesianModelMatrix: number[];\n  nodeMatrix: Matrix4;\n  indices: TypedArray;\n  attributeSpecificTransformation: Function;\n  useCartesianPositions: boolean;\n}): Float32Array {\n  const {vertices, indices, attributeSpecificTransformation} = args;\n  const newVertices = new Float32Array(indices.length * VALUES_PER_VERTEX);\n  if (!vertices) {\n    return newVertices;\n  }\n  for (let i = 0; i < indices.length; i++) {\n    const coordIndex = indices[i] * VALUES_PER_VERTEX;\n    const vertex = vertices.subarray(coordIndex, coordIndex + VALUES_PER_VERTEX);\n    let vertexVector = new Vector3(Array.from(vertex));\n\n    vertexVector = attributeSpecificTransformation(vertexVector, args);\n\n    newVertices[i * VALUES_PER_VERTEX] = vertexVector.x;\n    newVertices[i * VALUES_PER_VERTEX + 1] = vertexVector.y;\n    newVertices[i * VALUES_PER_VERTEX + 2] = vertexVector.z;\n  }\n  return newVertices;\n}\n\n/**\n * Trasform positions vector with the attribute specific transformations\n * @param vertexVector - source positions vector to transform\n * @param calleeArgs\n * @param calleeArgs.cartesianModelMatrix - a cartesian model matrix to transform coordnates from cartesian to cartographic format\n * @param calleeArgs.cartographicOrigin - cartographic origin coordinates\n * @param calleeArgs.nodeMatrix - a gltf node transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @param calleeArgs.useCartesianPositions - use coordinates as it is.\n * @returns transformed positions vector\n */\nfunction transformVertexPositions(vertexVector, calleeArgs): number[] {\n  const {cartesianModelMatrix, cartographicOrigin, nodeMatrix, useCartesianPositions} = calleeArgs;\n\n  if (nodeMatrix) {\n    vertexVector = vertexVector.transform(nodeMatrix);\n  }\n\n  vertexVector = vertexVector.transform(cartesianModelMatrix);\n\n  if (useCartesianPositions) {\n    return vertexVector;\n  }\n\n  Ellipsoid.WGS84.cartesianToCartographic(\n    [vertexVector[0], vertexVector[1], vertexVector[2]],\n    vertexVector\n  );\n  vertexVector = vertexVector.subtract(cartographicOrigin);\n  return vertexVector;\n}\n\n/**\n * Trasform normals vector with the attribute specific transformations\n * @param vertexVector - source normals vector to transform\n * @param calleeArgs\n * @param calleeArgs.cartesianModelMatrix - a cartesian model matrix to transform coordnates from cartesian to cartographic format\n * @param calleeArgs.nodeMatrix - a gltf node transformation matrix - cumulative transformation matrix formed from all parent node matrices\n * @returns transformed normals vector\n */\nfunction transformVertexNormals(vertexVector, calleeArgs): number[] {\n  const {cartesianModelMatrix, nodeMatrix} = calleeArgs;\n\n  if (nodeMatrix) {\n    vertexVector = vertexVector.transformAsVector(nodeMatrix);\n  }\n\n  vertexVector = vertexVector.transformAsVector(cartesianModelMatrix);\n  return vertexVector;\n}\n\n/**\n * Convert uv0 (texture coordinates) from coords based on indices to plain arrays, compatible with i3s\n * @param texCoords - gltf primitive TEXCOORD_0 attribute\n * @param indices - gltf primitive indices\n * @returns flattened texture coordinates\n */\nfunction flattenTexCoords(texCoords: TypedArray, indices: TypedArray): Float32Array {\n  const newTexCoords = new Float32Array(indices.length * VALUES_PER_TEX_COORD);\n  if (!texCoords) {\n    // We need dummy UV0s because it is required in 1.6\n    // https://github.com/Esri/i3s-spec/blob/master/docs/1.6/vertexAttribute.cmn.md\n    newTexCoords.fill(1);\n    return newTexCoords;\n  }\n  for (let i = 0; i < indices.length; i++) {\n    const coordIndex = indices[i] * VALUES_PER_TEX_COORD;\n    const texCoord = texCoords.subarray(coordIndex, coordIndex + VALUES_PER_TEX_COORD);\n    newTexCoords[i * VALUES_PER_TEX_COORD] = texCoord[0];\n    newTexCoords[i * VALUES_PER_TEX_COORD + 1] = texCoord[1];\n  }\n  return newTexCoords;\n}\n\n/**\n * Convert color from COLOR_0 based on indices to plain arrays, compatible with i3s\n * @param colorsAttribute - gltf primitive COLOR_0 attribute\n * @param indices - gltf primitive indices\n * @returns flattened colors attribute\n */\nfunction flattenColors(\n  colorsAttribute: GLTFAccessorPostprocessed,\n  indices: TypedArray\n): Uint8Array {\n  const components = colorsAttribute?.components || VALUES_PER_COLOR_ELEMENT;\n  const newColors = new Uint8Array(indices.length * components);\n  if (!colorsAttribute) {\n    // Vertex color multiplies by material color so it must be normalized 1 by default\n    newColors.fill(255);\n    return newColors;\n  }\n  const colors = colorsAttribute.value;\n  for (let i = 0; i < indices.length; i++) {\n    const colorIndex = indices[i] * components;\n    const color = colors.subarray(colorIndex, colorIndex + components);\n    const colorUint8 = new Uint8Array(components);\n    for (let j = 0; j < color.length; j++) {\n      colorUint8[j] = color[j] * 255;\n    }\n    newColors.set(colorUint8, i * components);\n  }\n  return newColors;\n}\n\n/**\n * Create per-vertex uv-region array\n * @param materialUvRegion - uv-region fragment for a single vertex\n * @param indices - geometry indices data\n * @returns - uv-region array\n */\nfunction createUvRegion(materialUvRegion: Uint16Array, indices: TypedArray): Uint16Array {\n  const result = new Uint16Array(indices.length * 4);\n  for (let i = 0; i < result.length; i += 4) {\n    result.set(materialUvRegion, i);\n  }\n  return result;\n}\n\n/**\n * Flatten batchedIds list based on indices to right ordered array, compatible with i3s\n * @param batchedIds - gltf primitive\n * @param indices - gltf primitive indices\n * @returns flattened batch ids\n */\nfunction flattenBatchIds(batchedIds: NumberArray, indices: TypedArray): number[] {\n  if (!batchedIds.length || !indices.length) {\n    return [];\n  }\n  const newBatchIds: number[] = [];\n  for (let i = 0; i < indices.length; i++) {\n    const coordIndex = indices[i];\n    newBatchIds.push(batchedIds[coordIndex]);\n  }\n  return newBatchIds;\n}\n\n/**\n * Get batchIds for featureIds creation\n * @param attributes - gltf accessors\n * @param primitive - gltf primitive data\n * @param images - gltf texture images\n */\nfunction getBatchIds(\n  attributes: {\n    [key: string]: GLTFAccessorPostprocessed;\n  },\n  primitive: GLTFMeshPrimitivePostprocessed,\n  images: (TextureImageProperties | null)[]\n): NumberArray {\n  const batchIds: NumberArray = handleBatchIdsExtensions(attributes, primitive, images);\n\n  if (batchIds.length) {\n    return batchIds;\n  }\n\n  for (let index = 0; index < BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES.length; index++) {\n    const possibleBatchIdAttributeName = BATCHED_ID_POSSIBLE_ATTRIBUTE_NAMES[index];\n    if (\n      attributes[possibleBatchIdAttributeName] &&\n      attributes[possibleBatchIdAttributeName].value\n    ) {\n      return attributes[possibleBatchIdAttributeName].value;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Convert GLTF material to I3S material definitions and textures\n * @param sourceMaterials Source GLTF materials\n * @param shouldMergeMaterials - if true - the converter will try to merge similar materials\n *                               to be able to merge primitives having those materials\n * @returns Array of Couples I3SMaterialDefinition + texture content\n */\nasync function convertMaterials(\n  sourceMaterials: GLTFMaterialPostprocessed[] = [],\n  shouldMergeMaterials: boolean\n): Promise<I3SMaterialWithTexture[]> {\n  let materials: I3SMaterialWithTexture[] = [];\n  for (const sourceMaterial of sourceMaterials) {\n    materials.push(convertMaterial(sourceMaterial));\n  }\n\n  if (shouldMergeMaterials) {\n    materials = await mergeAllMaterials(materials);\n  }\n\n  return materials;\n}\n\n/**\n * Merge materials when possible\n * @param materials materials array\n * @returns merged materials array\n */\nasync function mergeAllMaterials(\n  materials: I3SMaterialWithTexture[]\n): Promise<I3SMaterialWithTexture[]> {\n  const result: I3SMaterialWithTexture[] = [];\n  while (materials.length > 0) {\n    let newMaterial = materials.splice(0, 1)[0];\n    const mergedIndices: number[] = [];\n    for (let i = 0; i < materials.length; i++) {\n      const material = materials[i];\n      if (\n        (newMaterial.texture && material.texture) ||\n        (!newMaterial.texture && !material.texture)\n      ) {\n        newMaterial = await mergeMaterials(newMaterial, material);\n        mergedIndices.push(i);\n      }\n    }\n    if (newMaterial.texture && mergedIndices.length) {\n      const newWidth = newMaterial.mergedMaterials?.reduce(\n        (accum, {textureSize}) => accum + (textureSize?.width || 0),\n        0\n      );\n      const newHeight = newMaterial.mergedMaterials?.reduce(\n        (accum, {textureSize}) => Math.max(accum, textureSize?.height || 0),\n        0\n      );\n      let currentX = -1;\n      for (const aTextureMetadata of newMaterial.mergedMaterials) {\n        if (aTextureMetadata.textureSize) {\n          const newX =\n            currentX +\n            1 +\n            (aTextureMetadata.textureSize.width / newWidth) *\n              2 ** (Uint16Array.BYTES_PER_ELEMENT * 8) -\n            1;\n          aTextureMetadata.uvRegion = new Uint16Array([\n            currentX + 1,\n            0,\n            newX,\n            (aTextureMetadata.textureSize.height / newHeight) *\n              2 ** (Uint16Array.BYTES_PER_ELEMENT * 8) -\n              1\n          ]);\n          currentX = newX;\n        }\n      }\n\n      newMaterial.texture.image.width = newWidth;\n      newMaterial.texture.image.height = newHeight;\n    }\n    for (const index of mergedIndices.reverse()) {\n      materials.splice(index, 1);\n    }\n    result.push(newMaterial);\n  }\n\n  if (!result.length) {\n    result.push({\n      material: getDefaultMaterial(),\n      mergedMaterials: [{originalMaterialId: 'default'}]\n    });\n  }\n  return result;\n}\n\n/**\n * Merge 2 materials including texture\n * @param material1\n * @param material2\n * @returns\n */\nasync function mergeMaterials(\n  material1: I3SMaterialWithTexture,\n  material2: I3SMaterialWithTexture\n): Promise<I3SMaterialWithTexture> {\n  if (\n    material1.texture?.bufferView &&\n    material2.texture?.bufferView &&\n    material1.mergedMaterials &&\n    material2.mergedMaterials\n  ) {\n    const buffer1 = Buffer.from(material1.texture.bufferView.data);\n    const buffer2 = Buffer.from(material2.texture.bufferView.data);\n    try {\n      // @ts-ignore\n      const {joinImages} = await import('join-images');\n      const sharpData = await joinImages([buffer1, buffer2], {direction: 'horizontal'});\n      material1.texture.bufferView.data = await sharpData\n        .toFormat(material1.texture.mimeType === 'image/png' ? 'png' : 'jpeg')\n        .toBuffer();\n    } catch (error) {\n      console.log(\n        'Join images into a texture atlas has failed. Consider usage `--split-nodes` option. (See documentation https://loaders.gl/modules/tile-converter/docs/cli-reference/tile-converter)'\n      );\n      throw error;\n    }\n    // @ts-ignore\n    material1.material.pbrMetallicRoughness.baseColorTexture.textureSetDefinitionId = 1;\n  }\n  material1.mergedMaterials = material1.mergedMaterials.concat(material2.mergedMaterials);\n  return material1;\n}\n\n/**\n * Convert texture and material from gltf 2.0 material object\n * @param sourceMaterial - material object\n * @returns I3S material definition and texture\n */\nfunction convertMaterial(sourceMaterial: GLTFMaterialPostprocessed): I3SMaterialWithTexture {\n  const material: I3SMaterialDefinition = {\n    doubleSided: sourceMaterial.doubleSided,\n    emissiveFactor: sourceMaterial.emissiveFactor?.map((c) => Math.round(c * 255)) as [\n      number,\n      number,\n      number\n    ],\n    // It is in upper case in GLTF: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#alpha-coverage\n    // But it is in lower case in I3S: https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n    alphaMode: convertAlphaMode(sourceMaterial.alphaMode),\n    pbrMetallicRoughness: {\n      roughnessFactor:\n        sourceMaterial?.pbrMetallicRoughness?.roughnessFactor || DEFAULT_ROUGHNESS_FACTOR,\n      metallicFactor:\n        sourceMaterial?.pbrMetallicRoughness?.metallicFactor || DEFAULT_METALLIC_FACTOR\n    }\n  };\n\n  let texture;\n  if (sourceMaterial?.pbrMetallicRoughness?.baseColorTexture) {\n    texture = sourceMaterial.pbrMetallicRoughness.baseColorTexture.texture.source;\n    material.pbrMetallicRoughness.baseColorTexture = {\n      textureSetDefinitionId: 0\n    };\n  } else if (sourceMaterial.emissiveTexture) {\n    texture = sourceMaterial.emissiveTexture.texture.source;\n    // ArcGIS webscene doesn't show emissiveTexture but shows baseColorTexture\n    material.pbrMetallicRoughness.baseColorTexture = {\n      textureSetDefinitionId: 0\n    };\n  }\n\n  sourceMaterial.id = Number.isFinite(sourceMaterial.id) ? sourceMaterial.id : uuidv4();\n  let mergedMaterials: MergedMaterial[] = [{originalMaterialId: sourceMaterial.id}];\n  if (!texture) {\n    // Should use default baseColorFactor if it is not present in source material\n    // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-pbrmetallicroughness\n    const baseColorFactor = sourceMaterial?.pbrMetallicRoughness?.baseColorFactor;\n    material.pbrMetallicRoughness.baseColorFactor =\n      ((baseColorFactor && baseColorFactor.map((c) => Math.round(c * 255))) as [\n        number,\n        number,\n        number,\n        number\n      ]) || undefined;\n  } else {\n    mergedMaterials[0].textureSize = {width: texture.image.width, height: texture.image.height};\n  }\n\n  return {material, texture, mergedMaterials};\n}\n\n/**\n * Converts from `alphaMode` material property from GLTF to I3S format\n * @param gltfAlphaMode Gltf material `alphaMode` property\n * @returns I3SMaterialDefinition.alphaMode property\n */\nfunction convertAlphaMode(\n  gltfAlphaMode?: 'OPAQUE' | 'MASK' | 'BLEND' | string\n): 'opaque' | 'mask' | 'blend' {\n  switch (gltfAlphaMode) {\n    case 'OPAQUE':\n      return 'opaque';\n    case 'MASK':\n      return 'mask';\n    case 'BLEND':\n      return 'blend';\n    default:\n      return 'opaque';\n  }\n}\n\n/**\n * Form default I3SMaterialDefinition\n * @returns I3S material definition\n */\nfunction getDefaultMaterial(): I3SMaterialDefinition {\n  return {\n    alphaMode: 'opaque',\n    pbrMetallicRoughness: {\n      metallicFactor: 1,\n      roughnessFactor: 1\n    }\n  };\n}\n\n/**\n * Form \"sharedResources\" from gltf materials array\n * @param gltfMaterials - GLTF materials array\n * @param nodeId - I3S node ID\n * @returns {materialDefinitionInfos: Object[], textureDefinitionInfos: Object[]} -\n * 2 arrays in format of i3s sharedResources data https://github.com/Esri/i3s-spec/blob/master/docs/1.7/sharedResource.cmn.md\n */\nfunction getSharedResources(\n  gltfMaterials: GLTFMaterialPostprocessed[],\n  nodeId: number\n): SharedResourcesArrays {\n  const i3sResources: SharedResourcesArrays = {};\n\n  if (!gltfMaterials || !gltfMaterials.length) {\n    return i3sResources;\n  }\n\n  i3sResources.materialDefinitionInfos = [];\n  for (const gltfMaterial of gltfMaterials) {\n    const {materialDefinitionInfo, textureDefinitionInfo} = convertGLTFMaterialToI3sSharedResources(\n      gltfMaterial,\n      nodeId\n    );\n    i3sResources.materialDefinitionInfos.push(materialDefinitionInfo);\n    if (textureDefinitionInfo) {\n      i3sResources.textureDefinitionInfos = i3sResources.textureDefinitionInfos || [];\n      i3sResources.textureDefinitionInfos.push(textureDefinitionInfo);\n    }\n  }\n  return i3sResources;\n}\n\n/**\n * Convert gltf material into I3S sharedResources data\n * @param gltfMaterial - gltf material data\n * @param nodeId - I3S node ID\n * @returns - Couple {materialDefinitionInfo, textureDefinitionInfo} extracted from gltf material data\n */\nfunction convertGLTFMaterialToI3sSharedResources(\n  gltfMaterial: GLTFMaterialPostprocessed,\n  nodeId: number\n): {\n  materialDefinitionInfo: MaterialDefinitionInfo;\n  textureDefinitionInfo: TextureDefinitionInfo | null;\n} {\n  const texture =\n    gltfMaterial?.pbrMetallicRoughness?.baseColorTexture || gltfMaterial.emissiveTexture;\n  let textureDefinitionInfo: TextureDefinitionInfo | null = null;\n  if (texture) {\n    textureDefinitionInfo = extractSharedResourcesTextureInfo(texture.texture, nodeId);\n  }\n  const {baseColorFactor, metallicFactor} = gltfMaterial?.pbrMetallicRoughness || {};\n  let colorFactor = baseColorFactor;\n  // If alpha channel is 0 try to get emissive factor from gltf material.\n  if ((!baseColorFactor || baseColorFactor[3] === 0) && gltfMaterial.emissiveFactor) {\n    colorFactor = gltfMaterial.emissiveFactor;\n    colorFactor[3] = colorFactor[3] || 1;\n  }\n\n  return {\n    materialDefinitionInfo: extractSharedResourcesMaterialInfo(\n      colorFactor || [1, 1, 1, 1],\n      metallicFactor\n    ),\n    textureDefinitionInfo\n  };\n}\n\n/**\n * Form \"materialDefinition\" which is part of \"sharedResouces\"\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materials\n * See formulas in appendix \"Appendix B: BRDF Implementation\":\n * const dielectricSpecular = rgb(0.04, 0.04, 0.04)\n * const black = rgb(0, 0, 0)\n * cdiff = lerp(baseColor.rgb * (1 - dielectricSpecular.r), black, metallic)\n * F0 = lerp(dieletricSpecular, baseColor.rgb, metallic)\n *\n * Assumption: F0 - specular in i3s (\"specular reflection\" <-> \"reflectance value at normal incidence\")\n * cdiff - diffuse in i3s (\"Diffuse color\" <-> \"'c' diffuse\" (c means color?))\n * @param baseColorFactor - RGBA color in 0..1 format\n * @param metallicFactor - \"metallicFactor\" attribute of gltf material object\n * @returns material definition info for I3S shared resource\n */\nfunction extractSharedResourcesMaterialInfo(\n  baseColorFactor: number[],\n  metallicFactor: number = 1\n): MaterialDefinitionInfo {\n  const matDielectricColorComponent = 0.04 / 255; // Color from rgb (255) to 0..1 resolution\n  // All color resolutions are 0..1\n  const black = new Vector4(0, 0, 0, 1);\n  const unitVector = new Vector4(1, 1, 1, 1);\n  const dielectricSpecular = new Vector4(\n    matDielectricColorComponent,\n    matDielectricColorComponent,\n    matDielectricColorComponent,\n    0\n  );\n  const baseColorVector = new Vector4(baseColorFactor);\n  // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n  // Formulas for Cdiff & F0\n  const firstOperand = unitVector.subtract(dielectricSpecular).multiply(baseColorVector);\n  const diffuse = firstOperand.lerp(firstOperand, black, metallicFactor);\n  dielectricSpecular[3] = 1;\n  const specular = dielectricSpecular.lerp(dielectricSpecular, baseColorVector, metallicFactor);\n  return {\n    params: {\n      // @ts-expect-error NumericArray\n      diffuse: diffuse.toArray(),\n      // @ts-expect-error NumericArray\n      specular: specular.toArray(),\n      renderMode: 'solid'\n    }\n  };\n}\n\n/**\n * Form \"textureDefinition\" which is part of \"sharedResouces\"\n * @param texture - texture image info\n * @param nodeId - I3S node ID\n * @returns texture definition infor for shared resource\n */\nfunction extractSharedResourcesTextureInfo(\n  texture: GLTFTexturePostprocessed,\n  nodeId: number\n): TextureDefinitionInfo {\n  return {\n    encoding: texture?.source?.mimeType ? [texture.source.mimeType] : undefined,\n    images: [\n      {\n        // 'i3s' has just size which is width of the image. Images are supposed to be square.\n        // https://github.com/Esri/i3s-spec/blob/master/docs/1.7/image.cmn.md\n        id: generateImageId(texture, nodeId),\n        size: texture.source?.image.width,\n        length: texture.source?.image.data.length ? [texture.source?.image.data.length] : undefined\n      }\n    ]\n  };\n}\n\n/**\n * Formula for calculating imageId:\n * https://github.com/Esri/i3s-spec/blob/0a6366a9249b831db8436c322f8d27521e86cf07/format/Indexed%203d%20Scene%20Layer%20Format%20Specification.md#generating-image-ids\n * @param texture - texture image info\n * @param nodeId - I3S node ID\n * @returns calculate image ID according to the spec\n */\nfunction generateImageId(texture: GLTFTexturePostprocessed, nodeId: number) {\n  const {width, height} = texture.source?.image || {};\n  if (!width || !height) {\n    return '';\n  }\n  const levelCountOfTexture = 1;\n  const indexOfLevel = 0;\n  const indexOfTextureInStore = nodeId + 1;\n\n  const zerosCount = 32 - indexOfTextureInStore.toString(2).length;\n  const rightHalf = '0'.repeat(zerosCount).concat(indexOfTextureInStore.toString(2));\n\n  const shiftedLevelCountOfTexture = levelCountOfTexture << 28;\n  const shiftedIndexOfLevel = indexOfLevel << 24;\n  const shiftedWidth = (width - 1) << 12;\n  const shiftedHeight = (height - 1) << 0;\n\n  const leftHalf = shiftedLevelCountOfTexture + shiftedIndexOfLevel + shiftedWidth + shiftedHeight;\n  const imageId = BigInt(`0b${leftHalf.toString(2)}${rightHalf}`);\n  return imageId.toString();\n}\n\n/**\n * Make all feature ids unique through all nodes in layout.\n * @param featureIds\n * @param featureIndices\n * @param featuresHashArray\n * @param batchTable\n * @returns {void}\n */\nfunction makeFeatureIdsUnique(\n  featureIds: number[],\n  featureIndices: number[],\n  featuresHashArray: string[],\n  batchTable: {[key: string]: any}\n) {\n  const replaceMap = getFeaturesReplaceMap(featureIds, batchTable, featuresHashArray);\n  replaceIndicesByUnique(featureIndices, replaceMap);\n  replaceIndicesByUnique(featureIds, replaceMap);\n}\n\n/**\n * Generate replace map to make featureIds unique.\n * @param featureIds\n * @param batchTable\n * @param featuresHashArray\n * @returns\n */\nfunction getFeaturesReplaceMap(\n  featureIds: any[],\n  batchTable: object,\n  featuresHashArray: any[]\n): Record<string, any> {\n  const featureMap: Record<string, any> = {};\n\n  for (let index = 0; index < featureIds.length; index++) {\n    const oldFeatureId = featureIds[index];\n    const uniqueFeatureId = getOrCreateUniqueFeatureId(index, batchTable, featuresHashArray);\n    featureMap[oldFeatureId.toString()] = uniqueFeatureId;\n  }\n\n  return featureMap;\n}\n\n/**\n * Generates string for unique batch id creation.\n * @param batchTable\n * @param index\n * @returns\n */\nfunction generateStringFromBatchTableByIndex(batchTable: object, index: number): string {\n  let str = '';\n  for (const key in batchTable) {\n    str += batchTable[key][index];\n  }\n  return str;\n}\n\n/**\n * Return already exited featureId or creates and returns new to support unique feature ids throw nodes.\n * @param index\n * @param batchTable\n * @param featuresHashArray\n * @returns\n */\nfunction getOrCreateUniqueFeatureId(\n  index: number,\n  batchTable: object,\n  featuresHashArray: any[]\n): number {\n  const batchTableStr = generateStringFromBatchTableByIndex(batchTable, index);\n  const hash = md5(batchTableStr);\n\n  if (featuresHashArray.includes(hash)) {\n    return featuresHashArray.indexOf(hash);\n  }\n  return featuresHashArray.push(hash) - 1;\n}\n\n/**\n * Do replacement of indices for making them unique through all nodes.\n * @param indicesArray\n * @param featureMap\n * @returns\n */\nfunction replaceIndicesByUnique(indicesArray: any[], featureMap: Record<string, []>) {\n  for (let index = 0; index < indicesArray.length; index++) {\n    indicesArray[index] = featureMap[indicesArray[index]];\n  }\n}\n\n/**\n * Convert property table data to attribute buffers.\n * @param featureIds\n * @param propertyTable - table with metadata for particular feature.\n * @param attributeStorageInfo\n * @returns - Array of file buffers.\n */\nfunction convertPropertyTableToAttributeBuffers(\n  featureIds: number[],\n  propertyTable: FeatureTableJson,\n  attributeStorageInfo: AttributeStorageInfo[]\n): any[] {\n  const attributeBuffers: ArrayBuffer[] = [];\n\n  const needFlattenPropertyTable = checkPropertiesLength(featureIds, propertyTable);\n  const properties = needFlattenPropertyTable\n    ? flattenPropertyTableByFeatureIds(featureIds, propertyTable)\n    : propertyTable;\n\n  const propertyTableWithObjectIds = {\n    OBJECTID: featureIds,\n    ...properties\n  };\n\n  for (const propertyName in propertyTableWithObjectIds) {\n    const type = getAttributeType(propertyName, attributeStorageInfo);\n    const value = propertyTableWithObjectIds[propertyName];\n    const attributeBuffer = generateAttributeBuffer(type, value);\n\n    attributeBuffers.push(attributeBuffer);\n  }\n\n  return attributeBuffers;\n}\n\n/**\n * Generates attribute buffer based on attribute type\n * @param type\n * @param value\n */\nfunction generateAttributeBuffer(type: string, value: any): ArrayBuffer {\n  let attributeBuffer: ArrayBuffer;\n\n  switch (type) {\n    case OBJECT_ID_TYPE:\n    case SHORT_INT_TYPE:\n      attributeBuffer = generateShortIntegerAttributeBuffer(value);\n      break;\n    case DOUBLE_TYPE:\n      attributeBuffer = generateDoubleAttributeBuffer(value);\n      break;\n    case STRING_TYPE:\n      attributeBuffer = generateStringAttributeBuffer(value);\n      break;\n    default:\n      attributeBuffer = generateStringAttributeBuffer(value);\n  }\n\n  return attributeBuffer;\n}\n\n/**\n * Return attribute type.\n * @param key\n * @param attributeStorageInfo\n * @returns attribute type.\n */\nfunction getAttributeType(key: string, attributeStorageInfo: any[]): string {\n  const attribute = attributeStorageInfo.find((attr) => attr.name === key);\n  return attribute.attributeValues.valueType;\n}\n\n/**\n * Convert short integer to attribute arrayBuffer.\n * @param featureIds\n * @returns - Buffer with objectId data.\n */\nfunction generateShortIntegerAttributeBuffer(featureIds: any[]): ArrayBuffer {\n  const count = new Uint32Array([featureIds.length]);\n  const valuesArray = new Uint32Array(featureIds);\n  return concatenateArrayBuffers(count.buffer, valuesArray.buffer);\n}\n\n/**\n * Convert double to attribute arrayBuffer.\n * @param featureIds\n * @returns - Buffer with objectId data.\n */\nfunction generateDoubleAttributeBuffer(featureIds: any[]): ArrayBuffer {\n  const count = new Uint32Array([featureIds.length]);\n  const padding = new Uint8Array(4);\n  const valuesArray = new Float64Array(featureIds);\n\n  return concatenateArrayBuffers(count.buffer, padding.buffer, valuesArray.buffer);\n}\n\n/**\n * Convert batch table attributes to array buffer with batch table data.\n * @param batchAttributes\n * @returns - Buffer with batch table data.\n */\nfunction generateStringAttributeBuffer(batchAttributes: any[]): ArrayBuffer {\n  const stringCountArray = new Uint32Array([batchAttributes.length]);\n  let totalNumberOfBytes = 0;\n  const stringSizesArray = new Uint32Array(batchAttributes.length);\n  const stringBufferArray: ArrayBuffer[] = [];\n\n  for (let index = 0; index < batchAttributes.length; index++) {\n    const currentString = `${String(batchAttributes[index])}\\0`;\n    const currentStringBuffer = Buffer.from(currentString);\n    const currentStringSize = currentStringBuffer.length;\n    totalNumberOfBytes += currentStringSize;\n    stringSizesArray[index] = currentStringSize;\n    stringBufferArray.push(currentStringBuffer);\n  }\n\n  const totalBytes = new Uint32Array([totalNumberOfBytes]);\n\n  return concatenateArrayBuffers(\n    stringCountArray.buffer,\n    totalBytes.buffer,\n    stringSizesArray.buffer,\n    ...stringBufferArray\n  );\n}\n\n/**\n * Convert featureIds to BigUint64Array.\n * @param featureIds\n * @returns - Array of feature ids in BigUint64 format.\n */\nfunction generateBigUint64Array(featureIds: any[]): BigUint64Array {\n  const typedFeatureIds = new BigUint64Array(featureIds.length);\n  for (let index = 0; index < featureIds.length; index++) {\n    typedFeatureIds[index] = BigInt(featureIds[index]);\n  }\n  return typedFeatureIds;\n}\n\n/**\n * Generates draco compressed geometry\n * @param {Number} vertexCount\n * @param {Object} convertedAttributes - get rid of this argument here\n * @param {Object} attributes - geometry attributes to compress\n * @param {string} dracoWorkerSoure - draco worker source code\n * @returns {Promise<object>} - COmpressed geometry.\n */\nasync function generateCompressedGeometry(\n  vertexCount: number,\n  convertedAttributes: Record<string, any>,\n  attributes: Record<string, any>,\n  dracoWorkerSoure: string\n): Promise<ArrayBuffer> {\n  const {positions, normals, texCoords, colors, uvRegions, featureIds, faceRange} = attributes;\n  const indices = new Uint32Array(vertexCount);\n\n  for (let index = 0; index < indices.length; index++) {\n    indices.set([index], index);\n  }\n\n  const featureIndices = new Uint32Array(\n    convertedAttributes.featureIndices.length ? convertedAttributes.featureIndices : vertexCount\n  );\n\n  const featureIndex = generateFeatureIndexAttribute(featureIndices, faceRange);\n\n  const compressedAttributes: {\n    positions: TypedArray;\n    normals: TypedArray;\n    colors: TypedArray;\n    'feature-index': TypedArray;\n    texCoords?: TypedArray;\n    'uv-region'?: TypedArray;\n  } = {\n    positions,\n    normals,\n    colors,\n    'feature-index': featureIndex\n  };\n\n  if (texCoords.length) {\n    compressedAttributes.texCoords = texCoords;\n  }\n\n  const attributesMetadata = {\n    'feature-index': {\n      'i3s-attribute-type': 'feature-index',\n      'i3s-feature-ids': new Int32Array(featureIds)\n    }\n  };\n\n  if (uvRegions.length) {\n    compressedAttributes['uv-region'] = uvRegions;\n    attributesMetadata['uv-region'] = {\n      'i3s-attribute-type': 'uv-region'\n    };\n  }\n\n  return encode({attributes: compressedAttributes, indices}, DracoWriterWorker, {\n    ...DracoWriterWorker.options,\n    source: dracoWorkerSoure,\n    reuseWorkers: true,\n    _nodeWorkers: true,\n    draco: {\n      method: 'MESH_SEQUENTIAL_ENCODING',\n      attributesMetadata\n    }\n  });\n}\n\n/**\n * Generates ordered feature indices based on face range\n * @param featureIndex\n * @param faceRange\n * @returns\n */\nfunction generateFeatureIndexAttribute(\n  featureIndex: Uint32Array,\n  faceRange: Uint32Array\n): Uint32Array {\n  const orderedFeatureIndices = new Uint32Array(featureIndex.length);\n  let fillIndex = 0;\n  let startIndex = 0;\n\n  for (let index = 1; index < faceRange.length; index += 2) {\n    const endIndex = (faceRange[index] + 1) * VALUES_PER_VERTEX;\n\n    orderedFeatureIndices.fill(fillIndex, startIndex, endIndex);\n\n    fillIndex++;\n    startIndex = endIndex + 1;\n  }\n\n  return orderedFeatureIndices;\n}\n\n/**\n * Find property table in tile\n * For example it can be batchTable for b3dm files or property table in gLTF extension.\n * @param sourceTile\n * @return batch table from b3dm / feature properties from EXT_FEATURE_METADATA\n */\nexport function getPropertyTable(tileContent: B3DMContent): FeatureTableJson | null {\n  const batchTableJson = tileContent?.batchTableJson;\n\n  if (batchTableJson) {\n    return batchTableJson;\n  }\n\n  const {extensionName, extension} = getPropertyTableExtension(tileContent);\n\n  switch (extensionName) {\n    case EXT_MESH_FEATURES: {\n      console.warn('The I3S converter does not yet support the EXT_mesh_features extension');\n      return null;\n    }\n    case EXT_FEATURE_METADATA: {\n      return getPropertyTableFromExtFeatureMetadata(extension as GLTF_EXT_feature_metadata);\n    }\n    default:\n      return null;\n  }\n}\n\n/**\n * Check extensions which can be with property table inside.\n * @param sourceTile\n */\nfunction getPropertyTableExtension(\n  tileContent: B3DMContent\n): GLTF_EXT_feature_metadata | GLTF_EXT_mesh_features {\n  const extensionsWithPropertyTables = [EXT_FEATURE_METADATA, EXT_MESH_FEATURES];\n  const extensionsUsed = tileContent?.gltf?.extensionsUsed;\n\n  if (!extensionsUsed) {\n    return {extensionName: null, extension: null};\n  }\n\n  let extensionName: string = '';\n\n  for (const extensionItem of tileContent?.gltf?.extensionsUsed || []) {\n    if (extensionsWithPropertyTables.includes(extensionItem)) {\n      extensionName = extensionItem;\n      break;\n    }\n  }\n\n  const extension = tileContent?.gltf?.extensions?.[extensionName];\n\n  return {extensionName, extension};\n}\n\n/**\n * Handle EXT_feature_metadata to get property table\n * @param extension\n * TODO add EXT_feature_metadata feature textures support.\n */\nfunction getPropertyTableFromExtFeatureMetadata(\n  extension: GLTF_EXT_feature_metadata\n): FeatureTableJson | null {\n  if (extension?.featureTextures) {\n    console.warn(\n      'The I3S converter does not yet support the EXT_feature_metadata feature textures'\n    );\n    return null;\n  }\n\n  if (extension?.featureTables) {\n    /**\n     * Take only first feature table to generate attributes storage info object.\n     * TODO: Think about getting data from all feature tables?\n     * It can be tricky just because 3dTiles is able to have multiple featureId attributes and multiple feature tables.\n     * In I3S we should decide which featureIds attribute will be passed to geometry data.\n     */\n    const firstFeatureTableName = Object.keys(extension.featureTables)?.[0];\n\n    if (firstFeatureTableName) {\n      const featureTable = extension?.featureTables[firstFeatureTableName];\n      const propertyTable = {};\n\n      for (const propertyName in featureTable.properties) {\n        propertyTable[propertyName] = featureTable.properties[propertyName].data;\n      }\n\n      return propertyTable;\n    }\n  }\n\n  console.warn(\"The I3S converter couldn't handle EXT_feature_metadata extension\");\n  return null;\n}\n"],"mappings":"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"}