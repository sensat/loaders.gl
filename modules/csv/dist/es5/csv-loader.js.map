{"version":3,"file":"csv-loader.js","names":["_schema","require","_papaparse","_interopRequireDefault","_asyncIteratorStreamer","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty2","default","getOwnPropertyDescriptors","defineProperties","defineProperty","VERSION","DEFAULT_CSV_LOADER_OPTIONS","csv","shape","optimizeMemoryUsage","header","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","CSVLoader","id","module","name","version","extensions","mimeTypes","category","parse","_parse","_asyncToGenerator2","_regenerator","mark","_callee","arrayBuffer","options","wrap","_callee$","_context","prev","next","abrupt","parseCSV","TextDecoder","decode","stop","_x","_x2","parseText","text","parseInBatches","parseCSVInBatches","exports","_x3","_x4","_parseCSV","_callee2","csvText","csvOptions","firstRow","parseWithHeader","papaparseConfig","result","rows","headerRow","_callee2$","_context2","readFirstRow","isHeaderRow","Boolean","download","transformHeader","duplicateColumnTransformer","undefined","error","e","Error","Papa","data","meta","fields","generateHeader","t0","map","row","Array","isArray","convertToObjectRow","convertToArrayRow","asyncIterator","_options","batchSize","asyncQueue","AsyncQueue","isFirstRow","tableBatchBuilder","schema","config","chunkSize","step","results","collapsedRow","flat","join","trim","bytesUsed","cursor","deduceSchema","JSON","stringify","TableBatchBuilder","addRow","batch","getFullBatch","enqueue","complete","getFinalBatch","close","AsyncIteratorStreamer","every","value","preview","observedColumns","Set","col","colName","counter","has","concat","add","count","headers","columnName","_typeof2","String","index","type","Float32Array"],"sources":["../../src/csv-loader.ts"],"sourcesContent":["// loaders.gl, MIT license\n\nimport type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {Batch, TableBatch} from '@loaders.gl/schema';\n\nimport {\n  AsyncQueue,\n  Table,\n  TableBatchBuilder,\n  convertToArrayRow,\n  convertToObjectRow\n} from '@loaders.gl/schema';\nimport Papa from './papaparse/papaparse';\nimport AsyncIteratorStreamer from './papaparse/async-iterator-streamer';\n\ntype ObjectField = {name: string; index: number; type: any};\ntype ObjectSchema = {[key: string]: ObjectField} | ObjectField[];\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type CSVLoaderOptions = LoaderOptions & {\n  csv?: {\n    // loaders.gl options\n    shape?: 'array-row-table' | 'object-row-table' | 'columnar-table';\n    /** optimizes memory usage but increases parsing time. */\n    optimizeMemoryUsage?: boolean;\n    columnPrefix?: string;\n    header?: 'auto';\n\n    // CSV options (papaparse)\n    // delimiter: auto\n    // newline: auto\n    quoteChar?: string;\n    escapeChar?: string;\n    // Convert numbers and boolean values in rows from strings\n    dynamicTyping?: boolean;\n    comments?: boolean;\n    skipEmptyLines?: boolean | 'greedy';\n    // transform: null?\n    delimitersToGuess?: string[];\n    // fastMode: auto\n  };\n};\n\nconst DEFAULT_CSV_LOADER_OPTIONS = {\n  csv: {\n    shape: 'object-row-table',\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: true,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\nexport const CSVLoader: LoaderWithParser<Table, TableBatch, CSVLoaderOptions> = {\n  id: 'csv',\n  module: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv', 'tsv', 'dsv'],\n  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],\n  category: 'table',\n  parse: async (arrayBuffer: ArrayBuffer, options?: CSVLoaderOptions) =>\n    parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: (text: string, options?: CSVLoaderOptions) => parseCSV(text, options),\n  parseInBatches: parseCSVInBatches,\n  // @ts-ignore\n  // testText: null,\n  options: DEFAULT_CSV_LOADER_OPTIONS as CSVLoaderOptions\n};\n\nasync function parseCSV(csvText: string, options?: CSVLoaderOptions) {\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const firstRow = readFirstRow(csvText);\n  const header: boolean =\n    csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);\n\n  const parseWithHeader = header;\n\n  const papaparseConfig = {\n    // dynamicTyping: true,\n    ...csvOptions,\n    header: parseWithHeader,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,\n    error: (e) => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, papaparseConfig);\n  let {data: rows} = result;\n\n  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);\n\n  switch (csvOptions.shape) {\n    case 'object-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? convertToObjectRow(row, headerRow) : row));\n      break;\n    case 'array-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? row : convertToArrayRow(row, headerRow)));\n      break;\n    default:\n  }\n\n  /*\n  if (!header && shape === 'object-row-table') {\n    // If the dataset has no header, transform the array result into an object shape with an\n    // autogenerated header\n    return result.data.map((row) =>\n      row.reduce((acc, value, i) => {\n        acc[headerRow[i]] = value;\n        return acc;\n      }, {})\n    );\n  }\n  */\n  return rows;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: CSVLoaderOptions\n): AsyncIterable<Batch> {\n  // Papaparse does not support standard batch size handling\n  // TODO - investigate papaparse chunks mode\n  options = {...options};\n  if (options.batchSize === 'auto') {\n    options.batchSize = 4000;\n  }\n\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const asyncQueue = new AsyncQueue<Batch>();\n\n  let isFirstRow: boolean = true;\n  let headerRow: string[] | null = null;\n  let tableBatchBuilder: TableBatchBuilder | null = null;\n  let schema: ObjectSchema | null = null;\n\n  const config = {\n    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...csvOptions,\n    header: false, // Unfortunately, header detection is not automatic and does not infer shapes\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the\n    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.\n    // See https://github.com/mholt/PapaParse/issues/465\n    chunkSize: 1024 * 1024 * 5,\n    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true\n    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if\n    // both of the skipEmptyLines and step callback options are provided:\n    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465\n    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825\n    skipEmptyLines: false,\n\n    // step is called on every row\n    // eslint-disable-next-line complexity\n    step(results) {\n      let row = results.data;\n\n      if (csvOptions.skipEmptyLines) {\n        // Manually reject lines that are empty\n        const collapsedRow = row.flat().join('').trim();\n        if (collapsedRow === '') {\n          return;\n        }\n      }\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with csvOptions.header\n        const header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);\n        if (header) {\n          headerRow = row.map(duplicateColumnTransformer());\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = generateHeader(csvOptions.columnPrefix, row.length);\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      if (csvOptions.optimizeMemoryUsage) {\n        // A workaround to allocate new strings and don't retain pointers to original strings.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        row = JSON.parse(JSON.stringify(row));\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(\n          // @ts-expect-error TODO this is not a proper schema\n          schema,\n          {\n            shape: csvOptions.shape || 'array-row-table',\n            ...options\n          }\n        );\n\n      try {\n        tableBatchBuilder.addRow(row);\n        // If a batch has been completed, emit it\n        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results) {\n      try {\n        const bytesUsed = results.meta.cursor;\n        // Ensure any final (partial) batch gets emitted\n        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\n/**\n * Checks if a certain row is a header row\n * @param row the row to check\n * @returns true if the row looks like a header\n */\nfunction isHeaderRow(row: string[]): boolean {\n  return row && row.every((value) => typeof value === 'string');\n}\n\n/**\n * Reads, parses, and returns the first row of a CSV text\n * @param csvText the csv text to parse\n * @returns the first row\n */\nfunction readFirstRow(csvText: string): any[] {\n  const result = Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    preview: 1\n  });\n  return result.data[0];\n}\n\n/**\n * Creates a transformer that renames duplicate columns. This is needed as Papaparse doesn't handle\n * duplicate header columns and would use the latest occurrence by default.\n * See the header option in https://www.papaparse.com/docs#config\n * @returns a transform function that returns sanitized names for duplicate fields\n */\nfunction duplicateColumnTransformer() {\n  const observedColumns = new Set();\n  return (col) => {\n    let colName = col;\n    let counter = 1;\n    while (observedColumns.has(colName)) {\n      colName = `${col}.${counter}`;\n      counter++;\n    }\n    observedColumns.add(colName);\n    return colName;\n  };\n}\n\n/**\n * Generates the header of a CSV given a prefix and a column count\n * @param columnPrefix the columnPrefix to use\n * @param count the count of column names to generate\n * @returns an array of column names\n */\nfunction generateHeader(columnPrefix: string, count: number = 0): string[] {\n  const headers: string[] = [];\n  for (let i = 0; i < count; i++) {\n    headers.push(`${columnPrefix}${i + 1}`);\n  }\n  return headers;\n}\n\nfunction deduceSchema(row, headerRow): ObjectSchema {\n  const schema: ObjectSchema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"],"mappings":"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"}