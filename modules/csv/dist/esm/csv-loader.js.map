{"version":3,"file":"csv-loader.js","names":["AsyncQueue","TableBatchBuilder","convertToArrayRow","convertToObjectRow","Papa","AsyncIteratorStreamer","VERSION","DEFAULT_CSV_LOADER_OPTIONS","csv","shape","optimizeMemoryUsage","header","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","CSVLoader","id","module","name","version","extensions","mimeTypes","category","parse","arrayBuffer","options","parseCSV","TextDecoder","decode","parseText","text","parseInBatches","parseCSVInBatches","csvText","csvOptions","firstRow","readFirstRow","isHeaderRow","Boolean","parseWithHeader","papaparseConfig","download","transformHeader","duplicateColumnTransformer","undefined","error","e","Error","result","data","rows","headerRow","meta","fields","generateHeader","length","map","row","Array","isArray","asyncIterator","_options","batchSize","asyncQueue","isFirstRow","tableBatchBuilder","schema","config","chunkSize","step","results","collapsedRow","flat","join","trim","bytesUsed","cursor","deduceSchema","JSON","stringify","addRow","batch","getFullBatch","enqueue","complete","getFinalBatch","close","every","value","preview","observedColumns","Set","col","colName","counter","has","concat","add","count","arguments","headers","i","push","columnName","String","index","type","Float32Array"],"sources":["../../src/csv-loader.ts"],"sourcesContent":["// loaders.gl, MIT license\n\nimport type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {Batch, TableBatch} from '@loaders.gl/schema';\n\nimport {\n  AsyncQueue,\n  Table,\n  TableBatchBuilder,\n  convertToArrayRow,\n  convertToObjectRow\n} from '@loaders.gl/schema';\nimport Papa from './papaparse/papaparse';\nimport AsyncIteratorStreamer from './papaparse/async-iterator-streamer';\n\ntype ObjectField = {name: string; index: number; type: any};\ntype ObjectSchema = {[key: string]: ObjectField} | ObjectField[];\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type CSVLoaderOptions = LoaderOptions & {\n  csv?: {\n    // loaders.gl options\n    shape?: 'array-row-table' | 'object-row-table' | 'columnar-table';\n    /** optimizes memory usage but increases parsing time. */\n    optimizeMemoryUsage?: boolean;\n    columnPrefix?: string;\n    header?: 'auto';\n\n    // CSV options (papaparse)\n    // delimiter: auto\n    // newline: auto\n    quoteChar?: string;\n    escapeChar?: string;\n    // Convert numbers and boolean values in rows from strings\n    dynamicTyping?: boolean;\n    comments?: boolean;\n    skipEmptyLines?: boolean | 'greedy';\n    // transform: null?\n    delimitersToGuess?: string[];\n    // fastMode: auto\n  };\n};\n\nconst DEFAULT_CSV_LOADER_OPTIONS = {\n  csv: {\n    shape: 'object-row-table',\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: true,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\nexport const CSVLoader: LoaderWithParser<Table, TableBatch, CSVLoaderOptions> = {\n  id: 'csv',\n  module: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv', 'tsv', 'dsv'],\n  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],\n  category: 'table',\n  parse: async (arrayBuffer: ArrayBuffer, options?: CSVLoaderOptions) =>\n    parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: (text: string, options?: CSVLoaderOptions) => parseCSV(text, options),\n  parseInBatches: parseCSVInBatches,\n  // @ts-ignore\n  // testText: null,\n  options: DEFAULT_CSV_LOADER_OPTIONS as CSVLoaderOptions\n};\n\nasync function parseCSV(csvText: string, options?: CSVLoaderOptions) {\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const firstRow = readFirstRow(csvText);\n  const header: boolean =\n    csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);\n\n  const parseWithHeader = header;\n\n  const papaparseConfig = {\n    // dynamicTyping: true,\n    ...csvOptions,\n    header: parseWithHeader,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,\n    error: (e) => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, papaparseConfig);\n  let {data: rows} = result;\n\n  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);\n\n  switch (csvOptions.shape) {\n    case 'object-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? convertToObjectRow(row, headerRow) : row));\n      break;\n    case 'array-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? row : convertToArrayRow(row, headerRow)));\n      break;\n    default:\n  }\n\n  /*\n  if (!header && shape === 'object-row-table') {\n    // If the dataset has no header, transform the array result into an object shape with an\n    // autogenerated header\n    return result.data.map((row) =>\n      row.reduce((acc, value, i) => {\n        acc[headerRow[i]] = value;\n        return acc;\n      }, {})\n    );\n  }\n  */\n  return rows;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: CSVLoaderOptions\n): AsyncIterable<Batch> {\n  // Papaparse does not support standard batch size handling\n  // TODO - investigate papaparse chunks mode\n  options = {...options};\n  if (options.batchSize === 'auto') {\n    options.batchSize = 4000;\n  }\n\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const asyncQueue = new AsyncQueue<Batch>();\n\n  let isFirstRow: boolean = true;\n  let headerRow: string[] | null = null;\n  let tableBatchBuilder: TableBatchBuilder | null = null;\n  let schema: ObjectSchema | null = null;\n\n  const config = {\n    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...csvOptions,\n    header: false, // Unfortunately, header detection is not automatic and does not infer shapes\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the\n    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.\n    // See https://github.com/mholt/PapaParse/issues/465\n    chunkSize: 1024 * 1024 * 5,\n    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true\n    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if\n    // both of the skipEmptyLines and step callback options are provided:\n    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465\n    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825\n    skipEmptyLines: false,\n\n    // step is called on every row\n    // eslint-disable-next-line complexity\n    step(results) {\n      let row = results.data;\n\n      if (csvOptions.skipEmptyLines) {\n        // Manually reject lines that are empty\n        const collapsedRow = row.flat().join('').trim();\n        if (collapsedRow === '') {\n          return;\n        }\n      }\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with csvOptions.header\n        const header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);\n        if (header) {\n          headerRow = row.map(duplicateColumnTransformer());\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = generateHeader(csvOptions.columnPrefix, row.length);\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      if (csvOptions.optimizeMemoryUsage) {\n        // A workaround to allocate new strings and don't retain pointers to original strings.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        row = JSON.parse(JSON.stringify(row));\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(\n          // @ts-expect-error TODO this is not a proper schema\n          schema,\n          {\n            shape: csvOptions.shape || 'array-row-table',\n            ...options\n          }\n        );\n\n      try {\n        tableBatchBuilder.addRow(row);\n        // If a batch has been completed, emit it\n        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results) {\n      try {\n        const bytesUsed = results.meta.cursor;\n        // Ensure any final (partial) batch gets emitted\n        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\n/**\n * Checks if a certain row is a header row\n * @param row the row to check\n * @returns true if the row looks like a header\n */\nfunction isHeaderRow(row: string[]): boolean {\n  return row && row.every((value) => typeof value === 'string');\n}\n\n/**\n * Reads, parses, and returns the first row of a CSV text\n * @param csvText the csv text to parse\n * @returns the first row\n */\nfunction readFirstRow(csvText: string): any[] {\n  const result = Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    preview: 1\n  });\n  return result.data[0];\n}\n\n/**\n * Creates a transformer that renames duplicate columns. This is needed as Papaparse doesn't handle\n * duplicate header columns and would use the latest occurrence by default.\n * See the header option in https://www.papaparse.com/docs#config\n * @returns a transform function that returns sanitized names for duplicate fields\n */\nfunction duplicateColumnTransformer() {\n  const observedColumns = new Set();\n  return (col) => {\n    let colName = col;\n    let counter = 1;\n    while (observedColumns.has(colName)) {\n      colName = `${col}.${counter}`;\n      counter++;\n    }\n    observedColumns.add(colName);\n    return colName;\n  };\n}\n\n/**\n * Generates the header of a CSV given a prefix and a column count\n * @param columnPrefix the columnPrefix to use\n * @param count the count of column names to generate\n * @returns an array of column names\n */\nfunction generateHeader(columnPrefix: string, count: number = 0): string[] {\n  const headers: string[] = [];\n  for (let i = 0; i < count; i++) {\n    headers.push(`${columnPrefix}${i + 1}`);\n  }\n  return headers;\n}\n\nfunction deduceSchema(row, headerRow): ObjectSchema {\n  const schema: ObjectSchema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"],"mappings":"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"}