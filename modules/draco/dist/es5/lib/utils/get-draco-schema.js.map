{"version":3,"file":"get-draco-schema.js","names":["_schema","require","getDracoSchema","attributes","loaderData","indices","metadata","makeMetadata","fields","namedLoaderDataAttributes","transformAttributesLoaderData","attributeName","attribute","field","getArrowFieldFromAttribute","push","indicesField","result","key","dracoAttribute","name","metadataMap","undefined","deduceMeshField","Object","entries","serializedMetadata","concat","JSON","stringify"],"sources":["../../../../src/lib/utils/get-draco-schema.ts"],"sourcesContent":["import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadata = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return {fields, metadata};\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Record<string, string> {\n  Object.entries(metadata);\n  const serializedMetadata: Record<string, string> = {};\n  for (const key in metadata) {\n    serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);\n  }\n  return serializedMetadata;\n}\n"],"mappings":";;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AAKO,SAASC,cAAcA,CAC5BC,UAAoD,EACpDC,UAA2B,EAC3BC,OAAuB,EACf;EACR,IAAMC,QAAQ,GAAGC,YAAY,CAACH,UAAU,CAACE,QAAQ,CAAC;EAClD,IAAME,MAAe,GAAG,EAAE;EAC1B,IAAMC,yBAAyB,GAAGC,6BAA6B,CAACN,UAAU,CAACD,UAAU,CAAC;EACtF,KAAK,IAAMQ,cAAa,IAAIR,UAAU,EAAE;IACtC,IAAMS,SAAS,GAAGT,UAAU,CAACQ,cAAa,CAAC;IAC3C,IAAME,KAAK,GAAGC,0BAA0B,CACtCH,cAAa,EACbC,SAAS,EACTH,yBAAyB,CAACE,cAAa,CACzC,CAAC;IACDH,MAAM,CAACO,IAAI,CAACF,KAAK,CAAC;EACpB;EACA,IAAIR,OAAO,EAAE;IACX,IAAMW,YAAY,GAAGF,0BAA0B,CAAC,SAAS,EAAET,OAAO,CAAC;IACnEG,MAAM,CAACO,IAAI,CAACC,YAAY,CAAC;EAC3B;EACA,OAAO;IAACR,MAAM,EAANA,MAAM;IAAEF,QAAQ,EAARA;EAAQ,CAAC;AAC3B;AAEA,SAASI,6BAA6BA,CAACN,UAA2C,EAEhF;EACA,IAAMa,MAAiD,GAAG,CAAC,CAAC;EAC5D,KAAK,IAAMC,IAAG,IAAId,UAAU,EAAE;IAC5B,IAAMe,cAAc,GAAGf,UAAU,CAACc,IAAG,CAAC;IACtCD,MAAM,CAACE,cAAc,CAACC,IAAI,IAAI,WAAW,CAAC,GAAGD,cAAc;EAC7D;EACA,OAAOF,MAAM;AACf;AAEA,SAASH,0BAA0BA,CACjCH,aAAqB,EACrBC,SAAwB,EACxBR,UAA2B,EACpB;EACP,IAAMiB,WAAW,GAAGjB,UAAU,GAAGG,YAAY,CAACH,UAAU,CAACE,QAAQ,CAAC,GAAGgB,SAAS;EAC9E,IAAMT,KAAK,GAAG,IAAAU,uBAAe,EAACZ,aAAa,EAAEC,SAAS,EAAES,WAAW,CAAC;EACpE,OAAOR,KAAK;AACd;AAEA,SAASN,YAAYA,CAACD,QAA6C,EAA0B;EAC3FkB,MAAM,CAACC,OAAO,CAACnB,QAAQ,CAAC;EACxB,IAAMoB,kBAA0C,GAAG,CAAC,CAAC;EACrD,KAAK,IAAMR,KAAG,IAAIZ,QAAQ,EAAE;IAC1BoB,kBAAkB,IAAAC,MAAA,CAAIT,KAAG,aAAU,GAAGU,IAAI,CAACC,SAAS,CAACvB,QAAQ,CAACY,KAAG,CAAC,CAAC;EACrE;EACA,OAAOQ,kBAAkB;AAC3B"}