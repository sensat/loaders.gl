{
  "version": 3,
  "sources": ["../src/lib/utils/version.ts", "../src/draco-loader.ts", "../../schema/src/lib/table/simple-table/data-type.ts", "../../schema/src/lib/mesh/mesh-utils.ts", "../../schema/src/lib/mesh/deduce-mesh-schema.ts", "../../schema/src/index.ts", "../src/lib/utils/get-draco-schema.ts", "../src/lib/draco-parser.ts", "../../worker-utils/src/lib/env-utils/version.ts", "../../worker-utils/src/lib/env-utils/assert.ts", "../../worker-utils/src/lib/env-utils/globals.ts", "../../worker-utils/src/lib/node/require-utils.node", "../../worker-utils/src/lib/library-utils/library-utils.ts", "../../worker-utils/src/index.ts", "../src/lib/draco-module-loader.ts", "../src/lib/draco-builder.ts", "../src/draco-writer.ts", "../src/index.ts", "../src/bundle.ts"],
  "sourcesContent": ["// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "// loaders.gl, MIT license\nimport type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoMesh} from './lib/draco-types';\nimport type {DracoParseOptions} from './lib/draco-parser';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n    workerUrl?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader: Loader<DracoMesh, never, DracoLoaderOptions> = {\n  name: 'Draco',\n  id: 'draco',\n  module: 'draco',\n  // shapes: ['mesh'],\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n", "// loaders.gl, MIT license\n\nimport {DataType} from '../../../types/schema';\nimport {TypedArray, TypedArrayConstructor, ArrayType} from '../../../types/types';\n\n/** Deduce column types from values */\nexport function getDataTypeFromValue(\n  value: unknown,\n  defaultNumberType: 'float32' = 'float32'\n): DataType {\n  if (value instanceof Date) {\n    return 'date-millisecond';\n  }\n  if (value instanceof Number) {\n    return defaultNumberType;\n  }\n  if (typeof value === 'string') {\n    return 'utf8';\n  }\n  if (value === null || value === 'undefined') {\n    return 'null';\n  }\n  return 'null';\n}\n\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromArray(array: ArrayType): {type: DataType; nullable: boolean} {\n  let type = getDataTypeFromTypedArray(array as TypedArray);\n  if (type !== 'null') {\n    return {type, nullable: false};\n  }\n  if (array.length > 0) {\n    type = getDataTypeFromValue(array[0]);\n    return {type, nullable: true};\n  }\n\n  return {type: 'null', nullable: true};\n}\n\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return 'int8';\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return 'uint8';\n    case Int16Array:\n      return 'int16';\n    case Uint16Array:\n      return 'uint16';\n    case Int32Array:\n      return 'int32';\n    case Uint32Array:\n      return 'uint32';\n    case Float32Array:\n      return 'float32';\n    case Float64Array:\n      return 'float64';\n    default:\n      return 'null';\n  }\n}\n\nexport function getArrayTypeFromDataType(\n  type: DataType,\n  nullable: boolean | undefined\n): TypedArrayConstructor | ArrayConstructor {\n  if (!nullable) {\n    switch (type) {\n      case 'int8':\n        return Int8Array;\n      case 'uint8':\n        return Uint8Array;\n      case 'int16':\n        return Int16Array;\n      case 'uint16':\n        return Uint16Array;\n      case 'int32':\n        return Int32Array;\n      case 'uint32':\n        return Uint32Array;\n      case 'float32':\n        return Float32Array;\n      case 'float64':\n        return Float64Array;\n      default:\n        break;\n    }\n  }\n\n  // if (typeof BigInt64Array !== 'undefined') {\n  //   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n  //   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n  // }\n\n  return Array;\n}\n", "// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types/types';\nimport {MeshAttributes} from '../../types/category-mesh';\n\ntype TypedArrays = {[key: string]: TypedArray};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: MeshAttributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n", "// loaders.gl, MIT license\n\nimport {MeshAttribute, MeshAttributes} from '../../types/category-mesh';\nimport {Schema, Field} from '../../types/schema';\nimport {getDataTypeFromTypedArray} from '../table/simple-table/data-type';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata: Record<string, string> = {}\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return {fields, metadata};\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  name: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Record<string, string>\n): Field {\n  const type = getDataTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  return {\n    name,\n    type: {type: 'fixed-size-list', listSize: attribute.size, children: [{name: 'value', type}]},\n    nullable: false,\n    metadata\n  };\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Record<string, string> {\n  const result: Record<string, string> = {};\n  if ('byteOffset' in attribute) {\n    result.byteOffset = attribute.byteOffset!.toString(10);\n  }\n  if ('byteStride' in attribute) {\n    result.byteStride = attribute.byteStride!.toString(10);\n  }\n  if ('normalized' in attribute) {\n    result.normalized = attribute.normalized!.toString();\n  }\n  return result;\n}\n", "// COMMON CATEGORY\nexport type {\n  TypedArray,\n  TypedArrayConstructor,\n  NumberArray,\n  ArrayType,\n  AnyArray\n} from './types/types';\n\nexport type {Schema, Field, DataType, Batch, SchemaMetadata, FieldMetadata} from './types/schema';\n\n// TABLE CATEGORY TYPES\nexport type {\n  Table,\n  RowTable,\n  ArrayRowTable,\n  ObjectRowTable,\n  GeoJSONRowTable,\n  ColumnarTable,\n  ArrowTable,\n  Tables\n} from './types/category-table';\nexport type {\n  TableBatch,\n  ArrayRowTableBatch,\n  ObjectRowTableBatch,\n  GeoJSONRowTableBatch,\n  ColumnarTableBatch,\n  ArrowTableBatch\n} from './types/category-table';\n\n// TABLE CATEGORY UTILS\nexport {TableBatchBuilder} from './lib/table/batches/table-batch-builder';\nexport type {TableBatchAggregator} from './lib/table/batches/table-batch-aggregator';\nexport {RowTableBatchAggregator} from './lib/table/batches/row-table-batch-aggregator';\nexport {ColumnarTableBatchAggregator} from './lib/table/batches/columnar-table-batch-aggregator';\n\nexport {\n  getTableLength,\n  getTableNumCols,\n  getTableCell,\n  getTableRowShape,\n  getTableColumnIndex,\n  getTableColumnName,\n  getTableRowAsObject,\n  getTableRowAsArray,\n  makeRowIterator,\n  makeArrayRowIterator,\n  makeObjectRowIterator\n} from './lib/table/simple-table/table-accessors';\n\nexport {ArrowLikeTable} from './lib/table/arrow-api/arrow-like-table';\n\nexport {makeTableFromData} from './lib/table/simple-table/make-table';\nexport {deduceTableSchema} from './lib/table/simple-table/table-schema';\nexport {convertToObjectRow, convertToArrayRow} from './lib/table/simple-table/row-utils';\nexport {getDataTypeFromArray} from './lib/table/simple-table/data-type';\n\n// MESH CATEGORY\nexport type {\n  MeshTable,\n  MeshArrowTable,\n  Mesh,\n  MeshGeometry,\n  MeshAttribute,\n  MeshAttributes\n} from './types/category-mesh';\n\nexport {getMeshSize, getMeshBoundingBox} from './lib/mesh/mesh-utils';\n// Commented out due to https://github.com/visgl/deck.gl/issues/6906 and https://github.com/visgl/loaders.gl/issues/2177\n// export {convertMesh} from './category/mesh/convert-mesh';\nexport {\n  deduceMeshSchema,\n  deduceMeshField,\n  makeMeshAttributeMetadata\n} from './lib/mesh/deduce-mesh-schema';\n\n// TEXTURES\nexport type {TextureLevel, GPUTextureFormat} from './types/category-texture';\n\n// IMAGES\nexport type {ImageDataType, ImageType, ImageTypeEnum} from './types/category-image';\n\n// TYPES\n// GIS CATEGORY - GEOJSON\nexport type {\n  GeoJSON,\n  Feature,\n  FeatureCollection,\n  Geometry,\n  Position,\n  GeoJsonProperties,\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon,\n  GeometryCollection\n} from './types/category-gis';\n\nexport type {GeojsonGeometryInfo} from './types/category-gis';\n\n// GIS CATEGORY - FLAT GEOJSON\nexport type {\n  FlatFeature,\n  FlatIndexedGeometry,\n  FlatGeometry,\n  FlatGeometryType,\n  FlatPoint,\n  FlatLineString,\n  FlatPolygon\n} from './types/category-gis';\n\n// GIS CATEGORY - BINARY\nexport type {\n  BinaryGeometryType,\n  BinaryGeometry,\n  BinaryPointGeometry,\n  BinaryLineGeometry,\n  BinaryPolygonGeometry,\n  BinaryAttribute\n} from './types/category-gis';\nexport type {\n  BinaryFeatures,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures\n} from './types/category-gis';\n\n// SCHEMA\nexport {\n  Schema as ArrowLikeSchema,\n  Field as ArrowLikeField,\n  DataType as ArrowLikeDataType,\n  Null,\n  Binary,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeMillisecond,\n  TimeSecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList,\n  Struct\n} from './lib/table/arrow-api';\n\n// EXPERIMENTAL APIs\n\n// SCHEMA UTILS\nexport {getTypeInfo} from './lib/table/arrow-api/get-type-info';\nexport {getArrowType} from './lib/table/arrow/arrow-type-utils';\n\nexport {default as AsyncQueue} from './lib/utils/async-queue';\n", "import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadata = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return {fields, metadata};\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Record<string, string> {\n  Object.entries(metadata);\n  const serializedMetadata: Record<string, string> = {};\n  for (const key in metadata) {\n    serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);\n  }\n  return serializedMetadata;\n}\n", "/* eslint-disable camelcase */\n\nimport type {TypedArray, MeshAttribute, MeshGeometry} from '@loaders.gl/schema';\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  DracoMesh,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {getDracoSchema} from './utils/get-draco-schema';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMesh {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMesh = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshGeometry {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n\n// Change to `latest` on production branches\nconst DEFAULT_VERSION = 'beta';\ndeclare let __VERSION__: string;\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : DEFAULT_VERSION;\nif (typeof __VERSION__ === 'undefined') {\n  // eslint-disable-next-line\n  console.error(\n    'loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.'\n  );\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n", "// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n", "", "/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n/**\n * TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\n * 'beta' on beta branch, 'latest' on prod branch\n */\nconst LATEST = 'beta';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises: Record<string, Promise<any>> = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n\n  loadLibraryPromises[libraryUrl] =\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library: string, moduleName?: string, options?: any): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl: string): Promise<any> {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    try {\n      return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));\n    } catch {\n      return null;\n    }\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource: string, id: string): null | any {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n", "import type {WorkerObject} from './types';\nimport {VERSION} from './lib/env-utils/version';\n\n// TYPES\nexport type {\n  WorkerObject,\n  WorkerOptions,\n  // Protocol\n  WorkerMessage,\n  WorkerMessageType,\n  WorkerMessageData,\n  WorkerMessagePayload\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {isBrowser, isWorker} from './lib/env-utils/globals';\n\n// WORKER UTILS - TYPES\nexport {default as WorkerJob} from './lib/worker-farm/worker-job';\nexport {default as WorkerThread} from './lib/worker-farm/worker-thread';\n\n// WORKER FARMS\nexport {default as WorkerFarm} from './lib/worker-farm/worker-farm';\nexport {default as WorkerPool} from './lib/worker-farm/worker-pool';\nexport {default as WorkerBody} from './lib/worker-farm/worker-body';\n\nexport {processOnWorker, canProcessOnWorker} from './lib/worker-api/process-on-worker';\nexport {createWorker} from './lib/worker-api/create-worker';\n\n// WORKER UTILS - EXPORTS\nexport {getWorkerURL} from './lib/worker-api/get-worker-url';\nexport {validateWorkerVersion} from './lib/worker-api/validate-worker-version';\nexport {getTransferList, getTransferListForWriter} from './lib/worker-utils/get-transfer-list';\n\n// LIBRARY UTILS\nexport {getLibraryUrl, loadLibrary} from './lib/library-utils/library-utils';\n\n// PARSER UTILS\nexport {default as AsyncQueue} from './lib/async-queue/async-queue';\n\n// PROCESS UTILS\nexport {default as ChildProcessProxy} from './lib/process-utils/child-process-proxy';\n\n// WORKER OBJECTS\n\n/** A null worker to test that worker processing is functional */\nexport const NullWorker: WorkerObject = {\n  id: 'null',\n  name: 'null',\n  module: 'worker-utils',\n  version: VERSION,\n  options: {\n    null: {}\n  }\n};\n", "// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_DECODER_VERSION = '1.5.5';\nconst DRACO_ENCODER_VERSION = '1.4.1';\n\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\n\nconst DRACO_JS_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `${STATIC_DECODER_URL}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n", "/* eslint-disable camelcase */\n// This code is inspired by example code in the DRACO repository\nimport type {\n  Draco3D,\n  DracoInt8Array,\n  Encoder,\n  Mesh,\n  MeshBuilder,\n  PointCloud,\n  Metadata,\n  MetadataBuilder,\n  draco_GeometryAttribute_Type\n} from '../draco3d/draco3d-types';\n\nimport type {TypedArray} from '@loaders.gl/schema';\nimport type {DracoMesh} from './draco-types';\n\nexport type DracoBuildOptions = {\n  pointcloud?: boolean;\n  metadata?: {[key: string]: string};\n  attributesMetadata?: {};\n  log?: any;\n\n  // draco encoding options\n  speed?: [number, number];\n  method?: string;\n  quantization?: {[attributeName: string]: number};\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  draco: Draco3D;\n  dracoEncoder: Encoder;\n  dracoMeshBuilder: MeshBuilder;\n  dracoMetadataBuilder: MetadataBuilder;\n  log: any;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy(): void {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object): void {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  /**\n   * Encode mesh or point cloud\n   * @param mesh =({})\n   * @param options\n   */\n  encodeSync(mesh: DracoMesh, options: DracoBuildOptions = {}): ArrayBuffer {\n    this.log = noop; // TODO\n    this._setOptions(options);\n\n    return options.pointcloud\n      ? this._encodePointCloud(mesh, options)\n      : this._encodeMesh(mesh, options);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh: DracoMesh) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud: DracoMesh, options: DracoBuildOptions): ArrayBuffer {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh: DracoMesh, options: DracoBuildOptions): ArrayBuffer {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    // Build a `DracoMesh` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options: DracoBuildOptions): void {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh: Mesh, attributes, options: DracoBuildOptions): Mesh {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  /**\n   * @param {} dracoPointCloud\n   * @param {object} attributes\n   */\n  _createDracoPointCloud(\n    dracoPointCloud: PointCloud,\n    attributes: object,\n    options: DracoBuildOptions\n  ): PointCloud {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(\n          dracoPointCloud,\n          attributeName,\n          attribute,\n          vertexCount\n        );\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  /**\n   * @param mesh\n   * @param attributeName\n   * @param attribute\n   * @param vertexCount\n   */\n  _addAttributeToMesh(\n    mesh: PointCloud,\n    attributeName: string,\n    attribute: TypedArray,\n    vertexCount: number\n  ) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    const builder = this.dracoMeshBuilder;\n    const {buffer} = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param attributeName\n   */\n  _getDracoAttributeType(attributeName: string): draco_GeometryAttribute_Type | 'indices' {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add metadata for the geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param metadata\n   */\n  _addGeometryMetadata(dracoGeometry: PointCloud, metadata: {[key: string]: string}) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param uniqueAttributeId\n   * @param metadata\n   */\n  _addAttributeMetadata(\n    dracoGeometry: PointCloud,\n    uniqueAttributeId: number,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(\n      dracoGeometry,\n      uniqueAttributeId,\n      dracoAttributeMetadata\n    );\n  }\n\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param dracoMetadata - WASM Draco Object\n   * @param metadata\n   */\n  _populateDracoMetadata(\n    dracoMetadata: Metadata,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData: DracoInt8Array) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n", "import type {Writer, WriterOptions} from '@loaders.gl/loader-utils';\nimport type {DracoMesh} from './lib/draco-types';\nimport type {DracoBuildOptions} from './lib/draco-builder';\nimport DRACOBuilder from './lib/draco-builder';\nimport {loadDracoEncoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\n\n/** Writer Options for draco */\nexport type DracoWriterOptions = WriterOptions & {\n  draco?: DracoBuildOptions & {\n    method?: 'MESH_EDGEBREAKER_ENCODING' | 'MESH_SEQUENTIAL_ENCODING';\n    speed?: [number, number];\n    quantization?: Record<string, number>;\n    attributeNameEntry?: string;\n  };\n};\n\nconst DEFAULT_DRACO_WRITER_OPTIONS = {\n  pointcloud: false, // Set to true if pointcloud (mode: 0, no indices)\n  attributeNameEntry: 'name'\n  // Draco Compression Parameters\n  // method: 'MESH_EDGEBREAKER_ENCODING', // Use draco defaults\n  // speed: [5, 5], // Use draco defaults\n  // quantization: { // Use draco defaults\n  //   POSITION: 10\n  // }\n};\n\n/**\n * Exporter for Draco3D compressed geometries\n */\nexport const DracoWriter: Writer<DracoMesh, unknown, DracoWriterOptions> = {\n  name: 'DRACO',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  extensions: ['drc'],\n  encode,\n  options: {\n    draco: DEFAULT_DRACO_WRITER_OPTIONS\n  }\n};\n\nasync function encode(data: DracoMesh, options: DracoWriterOptions = {}): Promise<ArrayBuffer> {\n  // Dynamically load draco\n  const {draco} = await loadDracoEncoderModule(options);\n  const dracoBuilder = new DRACOBuilder(draco);\n\n  try {\n    return dracoBuilder.encodeSync(data, options.draco);\n  } finally {\n    dracoBuilder.destroy();\n  }\n}\n", "// loaders.gl, MIT license\nimport type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMesh, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\n\n// Draco data types\n\nexport type {DracoMesh, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n/**\n * Browser worker doesn't work because of issue during \"draco_encoder.js\" loading.\n * Refused to execute script from 'https://raw.githubusercontent.com/google/draco/1.4.1/javascript/draco_encoder.js' because its MIME type ('') is not executable.\n */\nexport const DracoWriterWorker = {\n  id: 'draco-writer',\n  name: 'Draco compressed geometry writer',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  options: {\n    draco: {},\n    source: null\n  }\n};\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader: LoaderWithParser<DracoMesh, never, DracoLoaderOptions> = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: DracoLoaderOptions): Promise<DracoMesh> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n", "// @ts-nocheck\nconst moduleExports = require('./index');\nglobalThis.loaders = globalThis.loaders || {};\nmodule.exports = Object.assign(globalThis.loaders, moduleExports);\n"],
  "mappings": "osBAAA,GAGa,GAHb,SAGO,AAAM,EAAU,MAAO,cAAgB,YAAc,YAAc,WCH1E,GAgBM,IAYO,EA5Bb,SAIA,IAYA,AAAM,GAA4C,CAChD,MAAO,CACL,YAAa,MAAO,cAAgB,SAAW,OAAS,KACxD,YAAa,QACb,gBAAiB,GACjB,mBAAoB,SAOX,EAA4D,CACvE,KAAM,QACN,GAAI,QACJ,OAAQ,QAER,QAAS,EACT,OAAQ,GACR,WAAY,CAAC,OACb,UAAW,CAAC,4BACZ,OAAQ,GACR,MAAO,CAAC,SACR,QAAS,MCKJ,WAAmC,EAA6B,CACrE,OAAQ,EAAM,iBACP,WACH,MAAO,WACJ,gBACA,mBACH,MAAO,YACJ,YACH,MAAO,YACJ,aACH,MAAO,aACJ,YACH,MAAO,YACJ,aACH,MAAO,aACJ,cACH,MAAO,cACJ,cACH,MAAO,kBAEP,MAAO,QAhEb,gBCmCO,WAA4B,EAAyC,CAC1E,GAAI,GAAO,IACP,EAAO,IACP,EAAO,IACP,EAAO,KACP,EAAO,KACP,EAAO,KAEL,EAAY,EAAW,SAAW,EAAW,SAAS,MAAQ,GAC9D,EAAM,GAAa,EAAU,OAEnC,OAAS,GAAI,EAAG,EAAI,EAAK,GAAK,EAAG,CAC/B,GAAM,GAAI,EAAU,GACd,EAAI,EAAU,EAAI,GAClB,EAAI,EAAU,EAAI,GAExB,EAAO,EAAI,EAAO,EAAI,EACtB,EAAO,EAAI,EAAO,EAAI,EACtB,EAAO,EAAI,EAAO,EAAI,EAEtB,EAAO,EAAI,EAAO,EAAI,EACtB,EAAO,EAAI,EAAO,EAAI,EACtB,EAAO,EAAI,EAAO,EAAI,EAExB,MAAO,CACL,CAAC,EAAM,EAAM,GACb,CAAC,EAAM,EAAM,IA7DjB,gBC2BO,WACL,EACA,EACA,EACO,CACP,GAAM,GAAO,EAA0B,EAAU,OAC3C,EAAW,GAAsC,EAA0B,GACjF,MAAO,CACL,OACA,KAAM,CAAC,KAAM,kBAAmB,SAAU,EAAU,KAAM,SAAU,CAAC,CAAC,KAAM,QAAS,UACrF,SAAU,GACV,YAuBG,WAAmC,EAAkD,CAC1F,GAAM,GAAiC,GACvC,MAAI,cAAgB,IAClB,GAAO,WAAa,EAAU,WAAY,SAAS,KAEjD,cAAgB,IAClB,GAAO,WAAa,EAAU,WAAY,SAAS,KAEjD,cAAgB,IAClB,GAAO,WAAa,EAAU,WAAY,YAErC,EAxET,aAIA,MCJA,aAoEA,IAGA,MClEO,WACL,EACA,EACA,EACQ,CACR,GAAM,GAAW,EAAa,EAAW,UACnC,EAAkB,GAClB,EAA4B,GAA8B,EAAW,YAC3E,OAAW,KAAiB,GAAY,CACtC,GAAM,GAAY,EAAW,GACvB,EAAQ,EACZ,EACA,EACA,EAA0B,IAE5B,EAAO,KAAK,GAEd,GAAI,EAAS,CACX,GAAM,GAAe,EAA2B,UAAW,GAC3D,EAAO,KAAK,GAEd,MAAO,CAAC,SAAQ,YAGlB,YAAuC,EAErC,CACA,GAAM,GAAoD,GAC1D,OAAW,KAAO,GAAY,CAC5B,GAAM,GAAiB,EAAW,GAClC,EAAO,EAAe,MAAQ,aAAe,EAE/C,MAAO,GAGT,WACE,EACA,EACA,EACO,CACP,GAAM,GAAc,EAAa,EAAa,EAAW,UAAY,OAErE,MADc,GAAgB,EAAe,EAAW,GAI1D,WAAsB,EAAuE,CAC3F,OAAO,QAAQ,GACf,GAAM,GAA6C,GACnD,OAAW,KAAO,GAChB,EAAmB,GAAG,YAAgB,KAAK,UAAU,EAAS,IAEhE,MAAO,GAxDT,mBCsjBA,YAA0B,EAAgB,EAAoC,CAC5E,OAAQ,OACD,cACH,MAAO,GAAM,eACV,WACH,MAAO,GAAM,YACV,YACH,MAAO,GAAM,aACV,YACH,MAAO,GAAM,aACV,YACH,MAAO,GAAM,aACV,aACH,MAAO,GAAM,cACV,aACH,MAAO,GAAM,kBAEb,MAAO,GAAM,YAOnB,YAAuB,EAAyC,CAC9D,GAAM,GAAY,EAAW,OACvB,EAAW,GAAI,YAAW,GAChC,OAAS,GAAI,EAAG,EAAI,EAAW,IAC7B,EAAS,GAAK,EAAW,SAAS,GAEpC,MAAO,GAMT,YAAwB,EAAyC,CAC/D,GAAM,GAAY,EAAW,OACvB,EAAW,GAAI,YAAW,GAChC,OAAS,GAAI,EAAG,EAAI,EAAW,IAC7B,EAAS,GAAK,EAAW,SAAS,GAEpC,MAAO,GAhmBT,GAqDM,GAOA,GAUA,GAEN,EAxEA,SA2BA,IACA,IAyBA,AAAM,EAAmC,CACvC,SAAU,WACV,OAAQ,SACR,MAAO,UACP,UAAW,cAGP,GAAqC,CACzC,EAAG,UACH,EAAG,WACH,EAAG,WACH,EAAG,YACH,EAAG,WACH,EAAG,YACH,EAAG,cAGC,GAAkB,EAExB,OAAiC,CAM/B,YAAY,EAAgB,CAC1B,KAAK,MAAQ,EACb,KAAK,QAAU,GAAI,MAAK,MAAM,QAC9B,KAAK,gBAAkB,GAAI,MAAK,MAAM,gBAMxC,SAAgB,CACd,KAAK,MAAM,QAAQ,KAAK,SACxB,KAAK,MAAM,QAAQ,KAAK,iBAQ1B,UAAU,EAA0B,EAA6B,GAAe,CAC9E,GAAM,GAAS,GAAI,MAAK,MAAM,cAC9B,EAAO,KAAK,GAAI,WAAU,GAAc,EAAY,YAEpD,KAAK,4BAA4B,GAEjC,GAAM,GAAgB,KAAK,QAAQ,uBAAuB,GACpD,EACJ,IAAkB,KAAK,MAAM,gBACzB,GAAI,MAAK,MAAM,KACf,GAAI,MAAK,MAAM,WAErB,GAAI,CACF,GAAI,GACJ,OAAQ,OACD,MAAK,MAAM,gBACd,EAAc,KAAK,QAAQ,mBAAmB,EAAQ,GACtD,UAEG,MAAK,MAAM,YACd,EAAc,KAAK,QAAQ,yBAAyB,EAAQ,GAC5D,cAGA,KAAM,IAAI,OAAM,iCAGpB,GAAI,CAAC,EAAY,MAAQ,CAAC,EAAc,IAAK,CAC3C,GAAM,GAAU,+BAA+B,EAAY,cAE3D,KAAM,IAAI,OAAM,GAGlB,GAAM,GAAa,KAAK,oBAAoB,EAAe,EAAe,GAEpE,EAAW,KAAK,aAAa,EAAe,EAAY,GAExD,EAAc,EAAmB,EAAS,YAE1C,EAAS,EAAe,EAAS,WAAY,EAAY,EAAS,SAYxE,MAVwB,CACtB,OAAQ,QACR,aACA,OAAQ,CACN,YAAa,EAAc,aAC3B,kBAEC,EACH,iBAGF,CACA,KAAK,MAAM,QAAQ,GACf,GACF,KAAK,MAAM,QAAQ,IAczB,oBACE,EACA,EACA,EACiB,CACjB,GAAM,GAAW,KAAK,qBAAqB,GACrC,EAAa,KAAK,oBAAoB,EAAe,GAE3D,MAAO,CACL,gBACA,eAAgB,EAAc,iBAC9B,WAAY,EAAc,aAC1B,UAAW,YAAyB,MAAK,MAAM,KAAO,EAAc,YAAc,EAClF,WACA,cAUJ,oBACE,EACA,EACuC,CACvC,GAAM,GAAyD,GAE/D,OAAS,GAAc,EAAG,EAAc,EAAc,iBAAkB,IAAe,CAGrF,GAAM,GAAiB,KAAK,QAAQ,aAAa,EAAe,GAE1D,EAAW,KAAK,sBAAsB,EAAe,GAE3D,EAAgB,EAAe,aAAe,CAC5C,UAAW,EAAe,YAC1B,eAAgB,EAAe,iBAC/B,UAAW,EAAe,YAC1B,eAAgB,EAAe,iBAE/B,YAAa,EAAe,cAC5B,YAAa,EAAe,cAC5B,WAAY,EAAe,aAC3B,gBAAiB,EAEjB,YAIF,GAAM,GAAe,KAAK,0BAA0B,EAAgB,GACpE,AAAI,GACF,GAAgB,EAAe,aAAa,uBAAyB,GAGvE,GAAM,GAAa,KAAK,wBAAwB,EAAgB,GAChE,AAAI,GACF,GAAgB,EAAe,aAAa,qBAAuB,GAIvE,MAAO,GAST,aACE,EACA,EACA,EACc,CACd,GAAM,GAAa,KAAK,mBAAmB,EAAY,EAAe,GAGtE,GAAI,CADsB,EAAW,SAEnC,KAAM,IAAI,OAAM,uCAIlB,GAAI,YAAyB,MAAK,MAAM,KACtC,OAAQ,EAAQ,cACT,iBACH,MAAO,CACL,SAAU,iBACV,KAAM,EACN,aACA,QAAS,CACP,MAAO,KAAK,yBAAyB,GACrC,KAAM,QAGP,wBAEH,MAAO,CACL,SAAU,gBACV,KAAM,EACN,aACA,QAAS,CACP,MAAO,KAAK,wBAAwB,GACpC,KAAM,IAOhB,MAAO,CACL,SAAU,aACV,KAAM,EACN,cAIJ,mBACE,EACA,EACA,EAC0C,CAC1C,GAAM,GAA6C,GAEnD,OAAW,KAAmB,QAAO,OAAO,EAAW,YAAa,CAClE,GAAM,GAAgB,KAAK,qBAAqB,EAAiB,GACjE,EAAgB,KAAO,EACvB,GAAM,CAAC,QAAO,QAAQ,KAAK,oBAAoB,EAAe,GAC9D,EAAW,GAAiB,CAC1B,QACA,OACA,WAAY,EAAgB,YAC5B,WAAY,EAAgB,YAC5B,WAAY,EAAgB,YAIhC,MAAO,GAST,wBAAwB,EAAqB,CAG3C,GAAM,GAAa,AADF,EAAc,YACD,EACxB,EAAa,EAAa,GAE1B,EAAM,KAAK,MAAM,QAAQ,GAC/B,GAAI,CACF,YAAK,QAAQ,wBAAwB,EAAe,EAAY,GACzD,GAAI,aAAY,KAAK,MAAM,QAAQ,OAAQ,EAAK,GAAY,eACnE,CACA,KAAK,MAAM,MAAM,IAQrB,yBAAyB,EAAqB,CAC5C,GAAM,GAAa,GAAI,MAAK,MAAM,gBAClC,GAAI,CACsB,YAAK,QAAQ,0BAA0B,EAAe,GACvE,GAAe,UACtB,CACA,KAAK,MAAM,QAAQ,IAUvB,oBACE,EACA,EACmC,CACnC,GAAM,GAAiB,GAAmC,EAAU,WAC9D,EAAgB,EAAU,eAE1B,EAAY,AADA,EAAc,aACF,EAExB,EAAa,EAAY,EAAe,kBACxC,EAAW,GAAiB,KAAK,MAAO,GAE1C,EAEE,EAAM,KAAK,MAAM,QAAQ,GAC/B,GAAI,CACF,GAAM,GAAiB,KAAK,QAAQ,aAAa,EAAe,EAAU,iBAC1E,KAAK,QAAQ,kCACX,EACA,EACA,EACA,EACA,GAEF,EAAQ,GAAI,GAAe,KAAK,MAAM,QAAQ,OAAQ,EAAK,GAAW,eACtE,CACA,KAAK,MAAM,MAAM,GAGnB,MAAO,CAAC,QAAO,KAAM,GA6BvB,qBAAqB,EAA2B,EAAoC,CAElF,GAAM,GAAW,EAAU,UAC3B,OAAW,CAAC,EAAe,IAAsB,QAAO,QACtD,EAAQ,iBAAmB,IAE3B,GAAI,IAAsB,EACxB,MAAO,GAKX,GAAM,GAAoB,EAAU,eACpC,OAAW,KAA0B,GAEnC,GAAI,AADkB,KAAK,MAAM,KACX,EAGpB,MAAO,GAAiC,GAM5C,GAAM,GAAY,EAAQ,oBAAsB,OAChD,MAAI,GAAU,SAAS,GACd,EAAU,SAAS,GAAW,OAIhC,oBAAoB,IAM7B,qBAAqB,EAAkC,CACrD,GAAM,GAAgB,KAAK,QAAQ,YAAY,GAC/C,MAAO,MAAK,kBAAkB,GAIhC,sBAAsB,EAAkC,EAAqB,CAC3E,GAAM,GAAgB,KAAK,QAAQ,qBAAqB,EAAe,GACvE,MAAO,MAAK,kBAAkB,GAQhC,kBAAkB,EAAgE,CAEhF,GAAI,CAAC,GAAiB,CAAC,EAAc,IACnC,MAAO,GAET,GAAM,GAAS,GACT,EAAa,KAAK,gBAAgB,WAAW,GACnD,OAAS,GAAa,EAAG,EAAa,EAAY,IAAc,CAC9D,GAAM,GAAY,KAAK,gBAAgB,aAAa,EAAe,GACnE,EAAO,GAAa,KAAK,uBAAuB,EAAe,GAEjE,MAAO,GAQT,uBAAuB,EAAyB,EAAuC,CACrF,GAAM,GAAa,GAAI,MAAK,MAAM,gBAClC,GAAI,CAEF,KAAK,gBAAgB,iBAAiB,EAAe,EAAW,GAChE,GAAM,GAAW,GAAc,GAC/B,MAAO,CACL,IAAK,KAAK,gBAAgB,YAAY,EAAe,GACrD,OAAQ,KAAK,gBAAgB,eAAe,EAAe,GAC3D,OAAQ,KAAK,gBAAgB,eAAe,EAAe,GAC3D,mBAEF,CACA,KAAK,MAAM,QAAQ,IAOvB,4BAA4B,EAA4B,CACtD,GAAM,CAAC,sBAAsB,GAAI,uBAAuB,IAAM,EACxD,EAAiB,CAAC,GAAG,EAAqB,GAAG,GACnD,OAAW,KAAsB,GAC/B,KAAK,QAAQ,uBAAuB,KAAK,MAAM,IAQnD,0BACE,EACA,EACmC,CACnC,GAAM,CAAC,sBAAsB,IAAM,EAC7B,EAAiB,EAAe,iBAEtC,GADa,EAAoB,IAAI,AAAC,GAAS,KAAK,QAAQ,IAAO,SAAS,GAClE,CACR,GAAM,GAAY,GAAI,MAAK,MAAM,+BACjC,GAAI,CACF,GAAI,EAAU,kBAAkB,GAC9B,MAAO,CACL,kBAAmB,EAAU,oBAC7B,MAAO,EAAU,QACjB,WAAY,GAAI,cAAa,CAAC,EAAG,EAAG,IAAI,IAAI,AAAC,GAAM,EAAU,UAAU,YAG3E,CACA,KAAK,MAAM,QAAQ,IAGvB,MAAO,MAGT,wBACE,EACA,EACiC,CACjC,GAAM,CAAC,uBAAuB,IAAM,EAC9B,EAAiB,EAAe,iBAItC,GAHmB,EAChB,IAAI,AAAC,GAAS,KAAK,QAAQ,IAC3B,SAAS,GACI,CACd,GAAM,GAAY,GAAI,MAAK,MAAM,+BACjC,GAAI,CACF,GAAI,EAAU,kBAAkB,GAC9B,MAAO,CACL,kBAAmB,EAAU,4BAGjC,CACA,KAAK,MAAM,QAAQ,IAGvB,MAAO,UC3iBX,GAIM,IAEO,EANb,SAIA,AAAM,GAAkB,OAEX,EAAU,MAAO,cAAgB,YAAc,YAAc,GAC1E,AAAI,MAAO,cAAgB,aAEzB,QAAQ,MACN,qICLG,WAAgB,EAAgB,EAAwB,CAC7D,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,GAAW,gCAP/B,gBCAA,GAIM,GAOA,GACA,GACA,EACA,GAKO,EAKA,EAGA,GAIP,EAIO,GAnCb,SAIA,AAAM,EAAU,CACd,KAAM,MAAO,OAAS,aAAe,KACrC,OAAQ,MAAO,SAAW,aAAe,OACzC,OAAQ,MAAO,SAAW,aAAe,OACzC,SAAU,MAAO,WAAa,aAAe,UAGzC,GAA8B,EAAQ,MAAQ,EAAQ,QAAU,EAAQ,QAAU,GAClF,GAAgC,EAAQ,QAAU,EAAQ,MAAQ,EAAQ,QAAU,GACpF,EAAgC,EAAQ,QAAU,EAAQ,MAAQ,EAAQ,QAAU,GACpF,GAAkC,EAAQ,UAAY,GAK/C,EAEX,MAAO,UAAY,UAAY,OAAO,WAAa,oBAAsB,QAAQ,QAGtE,EAAoB,MAAO,gBAAkB,WAG7C,GACX,MAAO,SAAW,aAAe,MAAO,QAAO,aAAgB,YAG3D,EACJ,MAAO,UAAY,aAAe,QAAQ,SAAW,YAAY,KAAK,QAAQ,SAGnE,GAAuB,GAAW,WAAW,EAAQ,KAAQ,ICnC1E,iBC8BA,iBACE,EACA,EAA4B,KAC5B,EAAkB,GACJ,CACd,MAAI,IACF,GAAa,GAAc,EAAY,EAAY,IAKrD,EAAoB,GAElB,EAAoB,IAAe,GAAoB,GAClD,KAAM,GAAoB,GAI5B,YAAuB,EAAiB,EAAqB,EAAuB,CAEzF,GAAI,EAAQ,WAAW,QACrB,MAAO,GAIT,GAAM,GAAU,EAAQ,SAAW,GACnC,MAAI,GAAQ,GACH,EAAQ,GAKZ,EAKD,EAAQ,IACV,GAAO,EAAQ,IAAI,WAAW,SACvB,GAAG,EAAQ,OAAO,KAAc,gBAAqB,KAI1D,EACK,eAAe,IAGjB,WAAW,cAAuB,IAdhC,WAAW,eAAwB,IAiB9C,kBAAmC,EAAkC,CACnE,GAAI,EAAW,SAAS,QAEtB,MAAO,MAAM,AADI,MAAM,OAAM,IACP,cAGxB,GAAI,CAAC,EACH,GAAI,CACF,MAAO,IAAa,mBAAoB,KAAM,AAAK,mBAAgB,QACnE,CACA,MAAO,MAGX,GAAI,EACF,MAAO,eAAc,GAQvB,GAAM,GAAe,KAAM,AADV,MAAM,OAAM,IACO,OACpC,MAAO,IAAsB,EAAc,GAqB7C,YAA+B,EAAsB,EAAwB,CAC3E,GAAI,CAAC,EACH,MAAO,AAAK,sBAAqB,AAAK,oBAAkB,EAAc,GAGxE,GAAI,EAEF,YAAK,KAAK,EAAQ,GAGX,KAGT,GAAM,GAAS,SAAS,cAAc,UACtC,EAAO,GAAK,EAEZ,GAAI,CACF,EAAO,YAAY,SAAS,eAAe,SAC3C,CACA,EAAO,KAAO,EAEhB,gBAAS,KAAK,YAAY,GACnB,KAlJT,GAEA,GAQM,GACA,GAEA,EAbN,UACA,IACA,EAAsB,SACtB,IACA,IAMA,AAAM,GAAS,OACT,GAAU,MAAO,IAAgB,YAAc,EAAc,GAE7D,EAAoD,KCb1D,cAoCA,OChBA,kBAA6C,EAAS,CACpD,GAAM,GAAU,EAAQ,SAAW,GAGnC,MAAI,GAAQ,QACV,EACE,GACA,EAAQ,QAAQ,oBAAoB,IAAI,KAAK,AAAC,GACrC,EAAC,WAIZ,EAAqB,GAAsB,GAAiB,GAEvD,KAAM,GAGf,kBAA6C,EAAS,CACpD,GAAM,GAAU,EAAQ,SAAW,GAGnC,MAAI,GAAQ,QACV,EACE,GACA,EAAQ,QAAQ,oBAAoB,IAAI,KAAK,AAAC,GACrC,EAAC,WAIZ,EAAqB,GAAsB,GAAiB,GAEvD,KAAM,GAKf,kBAAgC,EAAS,CACvC,GAAI,GACA,EACJ,OAAQ,EAAQ,OAAS,EAAQ,MAAM,iBAChC,KACH,EAAqB,KAAM,GAAY,GAAsB,QAAS,GACtE,UAEG,eAEH,CAAC,EAAoB,GAAc,KAAM,SAAQ,IAAI,CACnD,KAAM,GAAY,GAAwB,QAAS,GACnD,KAAM,GAAY,GAAwB,QAAS,KAKzD,SAAqB,GAAsB,WAAW,mBAC/C,KAAM,IAAuB,EAAoB,GAG1D,YAAgC,EAAoB,EAAY,CAC9D,GAAM,GAA8B,GACpC,MAAI,IACF,GAAQ,WAAa,GAGhB,GAAI,SAAQ,AAAC,GAAY,CAC9B,EAAmB,IACd,EACH,eAAgB,AAAC,GAAU,EAAQ,CAAC,cAO1C,kBAAgC,EAAS,CACvC,GAAI,GAAqB,KAAM,GAAY,GAAmB,QAAS,GAEvE,SAAqB,GAAsB,WAAW,mBAE/C,GAAI,SAAQ,AAAC,GAAY,CAC9B,EAAmB,CACjB,eAAgB,AAAC,GAAU,EAAQ,CAAC,cApG1C,GAMM,IACA,GAEA,EAEA,GACA,GACA,GAEA,GAEF,EACA,EAlBJ,SAIA,KAEA,AAAM,GAAwB,QACxB,GAAwB,QAExB,EAAqB,oDAAoD,KAEzE,GAAuB,GAAG,qBAC1B,GAAyB,GAAG,0BAC5B,GAAyB,GAAG,uBAE5B,GAAoB,kDAAkD,mCCma5E,YAAqC,EAA2B,CAC9D,GAAM,GAAa,EAAU,OACvB,EAAe,GAAI,aAAY,GAC/B,EAAa,GAAI,WAAU,GACjC,OAAS,GAAI,EAAG,EAAI,EAAY,EAAE,EAChC,EAAW,GAAK,EAAU,SAAS,GAErC,MAAO,GAIT,YAAoB,EAAW,CAE7B,MAAO,AADgB,GAAU,SAAW,CAAC,EAAU,eAAe,WAC9C,EAAU,UAAY,OAAO,QAAQ,GA/b/D,GA8BM,IAOA,GAEN,EAvCA,UA8BA,AAAM,GAAmC,CACvC,SAAU,WACV,OAAQ,SACR,QAAS,QACT,WAAY,aAGR,GAAO,IAAM,GAEnB,OAAkC,CAQhC,YAAY,EAAgB,CAC1B,KAAK,MAAQ,EACb,KAAK,aAAe,GAAI,MAAK,MAAM,QACnC,KAAK,iBAAmB,GAAI,MAAK,MAAM,YACvC,KAAK,qBAAuB,GAAI,MAAK,MAAM,gBAG7C,SAAgB,CACd,KAAK,qBAAqB,KAAK,kBAC/B,KAAK,qBAAqB,KAAK,cAC/B,KAAK,qBAAqB,KAAK,sBAE/B,KAAK,iBAAmB,KAExB,KAAK,aAAe,KAEpB,KAAK,MAAQ,KAIf,qBAAqB,EAAc,CACjC,AAAI,GACF,KAAK,MAAM,QAAQ,GASvB,WAAW,EAAiB,EAA6B,GAAiB,CACxE,YAAK,IAAM,GACX,KAAK,YAAY,GAEV,EAAQ,WACX,KAAK,kBAAkB,EAAM,GAC7B,KAAK,YAAY,EAAM,GAK7B,uBAAuB,EAAiB,CAEtC,GAAM,GAAa,IAAI,KAAS,EAAK,YAErC,MAAI,GAAK,SACP,GAAW,QAAU,EAAK,SAErB,EAGT,kBAAkB,EAAuB,EAAyC,CAChF,GAAM,GAAkB,GAAI,MAAK,MAAM,WAEvC,AAAI,EAAQ,UACV,KAAK,qBAAqB,EAAiB,EAAQ,UAGrD,GAAM,GAAa,KAAK,uBAAuB,GAG/C,KAAK,uBAAuB,EAAiB,EAAY,GAEzD,GAAM,GAAY,GAAI,MAAK,MAAM,eAEjC,GAAI,CACF,GAAM,GAAa,KAAK,aAAa,8BACnC,EACA,GACA,GAGF,GAAI,CAAE,GAAa,GACjB,KAAM,IAAI,OAAM,0BAGlB,YAAK,IAAI,iBAAiB,EAAgB;AAAA,eACjC,EAAgB,oCAAoC,WAEtD,GAA4B,UACnC,CACA,KAAK,qBAAqB,GAC1B,KAAK,qBAAqB,IAI9B,YAAY,EAAiB,EAAyC,CACpE,GAAM,GAAY,GAAI,MAAK,MAAM,KAEjC,AAAI,EAAQ,UACV,KAAK,qBAAqB,EAAW,EAAQ,UAG/C,GAAM,GAAa,KAAK,uBAAuB,GAG/C,KAAK,iBAAiB,EAAW,EAAY,GAE7C,GAAM,GAAY,GAAI,MAAK,MAAM,eAEjC,GAAI,CACF,GAAM,GAAa,KAAK,aAAa,wBAAwB,EAAW,GACxE,GAAI,GAAc,EAChB,KAAM,IAAI,OAAM,0BAGlB,YAAK,IAAI,iBAAiB,EAAU;AAAA,eAC3B,EAAU,oCAAoC,WAEhD,GAA4B,UACnC,CACA,KAAK,qBAAqB,GAC1B,KAAK,qBAAqB,IAQ9B,YAAY,EAAkC,CAK5C,GAJI,SAAW,IAEb,KAAK,aAAa,gBAAgB,GAAG,EAAQ,OAE3C,UAAY,GAAS,CACvB,GAAM,GAAc,KAAK,MAAM,EAAQ,QAAU,4BAEjD,KAAK,aAAa,kBAAkB,GAEtC,GAAI,gBAAkB,GACpB,OAAW,KAAa,GAAQ,aAAc,CAC5C,GAAM,GAAO,EAAQ,aAAa,GAC5B,EAAgB,KAAK,MAAM,GACjC,KAAK,aAAa,yBAAyB,EAAe,IAUhE,iBAAiB,EAAiB,EAAY,EAAkC,CAC9E,GAAM,GAAmB,EAAQ,oBAAsB,GAEvD,GAAI,CACF,GAAM,GAAY,KAAK,sBAAsB,GAC7C,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,aAElB,GAAM,GAAc,EAAU,OAAS,EAEvC,OAAS,KAAiB,GAAY,CACpC,GAAM,GAAY,EAAW,GAC7B,EAAgB,GAAiC,IAAkB,EACnE,GAAM,GAAW,KAAK,oBAAoB,EAAW,EAAe,EAAW,GAE/E,AAAI,IAAa,IACf,KAAK,sBAAsB,EAAW,EAAU,CAC9C,KAAM,KACF,EAAiB,IAAkB,YAItC,EAAP,CACA,WAAK,qBAAqB,GACpB,EAGR,MAAO,GAOT,uBACE,EACA,EACA,EACY,CACZ,GAAM,GAAmB,EAAQ,oBAAsB,GAEvD,GAAI,CACF,GAAM,GAAY,KAAK,sBAAsB,GAC7C,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,aAElB,GAAM,GAAc,EAAU,OAAS,EAEvC,OAAS,KAAiB,GAAY,CACpC,GAAM,GAAY,EAAW,GAC7B,EAAgB,GAAiC,IAAkB,EACnE,GAAM,GAAW,KAAK,oBACpB,EACA,EACA,EACA,GAEF,AAAI,IAAa,IACf,KAAK,sBAAsB,EAAiB,EAAU,CACpD,KAAM,KACF,EAAiB,IAAkB,YAItC,EAAP,CACA,WAAK,qBAAqB,GACpB,EAGR,MAAO,GAST,oBACE,EACA,EACA,EACA,EACA,CACA,GAAI,CAAC,YAAY,OAAO,GACtB,MAAO,GAGT,GAAM,GAAO,KAAK,uBAAuB,GAEnC,EAAO,EAAU,OAAS,EAEhC,GAAI,IAAS,UAAW,CAEtB,GAAM,GAAW,EAAU,OAAS,EACpC,YAAK,IAAI,oBAAoB,WAAuB,KAGpD,KAAK,iBAAiB,eAAe,EAAM,EAAU,GAC9C,GAGT,KAAK,IAAI,oBAAoB,WAAuB,KAEpD,GAAM,GAAU,KAAK,iBACf,CAAC,UAAU,EAEjB,OAAQ,EAAU,iBACX,WACH,MAAO,GAAQ,iBAAiB,EAAM,EAAM,EAAa,EAAM,GAAI,WAAU,QAE1E,YACH,MAAO,GAAQ,kBAAkB,EAAM,EAAM,EAAa,EAAM,GAAI,YAAW,QAE5E,YACH,MAAO,GAAQ,kBAAkB,EAAM,EAAM,EAAa,EAAM,GAAI,YAAW,QAC5E,gBACA,mBACH,MAAO,GAAQ,kBAAkB,EAAM,EAAM,EAAa,EAAM,GAAI,YAAW,QAE5E,aACH,MAAO,GAAQ,mBAAmB,EAAM,EAAM,EAAa,EAAM,GAAI,aAAY,QAE9E,aACH,MAAO,GAAQ,mBAAmB,EAAM,EAAM,EAAa,EAAM,GAAI,aAAY,QAE9E,sBAEH,MAAO,GAAQ,kBAAkB,EAAM,EAAM,EAAa,EAAM,GAAI,cAAa,KASvF,uBAAuB,EAAiE,CACtF,OAAQ,EAAc,mBACf,UACH,MAAO,cACJ,eACA,gBACA,WACH,MAAO,MAAK,MAAM,aACf,aACA,UACH,MAAO,MAAK,MAAM,WACf,YACA,SACH,MAAO,MAAK,MAAM,UACf,eACA,YACH,MAAO,MAAK,MAAM,kBAElB,MAAO,MAAK,MAAM,SAIxB,sBAAsB,EAAY,CAChC,OAAW,KAAiB,GAAY,CACtC,GAAM,GAAY,EAAW,GAE7B,GAAI,AADc,KAAK,uBAAuB,KAC5B,KAAK,MAAM,SAC3B,MAAO,GAGX,MAAO,MAQT,qBAAqB,EAA2B,EAAmC,CACjF,GAAM,GAAgB,GAAI,MAAK,MAAM,SACrC,KAAK,uBAAuB,EAAe,GAC3C,KAAK,iBAAiB,YAAY,EAAe,GASnD,sBACE,EACA,EACA,EACA,CAGA,GAAM,GAAyB,GAAI,MAAK,MAAM,SAC9C,KAAK,uBAAuB,EAAwB,GAGpD,KAAK,iBAAiB,wBACpB,EACA,EACA,GASJ,uBACE,EACA,EACA,CACA,OAAW,CAAC,EAAK,IAAU,IAAW,GACpC,OAAQ,MAAO,QACR,SACH,AAAI,KAAK,MAAM,KAAW,EACxB,KAAK,qBAAqB,YAAY,EAAe,EAAK,GAE1D,KAAK,qBAAqB,eAAe,EAAe,EAAK,GAE/D,UACG,SACH,AAAI,YAAiB,aACnB,KAAK,qBAAqB,iBAAiB,EAAe,EAAK,EAAO,EAAM,QAE9E,UACG,iBAEH,KAAK,qBAAqB,eAAe,EAAe,EAAK,QC3XvE,kBAAsB,EAAiB,EAA8B,GAA0B,CAE7F,GAAM,CAAC,SAAS,KAAM,IAAuB,GACvC,EAAe,GAAI,GAAa,GAEtC,GAAI,CACF,MAAO,GAAa,WAAW,EAAM,EAAQ,cAC7C,CACA,EAAa,WAnDjB,GAiBM,IAcO,GA/Bb,UAGA,KACA,IACA,IAYA,AAAM,GAA+B,CACnC,WAAY,GACZ,mBAAoB,QAYT,GAA8D,CACzE,KAAM,QACN,GAAI,QACJ,OAAQ,QACR,QAAS,EACT,WAAY,CAAC,OACb,UACA,QAAS,CACP,MAAO,OCvCX,uIA+CA,kBAAqB,EAA0B,EAAkD,CAC/F,GAAM,CAAC,SAAS,KAAM,IAAuB,GACvC,EAAc,GAAI,GAAY,GACpC,GAAI,CACF,MAAO,GAAY,UAAU,EAAa,GAAS,cACnD,CACA,EAAY,WArDhB,GAsBa,IAoBA,GAgBA,GA1Db,UAIA,IACA,IACA,IACA,IASA,KAMO,AAAM,GAAoB,CAC/B,GAAI,eACJ,KAAM,mCACN,OAAQ,QACR,QAAS,EACT,OAAQ,GACR,QAAS,CACP,MAAO,GACP,OAAQ,OAYC,GAAsE,IAC9E,EACH,UAcK,AAAM,GAA0C,KC1DvD,mBACA,GAAM,IAAgB,UACtB,WAAW,QAAU,WAAW,SAAW,GAC3C,GAAO,QAAU,OAAO,OAAO,WAAW,QAAS",
  "names": []
}
