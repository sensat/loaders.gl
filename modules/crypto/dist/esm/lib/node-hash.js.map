{"version":3,"file":"node-hash.js","names":["Hash","createHash","NodeHash","constructor","options","_this$options","_this$options$crypto","_defineProperty","crypto","algorithm","Error","name","hash","input","_this$options2","_this$options2$crypto","_this$options2$crypto2","preload","toLowerCase","inputArray","Uint8Array","update","digest","hashBatches","asyncIterator","_this$options3","_this$options3$crypto","_this$options3$crypto2","_this$options4","_this$options4$crypto","_this$options4$crypto2","chunk","onEnd","call"],"sources":["../../../src/lib/node-hash.ts"],"sourcesContent":["// This dependency is too big, application must provide it\nimport {Hash} from './hash';\nimport {createHash} from 'crypto'; // Node.js builtin\n\ntype CryptoHashOptions = {\n  crypto: {\n    algorithm: string;\n    onEnd?: (result: {hash: string}) => any;\n  };\n};\n\n/**\n * Calculates Cryptographic Hash using Node.js crypto library\n * @deprecated Warning, experimental class\n */\nexport class NodeHash extends Hash {\n  readonly name = 'crypto-node';\n\n  options: CryptoHashOptions;\n  // @ts-ignore\n  private _algorithm;\n  // @ts-ignore\n  private _hash;\n\n  constructor(options: CryptoHashOptions) {\n    super();\n    this.options = options;\n    if (!this.options?.crypto?.algorithm) {\n      throw new Error(this.name);\n    }\n  }\n\n  /**\n   * Atomic hash calculation\n   * @returns base64 encoded hash\n   */\n  async hash(input: ArrayBuffer): Promise<string> {\n    await this.preload();\n    const hash = createHash(this.options?.crypto?.algorithm?.toLowerCase());\n    const inputArray = new Uint8Array(input);\n    return hash.update(inputArray).digest('base64');\n  }\n\n  async *hashBatches(\n    asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n  ): AsyncIterable<ArrayBuffer> {\n    await this.preload();\n    const hash = createHash(this.options?.crypto?.algorithm?.toLowerCase());\n    for await (const chunk of asyncIterator) {\n      // https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer\n      const inputArray = new Uint8Array(chunk);\n      hash.update(inputArray);\n      yield chunk;\n    }\n    this.options?.crypto?.onEnd?.({hash: hash.digest('base64')});\n  }\n}\n"],"mappings":";AACA,SAAQA,IAAI,QAAO,QAAQ;AAC3B,SAAQC,UAAU,QAAO,QAAQ;AAajC,OAAO,MAAMC,QAAQ,SAASF,IAAI,CAAC;EASjCG,WAAWA,CAACC,OAA0B,EAAE;IAAA,IAAAC,aAAA,EAAAC,oBAAA;IACtC,KAAK,CAAC,CAAC;IAACC,eAAA,eATM,aAAa;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAU3B,IAAI,CAACH,OAAO,GAAGA,OAAO;IACtB,IAAI,GAAAC,aAAA,GAAC,IAAI,CAACD,OAAO,cAAAC,aAAA,gBAAAC,oBAAA,GAAZD,aAAA,CAAcG,MAAM,cAAAF,oBAAA,eAApBA,oBAAA,CAAsBG,SAAS,GAAE;MACpC,MAAM,IAAIC,KAAK,CAAC,IAAI,CAACC,IAAI,CAAC;IAC5B;EACF;EAMA,MAAMC,IAAIA,CAACC,KAAkB,EAAmB;IAAA,IAAAC,cAAA,EAAAC,qBAAA,EAAAC,sBAAA;IAC9C,MAAM,IAAI,CAACC,OAAO,CAAC,CAAC;IACpB,MAAML,IAAI,GAAGX,UAAU,EAAAa,cAAA,GAAC,IAAI,CAACV,OAAO,cAAAU,cAAA,wBAAAC,qBAAA,GAAZD,cAAA,CAAcN,MAAM,cAAAO,qBAAA,wBAAAC,sBAAA,GAApBD,qBAAA,CAAsBN,SAAS,cAAAO,sBAAA,uBAA/BA,sBAAA,CAAiCE,WAAW,CAAC,CAAC,CAAC;IACvE,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAACP,KAAK,CAAC;IACxC,OAAOD,IAAI,CAACS,MAAM,CAACF,UAAU,CAAC,CAACG,MAAM,CAAC,QAAQ,CAAC;EACjD;EAEA,OAAOC,WAAWA,CAChBC,aAAiE,EACrC;IAAA,IAAAC,cAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,cAAA,EAAAC,qBAAA,EAAAC,sBAAA;IAC5B,MAAM,IAAI,CAACb,OAAO,CAAC,CAAC;IACpB,MAAML,IAAI,GAAGX,UAAU,EAAAwB,cAAA,GAAC,IAAI,CAACrB,OAAO,cAAAqB,cAAA,wBAAAC,qBAAA,GAAZD,cAAA,CAAcjB,MAAM,cAAAkB,qBAAA,wBAAAC,sBAAA,GAApBD,qBAAA,CAAsBjB,SAAS,cAAAkB,sBAAA,uBAA/BA,sBAAA,CAAiCT,WAAW,CAAC,CAAC,CAAC;IACvE,WAAW,MAAMa,KAAK,IAAIP,aAAa,EAAE;MAEvC,MAAML,UAAU,GAAG,IAAIC,UAAU,CAACW,KAAK,CAAC;MACxCnB,IAAI,CAACS,MAAM,CAACF,UAAU,CAAC;MACvB,MAAMY,KAAK;IACb;IACA,CAAAH,cAAA,OAAI,CAACxB,OAAO,cAAAwB,cAAA,wBAAAC,qBAAA,GAAZD,cAAA,CAAcpB,MAAM,cAAAqB,qBAAA,wBAAAC,sBAAA,GAApBD,qBAAA,CAAsBG,KAAK,cAAAF,sBAAA,uBAA3BA,sBAAA,CAAAG,IAAA,CAAAJ,qBAAA,EAA8B;MAACjB,IAAI,EAAEA,IAAI,CAACU,MAAM,CAAC,QAAQ;IAAC,CAAC,CAAC;EAC9D;AACF"}