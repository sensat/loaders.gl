{"version":3,"file":"shred.js","names":["ParquetRowGroup","Types","shredBuffer","schema","columnData","field","fieldList","key","dlevels","rlevels","values","pageHeaders","count","rowCount","shredRecord","record","rowGroup","data","shredRecordFields","fields","Array","prototype","push","apply","rLevel","dLevel","name","undefined","constructor","length","Boolean","repetitionType","Error","concat","isNested","i","rlvl","rLevelMax","dLevelMax","toPrimitive","originalType","primitiveType","materializeRows","rows","materializeColumnAsRows","findField","branch","findFieldBranch","rLevels","fill","vIndex","rIndex","step","ix","value","fromPrimitive","materializeColumns","columns","materializeColumnAsColumnarArray","columnName","column"],"sources":["../../../../src/parquetjs/schema/shred.ts"],"sourcesContent":["// Forked from https://github.com/kbajalc/parquets under MIT license (Copyright (c) 2017 ironSource Ltd.)\n\nimport {ArrayType} from '@loaders.gl/schema';\nimport {ParquetRowGroup, ParquetColumnChunk, ParquetField, ParquetRow} from './declare';\nimport {ParquetSchema} from './schema';\nimport * as Types from './types';\n\nexport {ParquetRowGroup};\n\nexport function shredBuffer(schema: ParquetSchema): ParquetRowGroup {\n  const columnData: Record<string, ParquetColumnChunk> = {};\n  for (const field of schema.fieldList) {\n    columnData[field.key] = {\n      dlevels: [],\n      rlevels: [],\n      values: [],\n      pageHeaders: [],\n      count: 0\n    };\n  }\n  return {rowCount: 0, columnData};\n}\n\n/**\n * 'Shred' a record into a list of <value, repetition_level, definition_level>\n * tuples per column using the Google Dremel Algorithm..\n *\n * The rowGroup argument must point to an object into which the shredded record\n * will be returned. You may re-use the rowGroup for repeated calls to this function\n * to append to an existing rowGroup, as long as the schema is unchanged.\n *\n * The format in which the shredded records will be stored in the rowGroup is as\n * follows:\n *\n *   rowGroup = {\n *     columnData: [\n *       'my_col': {\n *          dlevels: [d1, d2, .. dN],\n *          rlevels: [r1, r2, .. rN],\n *          values: [v1, v2, .. vN],\n *        }, ...\n *      ],\n *      rowCount: X,\n *   }\n */\nexport function shredRecord(\n  schema: ParquetSchema,\n  record: ParquetRow,\n  rowGroup: ParquetRowGroup\n): void {\n  /* shred the record, this may raise an exception */\n  const data = shredBuffer(schema).columnData;\n\n  shredRecordFields(schema.fields, record, data, 0, 0);\n\n  /* if no error during shredding, add the shredded record to the rowGroup */\n  if (rowGroup.rowCount === 0) {\n    rowGroup.rowCount = 1;\n    rowGroup.columnData = data;\n    return;\n  }\n  rowGroup.rowCount += 1;\n  for (const field of schema.fieldList) {\n    Array.prototype.push.apply(rowGroup.columnData[field.key].rlevels, data[field.key].rlevels);\n    Array.prototype.push.apply(rowGroup.columnData[field.key].dlevels, data[field.key].dlevels);\n    Array.prototype.push.apply(rowGroup.columnData[field.key].values, data[field.key].values);\n    rowGroup.columnData[field.key].count += data[field.key].count;\n  }\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction shredRecordFields(\n  fields: Record<string, ParquetField>,\n  record: ParquetRow,\n  data: Record<string, ParquetColumnChunk>,\n  rLevel: number,\n  dLevel: number\n) {\n  for (const name in fields) {\n    const field = fields[name];\n\n    // fetch values\n    let values: any[] = [];\n    if (\n      record &&\n      field.name in record &&\n      record[field.name] !== undefined &&\n      record[field.name] !== null\n    ) {\n      if (record[field.name].constructor === Array) {\n        values = record[field.name];\n      } else {\n        values.push(record[field.name]);\n      }\n    }\n    // check values\n    if (values.length === 0 && Boolean(record) && field.repetitionType === 'REQUIRED') {\n      throw new Error(`missing required field: ${field.name}`);\n    }\n    if (values.length > 1 && field.repetitionType !== 'REPEATED') {\n      throw new Error(`too many values for field: ${field.name}`);\n    }\n\n    // push null\n    if (values.length === 0) {\n      if (field.isNested) {\n        shredRecordFields(field.fields!, null!, data, rLevel, dLevel);\n      } else {\n        data[field.key].count += 1;\n        data[field.key].rlevels.push(rLevel);\n        data[field.key].dlevels.push(dLevel);\n      }\n      continue; // eslint-disable-line no-continue\n    }\n\n    // push values\n    for (let i = 0; i < values.length; i++) {\n      const rlvl = i === 0 ? rLevel : field.rLevelMax;\n      if (field.isNested) {\n        shredRecordFields(field.fields!, values[i], data, rlvl, field.dLevelMax);\n      } else {\n        data[field.key].count += 1;\n        data[field.key].rlevels.push(rlvl);\n        data[field.key].dlevels.push(field.dLevelMax);\n        data[field.key].values.push(\n          Types.toPrimitive((field.originalType || field.primitiveType)!, values[i])\n        );\n      }\n    }\n  }\n}\n\n/**\n * 'Materialize' a list of <value, repetition_level, definition_level>\n * tuples back to nested records (objects/arrays) using the Google Dremel\n * Algorithm..\n *\n * The rowGroup argument must point to an object with the following structure (i.e.\n * the same structure that is returned by shredRecords):\n *\n *   rowGroup = {\n *     columnData: [\n *       'my_col': {\n *          dlevels: [d1, d2, .. dN],\n *          rlevels: [r1, r2, .. rN],\n *          values: [v1, v2, .. vN],\n *        }, ...\n *      ],\n *      rowCount: X,\n *   }\n */\nexport function materializeRows(schema: ParquetSchema, rowGroup: ParquetRowGroup): ParquetRow[] {\n  const rows: ParquetRow[] = [];\n  // rows = new Array(rowGroup.rowCount).fill({})'\n  for (let i = 0; i < rowGroup.rowCount; i++) {\n    rows.push({});\n  }\n  for (const key in rowGroup.columnData) {\n    const columnData = rowGroup.columnData[key];\n    if (columnData.count) {\n      materializeColumnAsRows(schema, columnData, key, rows);\n    }\n  }\n  return rows;\n}\n\n/** Populate record fields for one column */\n// eslint-disable-next-line max-statements, complexity\nfunction materializeColumnAsRows(\n  schema: ParquetSchema,\n  columnData: ParquetColumnChunk,\n  key: string,\n  rows: ParquetRow[]\n): void {\n  const field = schema.findField(key);\n  const branch = schema.findFieldBranch(key);\n\n  // tslint:disable-next-line:prefer-array-literal\n  const rLevels: number[] = new Array(field.rLevelMax + 1).fill(0);\n  let vIndex = 0;\n  for (let i = 0; i < columnData.count; i++) {\n    const dLevel = columnData.dlevels[i];\n    const rLevel = columnData.rlevels[i];\n    rLevels[rLevel]++;\n    rLevels.fill(0, rLevel + 1);\n\n    let rIndex = 0;\n    let record = rows[rLevels[rIndex++] - 1];\n\n    // Internal nodes - Build a nested row object\n    for (const step of branch) {\n      if (step === field || dLevel < step.dLevelMax) {\n        break;\n      }\n\n      switch (step.repetitionType) {\n        case 'REPEATED':\n          if (!(step.name in record)) {\n            // eslint-disable max-depth\n            record[step.name] = [];\n          }\n          const ix = rLevels[rIndex++];\n          while (record[step.name].length <= ix) {\n            // eslint-disable max-depth\n            record[step.name].push({});\n          }\n          record = record[step.name][ix];\n          break;\n\n        default:\n          record[step.name] = record[step.name] || {};\n          record = record[step.name];\n      }\n    }\n\n    // Leaf node - Add the value\n    if (dLevel === field.dLevelMax) {\n      const value = Types.fromPrimitive(\n        // @ts-ignore\n        field.originalType || field.primitiveType,\n        columnData.values[vIndex],\n        field\n      );\n      vIndex++;\n\n      switch (field.repetitionType) {\n        case 'REPEATED':\n          if (!(field.name in record)) {\n            // eslint-disable max-depth\n            record[field.name] = [];\n          }\n          const ix = rLevels[rIndex];\n          while (record[field.name].length <= ix) {\n            // eslint-disable max-depth\n            record[field.name].push(null);\n          }\n          record[field.name][ix] = value;\n          break;\n\n        default:\n          record[field.name] = value;\n      }\n    }\n  }\n}\n\n// Columnar export\n\n/**\n * 'Materialize' a list of <value, repetition_level, definition_level>\n * tuples back to nested records (objects/arrays) using the Google Dremel\n * Algorithm..\n *\n * The rowGroup argument must point to an object with the following structure (i.e.\n * the same structure that is returned by shredRecords):\n *\n *   rowGroup = {\n *     columnData: [\n *       'my_col': {\n *          dlevels: [d1, d2, .. dN],\n *          rlevels: [r1, r2, .. rN],\n *          values: [v1, v2, .. vN],\n *        }, ...\n *      ],\n *      rowCount: X,\n *   }\n */\nexport function materializeColumns(\n  schema: ParquetSchema,\n  rowGroup: ParquetRowGroup\n): Record<string, ArrayType> {\n  const columns: Record<string, ArrayType> = {};\n  for (const key in rowGroup.columnData) {\n    const columnData = rowGroup.columnData[key];\n    if (columnData.count) {\n      materializeColumnAsColumnarArray(schema, columnData, rowGroup.rowCount, key, columns);\n    }\n  }\n  return columns;\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction materializeColumnAsColumnarArray(\n  schema: ParquetSchema,\n  columnData: ParquetColumnChunk,\n  rowCount: number,\n  key: string,\n  columns: Record<string, ArrayType<any>>\n) {\n  if (columnData.count <= 0) {\n    return;\n  }\n\n  const field = schema.findField(key);\n  const branch = schema.findFieldBranch(key);\n\n  const columnName = branch[0].name;\n\n  let column: ArrayType | undefined;\n  const {values} = columnData;\n  if (values.length === rowCount && branch[0].primitiveType) {\n    // if (branch[0].repetitionType === `REQUIRED`) {\n    //   switch (branch[0].primitiveType) {\n    //     case 'INT32': return values instanceof Int32Array ? values : new Int32Array(values);\n    //   }\n    // }\n    column = values;\n  }\n\n  if (column) {\n    columns[columnName] = column;\n    return;\n  }\n\n  column = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    column[i] = {};\n  }\n  columns[columnName] = column;\n\n  // tslint:disable-next-line:prefer-array-literal\n  const rLevels: number[] = new Array(field.rLevelMax + 1).fill(0);\n  let vIndex = 0;\n  for (let i = 0; i < columnData.count; i++) {\n    const dLevel = columnData.dlevels[i];\n    const rLevel = columnData.rlevels[i];\n    rLevels[rLevel]++;\n    rLevels.fill(0, rLevel + 1);\n\n    let rIndex = 0;\n    let record = column[rLevels[rIndex++] - 1] as ParquetRow;\n\n    // Internal nodes - Build a nested row object\n    for (const step of branch) {\n      if (step === field || dLevel < step.dLevelMax) {\n        break;\n      }\n\n      switch (step.repetitionType) {\n        case 'REPEATED':\n          if (!(step.name in record)) {\n            // eslint-disable max-depth\n            record[step.name] = [];\n          }\n          const ix = rLevels[rIndex++];\n          while (record[step.name].length <= ix) {\n            // eslint-disable max-depth\n            record[step.name].push({});\n          }\n          record = record[step.name][ix];\n          break;\n\n        default:\n          record[step.name] = record[step.name] || {};\n          record = record[step.name];\n      }\n    }\n\n    // Leaf node - Add the value\n    if (dLevel === field.dLevelMax) {\n      const value = Types.fromPrimitive(\n        // @ts-ignore\n        field.originalType || field.primitiveType,\n        columnData.values[vIndex],\n        field\n      );\n      vIndex++;\n\n      switch (field.repetitionType) {\n        case 'REPEATED':\n          if (!(field.name in record)) {\n            // eslint-disable max-depth\n            record[field.name] = [];\n          }\n          const ix = rLevels[rIndex];\n          while (record[field.name].length <= ix) {\n            // eslint-disable max-depth\n            record[field.name].push(null);\n          }\n          record[field.name][ix] = value;\n          break;\n\n        default:\n          record[field.name] = value;\n      }\n    }\n  }\n\n  // Remove one level of nesting\n  for (let i = 0; i < rowCount; ++i) {\n    if (columnName in (column[i] as object)) {\n      column[i] = (column[i] as object)[columnName];\n    }\n  }\n}\n"],"mappings":"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"}