{"version":3,"file":"convert-schema-to-parquet.js","names":["PARQUET_TYPE_MAPPING","BOOLEAN","INT32","INT64","INT96","FLOAT","DOUBLE","BYTE_ARRAY","FIXED_LEN_BYTE_ARRAY","UTF8","DATE","TIME_MILLIS","TIME_MICROS","TIMESTAMP_MILLIS","TIMESTAMP_MICROS","UINT_8","UINT_16","UINT_32","UINT_64","INT_8","INT_16","INT_32","INT_64","JSON","BSON","INTERVAL","DECIMAL_INT32","DECIMAL_INT64","DECIMAL_BYTE_ARRAY","DECIMAL_FIXED_LEN_BYTE_ARRAY","exports","convertToParquetSchema","schema","fields","metadata"],"sources":["../../../../src/lib/arrow/convert-schema-to-parquet.ts"],"sourcesContent":["// loaders.gl, MIT license\n\n// import type {ParquetSchema} from '../../parquetjs/schema/schema';\nimport type {\n  // FieldDefinition, ParquetField,\n  ParquetType\n} from '../../parquetjs/schema/declare';\n\nimport {\n  Schema,\n  // Struct,\n  // Field,\n  DataType\n} from '@loaders.gl/schema';\n\nexport const PARQUET_TYPE_MAPPING: {[type in ParquetType]: DataType} = {\n  BOOLEAN: 'bool',\n  INT32: 'int32',\n  INT64: 'float64',\n  INT96: 'float64',\n  FLOAT: 'float32',\n  DOUBLE: 'float64',\n  BYTE_ARRAY: 'binary',\n  FIXED_LEN_BYTE_ARRAY: 'binary',\n  UTF8: 'utf8',\n  DATE: 'int32',\n  TIME_MILLIS: 'int64',\n  TIME_MICROS: 'int64',\n  TIMESTAMP_MILLIS: 'int64',\n  TIMESTAMP_MICROS: 'int64',\n  UINT_8: 'int32',\n  UINT_16: 'uint16',\n  UINT_32: 'uint32',\n  UINT_64: 'uint64',\n  INT_8: 'int8',\n  INT_16: 'int16',\n  INT_32: 'int32',\n  INT_64: 'int64',\n  JSON: 'binary',\n  BSON: 'binary',\n  // TODO check interval type\n  INTERVAL: 'binary',\n  DECIMAL_INT32: 'float32',\n  DECIMAL_INT64: 'float64',\n  DECIMAL_BYTE_ARRAY: 'float64',\n  DECIMAL_FIXED_LEN_BYTE_ARRAY: 'float64'\n};\n\nexport function convertToParquetSchema(schema: Schema): Schema {\n  const fields = []; // getFields(schema.fields);\n\n  // TODO add metadata if needed.\n  return {fields, metadata: {}};\n}\n\n// function getFields(schema: Field[]): Definition[] {\n//   const fields: Field[] = [];\n\n//   for (const name in schema) {\n//     const field = schema[name];\n\n//     // @ts-ignore\n//     const children = field.children as DataType[];\n//     if (children) {\n//       const childField = getFields(field.fields);\n//       const nestedField = new Field(name, new Struct(childField), field.optional);\n//       fields.push(nestedField);\n//     } else {\n//       const FieldType = PARQUET_TYPE_MAPPING[field.type];\n//       const metadata = getFieldMetadata(field);\n//       const arrowField = new Field(name, new FieldType(), field.optional, metadata);\n//       fields.push(arrowField);\n//     }\n//   }\n\n//   return fields;\n// }\n\n// function getFieldMetadata(field: ParquetField): Map<string, string> {\n//   const metadata = new Map();\n\n//   for (const key in field) {\n//     if (key !== 'name') {\n//       const value = typeof field[key] !== 'string' ? JSON.stringify(field[key]) : field[key];\n//       metadata.set(key, value);\n//     }\n//   }\n\n//   return metadata;\n// }\n"],"mappings":";;;;;;;AAeO,IAAMA,oBAAuD,GAAG;EACrEC,OAAO,EAAE,MAAM;EACfC,KAAK,EAAE,OAAO;EACdC,KAAK,EAAE,SAAS;EAChBC,KAAK,EAAE,SAAS;EAChBC,KAAK,EAAE,SAAS;EAChBC,MAAM,EAAE,SAAS;EACjBC,UAAU,EAAE,QAAQ;EACpBC,oBAAoB,EAAE,QAAQ;EAC9BC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,OAAO;EACbC,WAAW,EAAE,OAAO;EACpBC,WAAW,EAAE,OAAO;EACpBC,gBAAgB,EAAE,OAAO;EACzBC,gBAAgB,EAAE,OAAO;EACzBC,MAAM,EAAE,OAAO;EACfC,OAAO,EAAE,QAAQ;EACjBC,OAAO,EAAE,QAAQ;EACjBC,OAAO,EAAE,QAAQ;EACjBC,KAAK,EAAE,MAAM;EACbC,MAAM,EAAE,OAAO;EACfC,MAAM,EAAE,OAAO;EACfC,MAAM,EAAE,OAAO;EACfC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EAEdC,QAAQ,EAAE,QAAQ;EAClBC,aAAa,EAAE,SAAS;EACxBC,aAAa,EAAE,SAAS;EACxBC,kBAAkB,EAAE,SAAS;EAC7BC,4BAA4B,EAAE;AAChC,CAAC;AAACC,OAAA,CAAA9B,oBAAA,GAAAA,oBAAA;AAEK,SAAS+B,sBAAsBA,CAACC,MAAc,EAAU;EAC7D,IAAMC,MAAM,GAAG,EAAE;EAGjB,OAAO;IAACA,MAAM,EAANA,MAAM;IAAEC,QAAQ,EAAE,CAAC;EAAC,CAAC;AAC/B"}