{"version":3,"file":"netcdf-reader.js","names":["IOBuffer","readNetCDFHeader","readRecord","readNonRecord","NetCDFReader","constructor","data","_defineProperty","buffer","setBigEndian","magic","readChars","Error","concat","version","readByte","header","recordDimension","dimensions","attributes","variables","attributeExists","attributeName","attribute","find","val","name","undefined","getAttribute","value","dataVariableExists","variableName","variable","getDataVariableAsString","getDataVariable","join","seek","offset","record","toString","result","push","dimension","padEnd","size","JSON","parse","stringify","length","substring","isNaN"],"sources":["../../../src/netcdfjs/netcdf-reader.ts"],"sourcesContent":["import {IOBuffer} from '../iobuffer/iobuffer';\nimport type {\n  NetCDFHeader,\n  NetCDFDimension,\n  NetCDFRecordDimension,\n  NetCDFAttribute,\n  NetCDFVariable\n} from './netcdf-types';\nimport {readNetCDFHeader} from './read-header';\nimport {readRecord, readNonRecord} from './read-data';\n\n/**\n * Reads a NetCDF v3.x file\n * https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html\n * @param {ArrayBuffer} data - ArrayBuffer or any Typed Array (including Node.js' Buffer from v4) with the data\n * @constructor\n */\nexport class NetCDFReader {\n  public header: NetCDFHeader;\n  public buffer: IOBuffer;\n\n  constructor(data) {\n    const buffer = new IOBuffer(data);\n    buffer.setBigEndian();\n\n    // Validate that it's a NetCDF file\n    const magic = buffer.readChars(3);\n    if (magic !== 'CDF') {\n      throw new Error(`NetCDF: file should start with 'CDF', found ${magic}`);\n    }\n\n    // Check the NetCDF format\n    const version = buffer.readByte();\n    if (version > 2) {\n      throw new Error(`NetCDF: unsupported version ${version}`);\n    }\n\n    // Read the header\n    this.header = readNetCDFHeader(buffer, version);\n    this.buffer = buffer;\n  }\n\n  /**\n   * @return {string} - Version for the NetCDF format\n   */\n  get version() {\n    if (this.header.version === 1) {\n      return 'classic format';\n    }\n    return '64-bit offset format';\n  }\n\n  /**\n   * Get metadata for the record dimension\n   */\n  get recordDimension(): NetCDFRecordDimension {\n    return this.header.recordDimension;\n  }\n\n  /**\n   * Get list of dimensions (each with `name` and `size`)\n   */\n  get dimensions(): NetCDFDimension[] {\n    return this.header.dimensions;\n  }\n\n  /**\n   * Get list of global attributes with:\n   *  * `name`: String with the name of the attribute\n   *  * `type`: String with the type of the attribute\n   *  * `value`: A number or string with the value of the attribute\n   */\n  get attributes(): NetCDFAttribute[] {\n    return this.header.attributes;\n  }\n\n  /**\n   * Get list of variables\n   */\n  get variables(): NetCDFVariable[] {\n    return this.header.variables;\n  }\n\n  /**\n   * Check if an attribute exists\n   * @param attributeName - Name of the attribute to find\n   * @return\n   */\n  attributeExists(attributeName: string): boolean {\n    const attribute = this.attributes.find((val) => val.name === attributeName);\n    return attribute !== undefined;\n  }\n\n  /**\n   * Returns the value of an attribute\n   * @param attributeName\n   * @return Value of the attributeName or null\n   */\n  getAttribute(attributeName: string): string | null {\n    const attribute = this.attributes.find((val) => val.name === attributeName);\n    if (attribute) return attribute.value;\n    return null;\n  }\n\n  /**\n   * Check if a dataVariable exists\n   * @param variableName - Name of the variable to find\n   * @return\n   */\n  dataVariableExists(variableName: string): boolean {\n    const variable = this.header.variables.find(function (val) {\n      return val.name === variableName;\n    });\n    return variable !== undefined;\n  }\n\n  /**\n   * Returns the value of a variable as a string\n   * @param variableName\n   * @return Value of the variable as a string or null\n   */\n  getDataVariableAsString(variableName: string): string | null {\n    const variable = this.getDataVariable(variableName);\n    if (variable) return variable.join('');\n    return null;\n  }\n\n  /**\n   * Retrieves the data for a given variable\n   * @param variableName - Name of the variable to search or variable object\n   * @return List with the variable values\n   */\n  getDataVariable(variableName: string | object): any[] {\n    let variable;\n    if (typeof variableName === 'string') {\n      // search the variable\n      variable = this.header.variables.find(function (val) {\n        return val.name === variableName;\n      });\n    } else {\n      variable = variableName;\n    }\n\n    // throws if variable not found\n    if (variable === undefined) {\n      throw new Error(`NetCDF: variable not found: ${variableName}`);\n    }\n\n    // go to the offset position\n    this.buffer.seek(variable.offset);\n\n    if (variable.record) {\n      // record variable case\n      return readRecord(this.buffer, variable, this.header.recordDimension);\n    }\n    // non-record variable case\n    return readNonRecord(this.buffer, variable);\n  }\n\n  toString(): string {\n    const result: string[] = [];\n\n    result.push('DIMENSIONS');\n    for (const dimension of this.dimensions) {\n      result.push(`  ${dimension.name.padEnd(30)} = size: ${dimension.size}`);\n    }\n\n    result.push('');\n    result.push('GLOBAL ATTRIBUTES');\n    for (const attribute of this.attributes) {\n      result.push(`  ${attribute.name.padEnd(30)} = ${attribute.value}`);\n    }\n\n    const variables = JSON.parse(JSON.stringify(this.variables));\n    result.push('');\n    result.push('VARIABLES:');\n    for (const variable of variables) {\n      variable.value = this.getDataVariable(variable);\n      let stringify = JSON.stringify(variable.value);\n      if (stringify.length > 50) stringify = stringify.substring(0, 50);\n      if (!isNaN(variable.value.length)) {\n        stringify += ` (length: ${variable.value.length})`;\n      }\n      result.push(`  ${variable.name.padEnd(30)} = ${stringify}`);\n    }\n    return result.join('\\n');\n  }\n}\n"],"mappings":"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"}