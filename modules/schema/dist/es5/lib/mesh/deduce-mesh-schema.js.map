{"version":3,"file":"deduce-mesh-schema.js","names":["_dataType","require","deduceMeshSchema","attributes","metadata","arguments","length","undefined","fields","deduceMeshFields","deduceMeshField","name","attribute","optionalMetadata","type","getDataTypeFromTypedArray","value","makeMeshAttributeMetadata","listSize","size","children","nullable","attributeName","push","result","byteOffset","toString","byteStride","normalized"],"sources":["../../../../src/lib/mesh/deduce-mesh-schema.ts"],"sourcesContent":["// loaders.gl, MIT license\n\nimport {MeshAttribute, MeshAttributes} from '../../types/category-mesh';\nimport {Schema, Field} from '../../types/schema';\nimport {getDataTypeFromTypedArray} from '../table/simple-table/data-type';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata: Record<string, string> = {}\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return {fields, metadata};\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  name: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Record<string, string>\n): Field {\n  const type = getDataTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  return {\n    name,\n    type: {type: 'fixed-size-list', listSize: attribute.size, children: [{name: 'value', type}]},\n    nullable: false,\n    metadata\n  };\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Record<string, string> {\n  const result: Record<string, string> = {};\n  if ('byteOffset' in attribute) {\n    result.byteOffset = attribute.byteOffset!.toString(10);\n  }\n  if ('byteStride' in attribute) {\n    result.byteStride = attribute.byteStride!.toString(10);\n  }\n  if ('normalized' in attribute) {\n    result.normalized = attribute.normalized!.toString();\n  }\n  return result;\n}\n"],"mappings":";;;;;;;;AAIA,IAAAA,SAAA,GAAAC,OAAA;AAQO,SAASC,gBAAgBA,CAC9BC,UAA0B,EAElB;EAAA,IADRC,QAAgC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAErC,IAAMG,MAAM,GAAGC,gBAAgB,CAACN,UAAU,CAAC;EAC3C,OAAO;IAACK,MAAM,EAANA,MAAM;IAAEJ,QAAQ,EAARA;EAAQ,CAAC;AAC3B;AASO,SAASM,eAAeA,CAC7BC,IAAY,EACZC,SAAwB,EACxBC,gBAAyC,EAClC;EACP,IAAMC,IAAI,GAAG,IAAAC,mCAAyB,EAACH,SAAS,CAACI,KAAK,CAAC;EACvD,IAAMZ,QAAQ,GAAGS,gBAAgB,GAAGA,gBAAgB,GAAGI,yBAAyB,CAACL,SAAS,CAAC;EAC3F,OAAO;IACLD,IAAI,EAAJA,IAAI;IACJG,IAAI,EAAE;MAACA,IAAI,EAAE,iBAAiB;MAAEI,QAAQ,EAAEN,SAAS,CAACO,IAAI;MAAEC,QAAQ,EAAE,CAAC;QAACT,IAAI,EAAE,OAAO;QAAEG,IAAI,EAAJA;MAAI,CAAC;IAAC,CAAC;IAC5FO,QAAQ,EAAE,KAAK;IACfjB,QAAQ,EAARA;EACF,CAAC;AACH;AAOA,SAASK,gBAAgBA,CAACN,UAA0B,EAAW;EAC7D,IAAMK,MAAe,GAAG,EAAE;EAC1B,KAAK,IAAMc,aAAa,IAAInB,UAAU,EAAE;IACtC,IAAMS,SAAwB,GAAGT,UAAU,CAACmB,aAAa,CAAC;IAC1Dd,MAAM,CAACe,IAAI,CAACb,eAAe,CAACY,aAAa,EAAEV,SAAS,CAAC,CAAC;EACxD;EACA,OAAOJ,MAAM;AACf;AAOO,SAASS,yBAAyBA,CAACL,SAAwB,EAA0B;EAC1F,IAAMY,MAA8B,GAAG,CAAC,CAAC;EACzC,IAAI,YAAY,IAAIZ,SAAS,EAAE;IAC7BY,MAAM,CAACC,UAAU,GAAGb,SAAS,CAACa,UAAU,CAAEC,QAAQ,CAAC,EAAE,CAAC;EACxD;EACA,IAAI,YAAY,IAAId,SAAS,EAAE;IAC7BY,MAAM,CAACG,UAAU,GAAGf,SAAS,CAACe,UAAU,CAAED,QAAQ,CAAC,EAAE,CAAC;EACxD;EACA,IAAI,YAAY,IAAId,SAAS,EAAE;IAC7BY,MAAM,CAACI,UAAU,GAAGhB,SAAS,CAACgB,UAAU,CAAEF,QAAQ,CAAC,CAAC;EACtD;EACA,OAAOF,MAAM;AACf"}