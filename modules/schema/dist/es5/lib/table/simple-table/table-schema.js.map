{"version":3,"file":"table-schema.js","names":["_dataType","require","deduceTableSchema","table","shape","deduceSchemaFromRows","data","deduceSchemaFromColumns","Error","deduceSchema","Array","isArray","columnarTable","fields","_i","_Object$entries","Object","entries","length","_Object$entries$_i","_slicedToArray2","default","columnName","column","field","deduceFieldFromColumn","push","metadata","rowTable","row0","_i2","_Object$entries2","_Object$entries2$_i","value","deduceFieldFromValue","name","ArrayBuffer","isView","type","getDataTypeFromArray","nullable","getDataTypeFromValue"],"sources":["../../../../../src/lib/table/simple-table/table-schema.ts"],"sourcesContent":["// Type deduction\nimport {Schema, Field} from '../../../types/schema';\nimport {ArrayType} from '../../../types/types';\nimport {Table} from '../../../types/category-table';\nimport {getDataTypeFromArray, getDataTypeFromValue} from './data-type';\n\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table: Table): Schema {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return deduceSchemaFromRows(table.data);\n\n    case 'columnar-table':\n      return deduceSchemaFromColumns(table.data);\n\n    case 'arrow-table':\n    default:\n      throw new Error('Deduce schema');\n  }\n}\n\nexport function deduceSchema(\n  data: unknown[][] | {[key: string]: unknown}[] | {[key: string]: unknown[]}\n): Schema {\n  return Array.isArray(data) ? deduceSchemaFromRows(data) : deduceSchemaFromColumns(data);\n}\n\n/** Given an object with columnar arrays, try to deduce a schema */\nfunction deduceSchemaFromColumns(columnarTable: {[key: string]: ArrayType}): Schema {\n  const fields: Field[] = [];\n  for (const [columnName, column] of Object.entries(columnarTable)) {\n    const field = deduceFieldFromColumn(column, columnName);\n    fields.push(field);\n  }\n  return {fields, metadata: {}};\n}\n\n/** Given an array of rows, try to deduce a schema */\nfunction deduceSchemaFromRows(rowTable: unknown[][] | {[key: string]: unknown}[]): Schema {\n  if (!rowTable.length) {\n    throw new Error('deduce from empty table');\n  }\n  const fields: Field[] = [];\n  const row0 = rowTable[0];\n  // TODO - fields can be nullable, false detection...\n  // Could look at additional rows if nulls in first row\n  // TODO - if array, column names will be numbers\n  for (const [columnName, value] of Object.entries(row0)) {\n    fields.push(deduceFieldFromValue(value, columnName));\n  }\n\n  return {fields, metadata: {}};\n}\n\n/** Given a column (i.e. array), attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromColumn(column: ArrayType, name: string): Field {\n  if (ArrayBuffer.isView(column)) {\n    const type = getDataTypeFromArray(column);\n    return {\n      name,\n      type: type.type || 'null',\n      nullable: type.nullable\n      // metadata: {}\n    };\n  }\n\n  if (Array.isArray(column) && column.length > 0) {\n    const value = column[0];\n    const type = getDataTypeFromValue(value);\n    // TODO - support nested schemas?\n    return {\n      name,\n      type,\n      nullable: true\n      // metadata: {},\n    };\n  }\n\n  throw new Error('empty table');\n}\n\n/** Given a value, attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromValue(value: unknown, name: string): Field {\n  const type = getDataTypeFromValue(value);\n  return {\n    name,\n    type,\n    nullable: true\n    // metadata: {}\n  };\n}\n"],"mappings":"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"}