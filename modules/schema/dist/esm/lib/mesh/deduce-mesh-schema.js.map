{"version":3,"file":"deduce-mesh-schema.js","names":["getDataTypeFromTypedArray","deduceMeshSchema","attributes","metadata","arguments","length","undefined","fields","deduceMeshFields","deduceMeshField","name","attribute","optionalMetadata","type","value","makeMeshAttributeMetadata","listSize","size","children","nullable","attributeName","push","result","byteOffset","toString","byteStride","normalized"],"sources":["../../../../src/lib/mesh/deduce-mesh-schema.ts"],"sourcesContent":["// loaders.gl, MIT license\n\nimport {MeshAttribute, MeshAttributes} from '../../types/category-mesh';\nimport {Schema, Field} from '../../types/schema';\nimport {getDataTypeFromTypedArray} from '../table/simple-table/data-type';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata: Record<string, string> = {}\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return {fields, metadata};\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  name: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Record<string, string>\n): Field {\n  const type = getDataTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  return {\n    name,\n    type: {type: 'fixed-size-list', listSize: attribute.size, children: [{name: 'value', type}]},\n    nullable: false,\n    metadata\n  };\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Record<string, string> {\n  const result: Record<string, string> = {};\n  if ('byteOffset' in attribute) {\n    result.byteOffset = attribute.byteOffset!.toString(10);\n  }\n  if ('byteStride' in attribute) {\n    result.byteStride = attribute.byteStride!.toString(10);\n  }\n  if ('normalized' in attribute) {\n    result.normalized = attribute.normalized!.toString();\n  }\n  return result;\n}\n"],"mappings":"AAIA,SAAQA,yBAAyB,QAAO,iCAAiC;AAQzE,OAAO,SAASC,gBAAgBA,CAC9BC,UAA0B,EAElB;EAAA,IADRC,QAAgC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAErC,MAAMG,MAAM,GAAGC,gBAAgB,CAACN,UAAU,CAAC;EAC3C,OAAO;IAACK,MAAM;IAAEJ;EAAQ,CAAC;AAC3B;AASA,OAAO,SAASM,eAAeA,CAC7BC,IAAY,EACZC,SAAwB,EACxBC,gBAAyC,EAClC;EACP,MAAMC,IAAI,GAAGb,yBAAyB,CAACW,SAAS,CAACG,KAAK,CAAC;EACvD,MAAMX,QAAQ,GAAGS,gBAAgB,GAAGA,gBAAgB,GAAGG,yBAAyB,CAACJ,SAAS,CAAC;EAC3F,OAAO;IACLD,IAAI;IACJG,IAAI,EAAE;MAACA,IAAI,EAAE,iBAAiB;MAAEG,QAAQ,EAAEL,SAAS,CAACM,IAAI;MAAEC,QAAQ,EAAE,CAAC;QAACR,IAAI,EAAE,OAAO;QAAEG;MAAI,CAAC;IAAC,CAAC;IAC5FM,QAAQ,EAAE,KAAK;IACfhB;EACF,CAAC;AACH;AAOA,SAASK,gBAAgBA,CAACN,UAA0B,EAAW;EAC7D,MAAMK,MAAe,GAAG,EAAE;EAC1B,KAAK,MAAMa,aAAa,IAAIlB,UAAU,EAAE;IACtC,MAAMS,SAAwB,GAAGT,UAAU,CAACkB,aAAa,CAAC;IAC1Db,MAAM,CAACc,IAAI,CAACZ,eAAe,CAACW,aAAa,EAAET,SAAS,CAAC,CAAC;EACxD;EACA,OAAOJ,MAAM;AACf;AAOA,OAAO,SAASQ,yBAAyBA,CAACJ,SAAwB,EAA0B;EAC1F,MAAMW,MAA8B,GAAG,CAAC,CAAC;EACzC,IAAI,YAAY,IAAIX,SAAS,EAAE;IAC7BW,MAAM,CAACC,UAAU,GAAGZ,SAAS,CAACY,UAAU,CAAEC,QAAQ,CAAC,EAAE,CAAC;EACxD;EACA,IAAI,YAAY,IAAIb,SAAS,EAAE;IAC7BW,MAAM,CAACG,UAAU,GAAGd,SAAS,CAACc,UAAU,CAAED,QAAQ,CAAC,EAAE,CAAC;EACxD;EACA,IAAI,YAAY,IAAIb,SAAS,EAAE;IAC7BW,MAAM,CAACI,UAAU,GAAGf,SAAS,CAACe,UAAU,CAAEF,QAAQ,CAAC,CAAC;EACtD;EACA,OAAOF,MAAM;AACf"}