{"version":3,"file":"table-schema.js","names":["getDataTypeFromArray","getDataTypeFromValue","deduceTableSchema","table","shape","deduceSchemaFromRows","data","deduceSchemaFromColumns","Error","deduceSchema","Array","isArray","columnarTable","fields","columnName","column","Object","entries","field","deduceFieldFromColumn","push","metadata","rowTable","length","row0","value","deduceFieldFromValue","name","ArrayBuffer","isView","type","nullable"],"sources":["../../../../../src/lib/table/simple-table/table-schema.ts"],"sourcesContent":["// Type deduction\nimport {Schema, Field} from '../../../types/schema';\nimport {ArrayType} from '../../../types/types';\nimport {Table} from '../../../types/category-table';\nimport {getDataTypeFromArray, getDataTypeFromValue} from './data-type';\n\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table: Table): Schema {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return deduceSchemaFromRows(table.data);\n\n    case 'columnar-table':\n      return deduceSchemaFromColumns(table.data);\n\n    case 'arrow-table':\n    default:\n      throw new Error('Deduce schema');\n  }\n}\n\nexport function deduceSchema(\n  data: unknown[][] | {[key: string]: unknown}[] | {[key: string]: unknown[]}\n): Schema {\n  return Array.isArray(data) ? deduceSchemaFromRows(data) : deduceSchemaFromColumns(data);\n}\n\n/** Given an object with columnar arrays, try to deduce a schema */\nfunction deduceSchemaFromColumns(columnarTable: {[key: string]: ArrayType}): Schema {\n  const fields: Field[] = [];\n  for (const [columnName, column] of Object.entries(columnarTable)) {\n    const field = deduceFieldFromColumn(column, columnName);\n    fields.push(field);\n  }\n  return {fields, metadata: {}};\n}\n\n/** Given an array of rows, try to deduce a schema */\nfunction deduceSchemaFromRows(rowTable: unknown[][] | {[key: string]: unknown}[]): Schema {\n  if (!rowTable.length) {\n    throw new Error('deduce from empty table');\n  }\n  const fields: Field[] = [];\n  const row0 = rowTable[0];\n  // TODO - fields can be nullable, false detection...\n  // Could look at additional rows if nulls in first row\n  // TODO - if array, column names will be numbers\n  for (const [columnName, value] of Object.entries(row0)) {\n    fields.push(deduceFieldFromValue(value, columnName));\n  }\n\n  return {fields, metadata: {}};\n}\n\n/** Given a column (i.e. array), attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromColumn(column: ArrayType, name: string): Field {\n  if (ArrayBuffer.isView(column)) {\n    const type = getDataTypeFromArray(column);\n    return {\n      name,\n      type: type.type || 'null',\n      nullable: type.nullable\n      // metadata: {}\n    };\n  }\n\n  if (Array.isArray(column) && column.length > 0) {\n    const value = column[0];\n    const type = getDataTypeFromValue(value);\n    // TODO - support nested schemas?\n    return {\n      name,\n      type,\n      nullable: true\n      // metadata: {},\n    };\n  }\n\n  throw new Error('empty table');\n}\n\n/** Given a value, attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromValue(value: unknown, name: string): Field {\n  const type = getDataTypeFromValue(value);\n  return {\n    name,\n    type,\n    nullable: true\n    // metadata: {}\n  };\n}\n"],"mappings":"AAIA,SAAQA,oBAAoB,EAAEC,oBAAoB,QAAO,aAAa;AAQtE,OAAO,SAASC,iBAAiBA,CAACC,KAAY,EAAU;EACtD,QAAQA,KAAK,CAACC,KAAK;IACjB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;MACrB,OAAOC,oBAAoB,CAACF,KAAK,CAACG,IAAI,CAAC;IAEzC,KAAK,gBAAgB;MACnB,OAAOC,uBAAuB,CAACJ,KAAK,CAACG,IAAI,CAAC;IAE5C,KAAK,aAAa;IAClB;MACE,MAAM,IAAIE,KAAK,CAAC,eAAe,CAAC;EACpC;AACF;AAEA,OAAO,SAASC,YAAYA,CAC1BH,IAA2E,EACnE;EACR,OAAOI,KAAK,CAACC,OAAO,CAACL,IAAI,CAAC,GAAGD,oBAAoB,CAACC,IAAI,CAAC,GAAGC,uBAAuB,CAACD,IAAI,CAAC;AACzF;AAGA,SAASC,uBAAuBA,CAACK,aAAyC,EAAU;EAClF,MAAMC,MAAe,GAAG,EAAE;EAC1B,KAAK,MAAM,CAACC,UAAU,EAAEC,MAAM,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACL,aAAa,CAAC,EAAE;IAChE,MAAMM,KAAK,GAAGC,qBAAqB,CAACJ,MAAM,EAAED,UAAU,CAAC;IACvDD,MAAM,CAACO,IAAI,CAACF,KAAK,CAAC;EACpB;EACA,OAAO;IAACL,MAAM;IAAEQ,QAAQ,EAAE,CAAC;EAAC,CAAC;AAC/B;AAGA,SAAShB,oBAAoBA,CAACiB,QAAkD,EAAU;EACxF,IAAI,CAACA,QAAQ,CAACC,MAAM,EAAE;IACpB,MAAM,IAAIf,KAAK,CAAC,yBAAyB,CAAC;EAC5C;EACA,MAAMK,MAAe,GAAG,EAAE;EAC1B,MAAMW,IAAI,GAAGF,QAAQ,CAAC,CAAC,CAAC;EAIxB,KAAK,MAAM,CAACR,UAAU,EAAEW,KAAK,CAAC,IAAIT,MAAM,CAACC,OAAO,CAACO,IAAI,CAAC,EAAE;IACtDX,MAAM,CAACO,IAAI,CAACM,oBAAoB,CAACD,KAAK,EAAEX,UAAU,CAAC,CAAC;EACtD;EAEA,OAAO;IAACD,MAAM;IAAEQ,QAAQ,EAAE,CAAC;EAAC,CAAC;AAC/B;AAGA,SAASF,qBAAqBA,CAACJ,MAAiB,EAAEY,IAAY,EAAS;EACrE,IAAIC,WAAW,CAACC,MAAM,CAACd,MAAM,CAAC,EAAE;IAC9B,MAAMe,IAAI,GAAG9B,oBAAoB,CAACe,MAAM,CAAC;IACzC,OAAO;MACLY,IAAI;MACJG,IAAI,EAAEA,IAAI,CAACA,IAAI,IAAI,MAAM;MACzBC,QAAQ,EAAED,IAAI,CAACC;IAEjB,CAAC;EACH;EAEA,IAAIrB,KAAK,CAACC,OAAO,CAACI,MAAM,CAAC,IAAIA,MAAM,CAACQ,MAAM,GAAG,CAAC,EAAE;IAC9C,MAAME,KAAK,GAAGV,MAAM,CAAC,CAAC,CAAC;IACvB,MAAMe,IAAI,GAAG7B,oBAAoB,CAACwB,KAAK,CAAC;IAExC,OAAO;MACLE,IAAI;MACJG,IAAI;MACJC,QAAQ,EAAE;IAEZ,CAAC;EACH;EAEA,MAAM,IAAIvB,KAAK,CAAC,aAAa,CAAC;AAChC;AAGA,SAASkB,oBAAoBA,CAACD,KAAc,EAAEE,IAAY,EAAS;EACjE,MAAMG,IAAI,GAAG7B,oBAAoB,CAACwB,KAAK,CAAC;EACxC,OAAO;IACLE,IAAI;IACJG,IAAI;IACJC,QAAQ,EAAE;EAEZ,CAAC;AACH"}