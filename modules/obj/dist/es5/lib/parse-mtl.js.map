{"version":3,"file":"parse-mtl.js","names":["DELIMITER_PATTERN","parseMTL","text","options","materials","currentMaterial","name","lines","split","_iterator","_createForOfIteratorHelper","_step","s","n","done","line","value","trim","length","charAt","pos","indexOf","key","substring","toLowerCase","push","ambientColor","parseColor","diffuseColor","diffuseTextureUrl","specularColor","specularTextureUrl","emissiveColor","emissiveTextureUrl","shininess","parseFloat","refraction","illumination","err","e","f","rgb","color"],"sources":["../../../src/lib/parse-mtl.ts"],"sourcesContent":["// loaders.gl, MIT license\n// Forked from THREE.js under MIT license\n// https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/MTLLoader.js\n\n// import type {DiffuseMaterial} from '@loaders.gl/schema';\n\nexport type MTLMaterial = {\n  name: string;\n  ambientColor?: [number, number, number];\n  diffuseColor?: [number, number, number];\n  specularColor?: [number, number, number];\n  emissiveColor?: [number, number, number];\n  // specular?: number;\n  shininess?: number;\n  refraction?: number;\n  illumination?: number;\n  diffuseTextureUrl?: string;\n  emissiveTextureUrl?: string;\n  specularTextureUrl?: string;\n};\n\nconst DELIMITER_PATTERN = /\\s+/;\n\n/**\n * Set of options on how to construct materials\n * @param normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 (Default: false, assumed to be already normalized)\n * @param ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's Default: false\n * @param baseUrl - Url relative to which textures are loaded\n */\nexport type ParseMTLOptions = {\n  normalizeRGB?: boolean;\n  ignoreZeroRGBs?: boolean;\n  baseUrl?: string;\n};\n\n/**\n * Parses a MTL file.\n * Parses a Wavefront .mtl file specifying materials\n * http://paulbourke.net/dataformats/mtl/\n * https://www.loc.gov/preservation/digital/formats/fdd/fdd000508.shtml\n *\n * @param  text - Content of MTL file\n */\n// eslint-disable-next-line complexity\nexport function parseMTL(text: string, options?: ParseMTLOptions): MTLMaterial[] {\n  // const materialsInfo: Record<string, MTLMaterial> = {};\n  const materials: MTLMaterial[] = [];\n\n  let currentMaterial: MTLMaterial = {name: 'placeholder'};\n\n  const lines = text.split('\\n');\n  for (let line of lines) {\n    line = line.trim();\n\n    if (line.length === 0 || line.charAt(0) === '#') {\n      // Blank line or comment ignore\n      continue; // eslint-disable-line no-continue\n    }\n\n    const pos = line.indexOf(' ');\n\n    let key = pos >= 0 ? line.substring(0, pos) : line;\n    key = key.toLowerCase();\n\n    let value = pos >= 0 ? line.substring(pos + 1) : '';\n    value = value.trim();\n\n    switch (key) {\n      case 'newmtl':\n        // New material\n        currentMaterial = {name: value};\n        // insert into map\n        materials.push(currentMaterial);\n        break;\n\n      case 'ka': // Ka\n        currentMaterial.ambientColor = parseColor(value);\n        break;\n\n      case 'kd':\n        // Kd: Diffuse color (color under white light) using RGB values\n        currentMaterial.diffuseColor = parseColor(value);\n        break;\n      case 'map_kd':\n        // Diffuse texture map\n        currentMaterial.diffuseTextureUrl = value;\n        //         setMapForType('map', value);\n        break;\n\n      case 'ks':\n        // Specular color (color when light is reflected from shiny surface) using RGB values\n        currentMaterial.specularColor = parseColor(value);\n        break;\n      case 'map_ks':\n        // Specular map\n        currentMaterial.specularTextureUrl = value;\n        // setMapForType('specularMap', value);\n        break;\n\n      case 'ke':\n        // Emissive using RGB values\n        currentMaterial.emissiveColor = parseColor(value);\n        break;\n      case 'map_ke':\n        // Emissive map\n        currentMaterial.emissiveTextureUrl = value;\n        // setMapForType('emissiveMap', value);\n        break;\n\n      case 'ns':\n        // Ns is material specular exponent (defines the focus of the specular highlight)\n        // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n        currentMaterial.shininess = parseFloat(value);\n        break;\n      case 'map_ns':\n        // Ns is material specular exponent\n        // TODO?\n        // currentMaterial.shininessMap = parseFloat(value);\n        break;\n      case 'ni':\n        currentMaterial.refraction = parseFloat(value);\n        break;\n      case 'illum':\n        currentMaterial.illumination = parseFloat(value);\n        break;\n\n      default:\n        // log unknown message?\n        break;\n\n      /*\n      case 'norm':\n        setMapForType('normalMap', value);\n        break;\n\n      case 'map_bump':\n      case 'bump':\n        // Bump texture map\n        setMapForType('bumpMap', value);\n        break;\n\n      case 'd':\n        n = parseFloat(value);\n        if (n < 1) {\n          params.opacity = n;\n          params.transparent = true;\n        }\n        break;\n\n      case 'map_d':\n        // Alpha map\n        setMapForType('alphaMap', value);\n        params.transparent = true;\n        break;\n\n      case 'tr':\n        n = parseFloat(value);\n        if (this.options && this.options.invertTrProperty) n = 1 - n;\n        if (n > 0) {\n          params.opacity = 1 - n;\n          params.transparent = true;\n        }\n      */\n    }\n  }\n\n  return materials;\n}\n\nfunction parseColor(value: string, options?: ParseMTLOptions): [number, number, number] {\n  const rgb = value.split(DELIMITER_PATTERN, 3);\n  const color: [number, number, number] = [\n    parseFloat(rgb[0]),\n    parseFloat(rgb[1]),\n    parseFloat(rgb[2])\n  ];\n  // TODO auto detect big values?\n  // if (this.options && this.options.normalizeRGB) {\n  //   value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n  // }\n\n  // if (this.options && this.options.ignoreZeroRGBs) {\n  //   if (value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0) {\n  //     // ignore\n  //     save = false;\n  //   }\n  // }\n  return color;\n}\n\n/* TODO parse url options\nfunction parseTexture(value, matParams) {\n  const texParams = {\n    scale: new Vector2(1, 1),\n    offset: new Vector2(0, 0)\n  };\n\n  const items = value.split(/\\s+/);\n  let pos;\n\n  pos = items.indexOf('-bm');\n  if (pos >= 0) {\n    matParams.bumpScale = parseFloat(items[ pos + 1 ]);\n    items.splice(pos, 2);\n  }\n\n  pos = items.indexOf('-s');\n  if (pos >= 0) {\n    texParams.scale.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n\n  }\n\n  pos = items.indexOf('-o');\n\n  if (pos >= 0) {\n    texParams.offset.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n  }\n\n  texParams.url = items.join(' ').trim();\n  return texParams;\n}\n\n *function resolveURL(baseUrl, url) {\n * baseUrl?: string;\n    // Absolute URL\n    if (/^https?:\\/\\//i.test(url)) return url;\n    return baseUrl + url;\n  }\n\n  function setMapForType(mapType, value) {\n    if (params[ mapType ]) return; // Keep the first encountered texture\n\n    const texParams = scope.getTextureParams(value, params);\n    const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n    map.repeat.copy(texParams.scale);\n    map.offset.copy(texParams.offset);\n\n    map.wrapS = scope.wrap;\n    map.wrapT = scope.wrap;\n\n    params[ mapType ] = map;\n  }\n*/\n"],"mappings":";;;;;;;;;AAqBA,IAAMA,iBAAiB,GAAG,KAAK;AAuBxB,SAASC,QAAQA,CAACC,IAAY,EAAEC,OAAyB,EAAiB;EAE/E,IAAMC,SAAwB,GAAG,EAAE;EAEnC,IAAIC,eAA4B,GAAG;IAACC,IAAI,EAAE;EAAa,CAAC;EAExD,IAAMC,KAAK,GAAGL,IAAI,CAACM,KAAK,CAAC,IAAI,CAAC;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CACdH,KAAK;IAAAI,KAAA;EAAA;IAAtB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAwB;MAAA,IAAfC,IAAI,GAAAJ,KAAA,CAAAK,KAAA;MACXD,IAAI,GAAGA,IAAI,CAACE,IAAI,CAAC,CAAC;MAElB,IAAIF,IAAI,CAACG,MAAM,KAAK,CAAC,IAAIH,IAAI,CAACI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAE/C;MACF;MAEA,IAAMC,GAAG,GAAGL,IAAI,CAACM,OAAO,CAAC,GAAG,CAAC;MAE7B,IAAIC,GAAG,GAAGF,GAAG,IAAI,CAAC,GAAGL,IAAI,CAACQ,SAAS,CAAC,CAAC,EAAEH,GAAG,CAAC,GAAGL,IAAI;MAClDO,GAAG,GAAGA,GAAG,CAACE,WAAW,CAAC,CAAC;MAEvB,IAAIR,KAAK,GAAGI,GAAG,IAAI,CAAC,GAAGL,IAAI,CAACQ,SAAS,CAACH,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE;MACnDJ,KAAK,GAAGA,KAAK,CAACC,IAAI,CAAC,CAAC;MAEpB,QAAQK,GAAG;QACT,KAAK,QAAQ;UAEXjB,eAAe,GAAG;YAACC,IAAI,EAAEU;UAAK,CAAC;UAE/BZ,SAAS,CAACqB,IAAI,CAACpB,eAAe,CAAC;UAC/B;QAEF,KAAK,IAAI;UACPA,eAAe,CAACqB,YAAY,GAAGC,UAAU,CAACX,KAAK,CAAC;UAChD;QAEF,KAAK,IAAI;UAEPX,eAAe,CAACuB,YAAY,GAAGD,UAAU,CAACX,KAAK,CAAC;UAChD;QACF,KAAK,QAAQ;UAEXX,eAAe,CAACwB,iBAAiB,GAAGb,KAAK;UAEzC;QAEF,KAAK,IAAI;UAEPX,eAAe,CAACyB,aAAa,GAAGH,UAAU,CAACX,KAAK,CAAC;UACjD;QACF,KAAK,QAAQ;UAEXX,eAAe,CAAC0B,kBAAkB,GAAGf,KAAK;UAE1C;QAEF,KAAK,IAAI;UAEPX,eAAe,CAAC2B,aAAa,GAAGL,UAAU,CAACX,KAAK,CAAC;UACjD;QACF,KAAK,QAAQ;UAEXX,eAAe,CAAC4B,kBAAkB,GAAGjB,KAAK;UAE1C;QAEF,KAAK,IAAI;UAGPX,eAAe,CAAC6B,SAAS,GAAGC,UAAU,CAACnB,KAAK,CAAC;UAC7C;QACF,KAAK,QAAQ;UAIX;QACF,KAAK,IAAI;UACPX,eAAe,CAAC+B,UAAU,GAAGD,UAAU,CAACnB,KAAK,CAAC;UAC9C;QACF,KAAK,OAAO;UACVX,eAAe,CAACgC,YAAY,GAAGF,UAAU,CAACnB,KAAK,CAAC;UAChD;QAEF;UAEE;MAmCJ;IACF;EAAC,SAAAsB,GAAA;IAAA7B,SAAA,CAAA8B,CAAA,CAAAD,GAAA;EAAA;IAAA7B,SAAA,CAAA+B,CAAA;EAAA;EAED,OAAOpC,SAAS;AAClB;AAEA,SAASuB,UAAUA,CAACX,KAAa,EAAEb,OAAyB,EAA4B;EACtF,IAAMsC,GAAG,GAAGzB,KAAK,CAACR,KAAK,CAACR,iBAAiB,EAAE,CAAC,CAAC;EAC7C,IAAM0C,KAA+B,GAAG,CACtCP,UAAU,CAACM,GAAG,CAAC,CAAC,CAAC,CAAC,EAClBN,UAAU,CAACM,GAAG,CAAC,CAAC,CAAC,CAAC,EAClBN,UAAU,CAACM,GAAG,CAAC,CAAC,CAAC,CAAC,CACnB;EAYD,OAAOC,KAAK;AACd"}