{"version":3,"file":"parse-mtl.js","names":["DELIMITER_PATTERN","parseMTL","text","options","materials","currentMaterial","name","lines","split","line","trim","length","charAt","pos","indexOf","key","substring","toLowerCase","value","push","ambientColor","parseColor","diffuseColor","diffuseTextureUrl","specularColor","specularTextureUrl","emissiveColor","emissiveTextureUrl","shininess","parseFloat","refraction","illumination","rgb","color"],"sources":["../../../src/lib/parse-mtl.ts"],"sourcesContent":["// loaders.gl, MIT license\n// Forked from THREE.js under MIT license\n// https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/MTLLoader.js\n\n// import type {DiffuseMaterial} from '@loaders.gl/schema';\n\nexport type MTLMaterial = {\n  name: string;\n  ambientColor?: [number, number, number];\n  diffuseColor?: [number, number, number];\n  specularColor?: [number, number, number];\n  emissiveColor?: [number, number, number];\n  // specular?: number;\n  shininess?: number;\n  refraction?: number;\n  illumination?: number;\n  diffuseTextureUrl?: string;\n  emissiveTextureUrl?: string;\n  specularTextureUrl?: string;\n};\n\nconst DELIMITER_PATTERN = /\\s+/;\n\n/**\n * Set of options on how to construct materials\n * @param normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 (Default: false, assumed to be already normalized)\n * @param ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's Default: false\n * @param baseUrl - Url relative to which textures are loaded\n */\nexport type ParseMTLOptions = {\n  normalizeRGB?: boolean;\n  ignoreZeroRGBs?: boolean;\n  baseUrl?: string;\n};\n\n/**\n * Parses a MTL file.\n * Parses a Wavefront .mtl file specifying materials\n * http://paulbourke.net/dataformats/mtl/\n * https://www.loc.gov/preservation/digital/formats/fdd/fdd000508.shtml\n *\n * @param  text - Content of MTL file\n */\n// eslint-disable-next-line complexity\nexport function parseMTL(text: string, options?: ParseMTLOptions): MTLMaterial[] {\n  // const materialsInfo: Record<string, MTLMaterial> = {};\n  const materials: MTLMaterial[] = [];\n\n  let currentMaterial: MTLMaterial = {name: 'placeholder'};\n\n  const lines = text.split('\\n');\n  for (let line of lines) {\n    line = line.trim();\n\n    if (line.length === 0 || line.charAt(0) === '#') {\n      // Blank line or comment ignore\n      continue; // eslint-disable-line no-continue\n    }\n\n    const pos = line.indexOf(' ');\n\n    let key = pos >= 0 ? line.substring(0, pos) : line;\n    key = key.toLowerCase();\n\n    let value = pos >= 0 ? line.substring(pos + 1) : '';\n    value = value.trim();\n\n    switch (key) {\n      case 'newmtl':\n        // New material\n        currentMaterial = {name: value};\n        // insert into map\n        materials.push(currentMaterial);\n        break;\n\n      case 'ka': // Ka\n        currentMaterial.ambientColor = parseColor(value);\n        break;\n\n      case 'kd':\n        // Kd: Diffuse color (color under white light) using RGB values\n        currentMaterial.diffuseColor = parseColor(value);\n        break;\n      case 'map_kd':\n        // Diffuse texture map\n        currentMaterial.diffuseTextureUrl = value;\n        //         setMapForType('map', value);\n        break;\n\n      case 'ks':\n        // Specular color (color when light is reflected from shiny surface) using RGB values\n        currentMaterial.specularColor = parseColor(value);\n        break;\n      case 'map_ks':\n        // Specular map\n        currentMaterial.specularTextureUrl = value;\n        // setMapForType('specularMap', value);\n        break;\n\n      case 'ke':\n        // Emissive using RGB values\n        currentMaterial.emissiveColor = parseColor(value);\n        break;\n      case 'map_ke':\n        // Emissive map\n        currentMaterial.emissiveTextureUrl = value;\n        // setMapForType('emissiveMap', value);\n        break;\n\n      case 'ns':\n        // Ns is material specular exponent (defines the focus of the specular highlight)\n        // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n        currentMaterial.shininess = parseFloat(value);\n        break;\n      case 'map_ns':\n        // Ns is material specular exponent\n        // TODO?\n        // currentMaterial.shininessMap = parseFloat(value);\n        break;\n      case 'ni':\n        currentMaterial.refraction = parseFloat(value);\n        break;\n      case 'illum':\n        currentMaterial.illumination = parseFloat(value);\n        break;\n\n      default:\n        // log unknown message?\n        break;\n\n      /*\n      case 'norm':\n        setMapForType('normalMap', value);\n        break;\n\n      case 'map_bump':\n      case 'bump':\n        // Bump texture map\n        setMapForType('bumpMap', value);\n        break;\n\n      case 'd':\n        n = parseFloat(value);\n        if (n < 1) {\n          params.opacity = n;\n          params.transparent = true;\n        }\n        break;\n\n      case 'map_d':\n        // Alpha map\n        setMapForType('alphaMap', value);\n        params.transparent = true;\n        break;\n\n      case 'tr':\n        n = parseFloat(value);\n        if (this.options && this.options.invertTrProperty) n = 1 - n;\n        if (n > 0) {\n          params.opacity = 1 - n;\n          params.transparent = true;\n        }\n      */\n    }\n  }\n\n  return materials;\n}\n\nfunction parseColor(value: string, options?: ParseMTLOptions): [number, number, number] {\n  const rgb = value.split(DELIMITER_PATTERN, 3);\n  const color: [number, number, number] = [\n    parseFloat(rgb[0]),\n    parseFloat(rgb[1]),\n    parseFloat(rgb[2])\n  ];\n  // TODO auto detect big values?\n  // if (this.options && this.options.normalizeRGB) {\n  //   value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n  // }\n\n  // if (this.options && this.options.ignoreZeroRGBs) {\n  //   if (value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0) {\n  //     // ignore\n  //     save = false;\n  //   }\n  // }\n  return color;\n}\n\n/* TODO parse url options\nfunction parseTexture(value, matParams) {\n  const texParams = {\n    scale: new Vector2(1, 1),\n    offset: new Vector2(0, 0)\n  };\n\n  const items = value.split(/\\s+/);\n  let pos;\n\n  pos = items.indexOf('-bm');\n  if (pos >= 0) {\n    matParams.bumpScale = parseFloat(items[ pos + 1 ]);\n    items.splice(pos, 2);\n  }\n\n  pos = items.indexOf('-s');\n  if (pos >= 0) {\n    texParams.scale.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n\n  }\n\n  pos = items.indexOf('-o');\n\n  if (pos >= 0) {\n    texParams.offset.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n  }\n\n  texParams.url = items.join(' ').trim();\n  return texParams;\n}\n\n *function resolveURL(baseUrl, url) {\n * baseUrl?: string;\n    // Absolute URL\n    if (/^https?:\\/\\//i.test(url)) return url;\n    return baseUrl + url;\n  }\n\n  function setMapForType(mapType, value) {\n    if (params[ mapType ]) return; // Keep the first encountered texture\n\n    const texParams = scope.getTextureParams(value, params);\n    const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n    map.repeat.copy(texParams.scale);\n    map.offset.copy(texParams.offset);\n\n    map.wrapS = scope.wrap;\n    map.wrapT = scope.wrap;\n\n    params[ mapType ] = map;\n  }\n*/\n"],"mappings":"AAqBA,MAAMA,iBAAiB,GAAG,KAAK;AAuB/B,OAAO,SAASC,QAAQA,CAACC,IAAY,EAAEC,OAAyB,EAAiB;EAE/E,MAAMC,SAAwB,GAAG,EAAE;EAEnC,IAAIC,eAA4B,GAAG;IAACC,IAAI,EAAE;EAAa,CAAC;EAExD,MAAMC,KAAK,GAAGL,IAAI,CAACM,KAAK,CAAC,IAAI,CAAC;EAC9B,KAAK,IAAIC,IAAI,IAAIF,KAAK,EAAE;IACtBE,IAAI,GAAGA,IAAI,CAACC,IAAI,CAAC,CAAC;IAElB,IAAID,IAAI,CAACE,MAAM,KAAK,CAAC,IAAIF,IAAI,CAACG,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAE/C;IACF;IAEA,MAAMC,GAAG,GAAGJ,IAAI,CAACK,OAAO,CAAC,GAAG,CAAC;IAE7B,IAAIC,GAAG,GAAGF,GAAG,IAAI,CAAC,GAAGJ,IAAI,CAACO,SAAS,CAAC,CAAC,EAAEH,GAAG,CAAC,GAAGJ,IAAI;IAClDM,GAAG,GAAGA,GAAG,CAACE,WAAW,CAAC,CAAC;IAEvB,IAAIC,KAAK,GAAGL,GAAG,IAAI,CAAC,GAAGJ,IAAI,CAACO,SAAS,CAACH,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE;IACnDK,KAAK,GAAGA,KAAK,CAACR,IAAI,CAAC,CAAC;IAEpB,QAAQK,GAAG;MACT,KAAK,QAAQ;QAEXV,eAAe,GAAG;UAACC,IAAI,EAAEY;QAAK,CAAC;QAE/Bd,SAAS,CAACe,IAAI,CAACd,eAAe,CAAC;QAC/B;MAEF,KAAK,IAAI;QACPA,eAAe,CAACe,YAAY,GAAGC,UAAU,CAACH,KAAK,CAAC;QAChD;MAEF,KAAK,IAAI;QAEPb,eAAe,CAACiB,YAAY,GAAGD,UAAU,CAACH,KAAK,CAAC;QAChD;MACF,KAAK,QAAQ;QAEXb,eAAe,CAACkB,iBAAiB,GAAGL,KAAK;QAEzC;MAEF,KAAK,IAAI;QAEPb,eAAe,CAACmB,aAAa,GAAGH,UAAU,CAACH,KAAK,CAAC;QACjD;MACF,KAAK,QAAQ;QAEXb,eAAe,CAACoB,kBAAkB,GAAGP,KAAK;QAE1C;MAEF,KAAK,IAAI;QAEPb,eAAe,CAACqB,aAAa,GAAGL,UAAU,CAACH,KAAK,CAAC;QACjD;MACF,KAAK,QAAQ;QAEXb,eAAe,CAACsB,kBAAkB,GAAGT,KAAK;QAE1C;MAEF,KAAK,IAAI;QAGPb,eAAe,CAACuB,SAAS,GAAGC,UAAU,CAACX,KAAK,CAAC;QAC7C;MACF,KAAK,QAAQ;QAIX;MACF,KAAK,IAAI;QACPb,eAAe,CAACyB,UAAU,GAAGD,UAAU,CAACX,KAAK,CAAC;QAC9C;MACF,KAAK,OAAO;QACVb,eAAe,CAAC0B,YAAY,GAAGF,UAAU,CAACX,KAAK,CAAC;QAChD;MAEF;QAEE;IAmCJ;EACF;EAEA,OAAOd,SAAS;AAClB;AAEA,SAASiB,UAAUA,CAACH,KAAa,EAAEf,OAAyB,EAA4B;EACtF,MAAM6B,GAAG,GAAGd,KAAK,CAACV,KAAK,CAACR,iBAAiB,EAAE,CAAC,CAAC;EAC7C,MAAMiC,KAA+B,GAAG,CACtCJ,UAAU,CAACG,GAAG,CAAC,CAAC,CAAC,CAAC,EAClBH,UAAU,CAACG,GAAG,CAAC,CAAC,CAAC,CAAC,EAClBH,UAAU,CAACG,GAAG,CAAC,CAAC,CAAC,CAAC,CACnB;EAYD,OAAOC,KAAK;AACd"}