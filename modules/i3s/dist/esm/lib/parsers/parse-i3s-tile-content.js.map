{"version":3,"file":"parse-i3s-tile-content.js","names":["load","parse","Vector3","Matrix4","Ellipsoid","ImageLoader","DracoLoader","BasisLoader","CompressedTextureLoader","HeaderAttributeProperty","getUrlWithToken","GL_TYPE_MAP","getConstructorForDataFormat","sizeOf","COORDINATE_SYSTEM","customizeColors","scratchVector","getLoaderForTextureFormat","textureFormat","I3S_ATTRIBUTE_TYPE","parseI3STileContent","arrayBuffer","tileOptions","tilesetOptions","options","context","content","attributes","indices","featureIds","vertexCount","modelMatrix","coordinateSystem","byteLength","texture","textureUrl","_options$i3s","url","i3s","token","loader","response","fetch","decodeTextures","textureLoaderOptions","image","type","e","compressed","mipmaps","width","height","data","material","makePbrMaterial","materialDefinition","parseI3SNodeGeometry","_options$i3s2","contentByteLength","byteOffset","featureCount","isDracoGeometry","_decompressedGeometry","decompressedGeometry","draco","attributeNameEntry","header","value","POSITION","NORMAL","COLOR_0","TEXCOORD_0","featureIndex","uvRegion","position","normal","color","uv0","id","updateAttributesMetadata","getFeatureIdsFromFeatureIndexMetadata","flattenFeatureIdsByFeatureIndices","vertexAttributes","ordering","attributesOrder","featureAttributes","featureAttributeOrder","store","defaultGeometrySchema","headers","parseHeaders","normalizedVertexAttributes","offset","normalizeAttributes","normalizedFeatureAttributes","flattenFeatureIdsByFaceRanges","concatAttributes","METER_OFFSETS","enuMatrix","parsePositions","invert","getModelMatrix","LNGLAT_OFFSETS","positions","normals","colors","normalizeAttribute","texCoords","uvRegions","region","attributeIndex","key","loaderData","dracoAttribute","name","metadata","attribute","normalized","property","TypedArrayTypeHeader","attributeCount","valueType","valuesPerElement","buffer","slice","parseUint64Values","TypedArrayType","size","elementsCount","attributeSize","values","dataView","DataView","index","left","getUint32","right","push","Uint32Array","mbs","cartographicOrigin","cartesianOrigin","WGS84","cartographicToCartesian","eastNorthUpToFixedFrame","offsetsToCartesians","vertices","arguments","length","undefined","Float64Array","scaleX","double","scaleY","i","x","y","z","subarray","_metadata$i3sScale_x","_metadata$i3sScale_y","pbrMaterial","pbrMetallicRoughness","baseColorFactor","baseColorTexture","texCoord","alphaCutoff","alphaMode","toUpperCase","emissiveFactor","convertColorFormat","setMaterialTexture","colorFactor","normalizedColor","source","emissiveTexture","metallicRoughnessTexture","normalTexture","occlusionTexture","faceRange","range","featureIdsLength","orderedFeatureIndices","startIndex","fillId","Number","endValue","prevValue","trianglesCount","endIndex","fill","featureIndices","result","Float32Array","_featureIndex$metadat","_featureIndex$metadat2","intArray"],"sources":["../../../../src/lib/parsers/parse-i3s-tile-content.ts"],"sourcesContent":["import type {TypedArray} from '@loaders.gl/schema';\nimport {load, parse} from '@loaders.gl/core';\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport type {LoaderOptions, LoaderContext} from '@loaders.gl/loader-utils';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {DracoLoader, DracoMesh} from '@loaders.gl/draco';\nimport {BasisLoader, CompressedTextureLoader} from '@loaders.gl/textures';\n\nimport {\n  FeatureAttribute,\n  VertexAttribute,\n  I3SMeshAttributes,\n  I3SMeshAttribute,\n  TileContentTexture,\n  HeaderAttributeProperty,\n  I3SMaterialDefinition,\n  I3STileContent,\n  I3STileOptions,\n  I3STilesetOptions\n} from '../../types';\nimport {getUrlWithToken} from '../utils/url-utils';\n\nimport {GL_TYPE_MAP, getConstructorForDataFormat, sizeOf, COORDINATE_SYSTEM} from './constants';\nimport {I3SLoaderOptions} from '../../i3s-loader';\nimport {customizeColors} from '../utils/customizeColors';\n\nconst scratchVector = new Vector3([0, 0, 0]);\n\nfunction getLoaderForTextureFormat(textureFormat?: 'jpg' | 'png' | 'ktx-etc2' | 'dds' | 'ktx2') {\n  switch (textureFormat) {\n    case 'ktx-etc2':\n    case 'dds':\n      return CompressedTextureLoader;\n    case 'ktx2':\n      return BasisLoader;\n    case 'jpg':\n    case 'png':\n    default:\n      return ImageLoader;\n  }\n}\n\nconst I3S_ATTRIBUTE_TYPE = 'i3s-attribute-type';\n\nexport async function parseI3STileContent(\n  arrayBuffer: ArrayBuffer,\n  tileOptions: I3STileOptions,\n  tilesetOptions: I3STilesetOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<I3STileContent> {\n  const content: I3STileContent = {\n    attributes: {},\n    indices: null,\n    featureIds: [],\n    vertexCount: 0,\n    modelMatrix: new Matrix4(),\n    coordinateSystem: 0,\n    byteLength: 0,\n    texture: null\n  };\n\n  if (tileOptions.textureUrl) {\n    // @ts-expect-error options is not properly typed\n    const url = getUrlWithToken(tileOptions.textureUrl, options?.i3s?.token);\n    const loader = getLoaderForTextureFormat(tileOptions.textureFormat);\n    const response = await fetch(url, options?.fetch as RequestInit);\n    const arrayBuffer = await response.arrayBuffer();\n\n    // @ts-expect-error options is not properly typed\n    if (options?.i3s.decodeTextures) {\n      if (loader === ImageLoader) {\n        const options = {...tileOptions.textureLoaderOptions, image: {type: 'data'}};\n        try {\n          // @ts-ignore context must be defined\n          // Image constructor is not supported in worker thread.\n          // Do parsing image data on the main thread by using context to avoid worker issues.\n          content.texture = await context.parse(arrayBuffer, options);\n        } catch (e) {\n          // context object is different between worker and node.js conversion script.\n          // To prevent error we parse data in ordinary way if it is not parsed by using context.\n          // @ts-expect-error\n          content.texture = await parse(arrayBuffer, loader, options);\n        }\n      } else if (loader === CompressedTextureLoader || loader === BasisLoader) {\n        let texture = await load(arrayBuffer, loader, tileOptions.textureLoaderOptions);\n        if (loader === BasisLoader) {\n          // @ts-expect-error\n          texture = texture[0];\n        }\n        content.texture = {\n          compressed: true,\n          mipmaps: false,\n          // @ts-expect-error\n          width: texture[0].width,\n          // @ts-expect-error\n          height: texture[0].height,\n          // @ts-expect-error\n          data: texture\n        };\n      }\n    } else {\n      content.texture = arrayBuffer;\n    }\n  }\n\n  content.material = makePbrMaterial(tileOptions.materialDefinition, content.texture);\n  if (content.material) {\n    content.texture = null;\n  }\n\n  return await parseI3SNodeGeometry(arrayBuffer, content, tileOptions, tilesetOptions, options);\n}\n\n/* eslint-disable max-statements */\nasync function parseI3SNodeGeometry(\n  arrayBuffer: ArrayBuffer,\n  content: I3STileContent,\n  tileOptions: I3STileOptions,\n  tilesetOptions: I3STilesetOptions,\n  options?: I3SLoaderOptions\n): Promise<I3STileContent> {\n  const contentByteLength = arrayBuffer.byteLength;\n  let attributes: I3SMeshAttributes;\n  let vertexCount: number;\n  let byteOffset: number = 0;\n  let featureCount: number = 0;\n  let indices: TypedArray | undefined;\n\n  if (tileOptions.isDracoGeometry) {\n    const decompressedGeometry: DracoMesh = await parse(arrayBuffer, DracoLoader, {\n      draco: {\n        attributeNameEntry: I3S_ATTRIBUTE_TYPE\n      }\n    });\n    // @ts-expect-error\n    vertexCount = decompressedGeometry.header.vertexCount;\n    indices = decompressedGeometry.indices?.value;\n    const {\n      POSITION,\n      NORMAL,\n      COLOR_0,\n      TEXCOORD_0,\n      ['feature-index']: featureIndex,\n      ['uv-region']: uvRegion\n    } = decompressedGeometry.attributes;\n\n    attributes = {\n      position: POSITION,\n      normal: NORMAL,\n      color: COLOR_0,\n      uv0: TEXCOORD_0,\n      uvRegion,\n      id: featureIndex\n    };\n\n    updateAttributesMetadata(attributes, decompressedGeometry);\n\n    const featureIds = getFeatureIdsFromFeatureIndexMetadata(featureIndex);\n\n    if (featureIds) {\n      flattenFeatureIdsByFeatureIndices(attributes, featureIds);\n    }\n  } else {\n    const {\n      vertexAttributes,\n      ordering: attributesOrder,\n      featureAttributes,\n      featureAttributeOrder\n    } = tilesetOptions.store.defaultGeometrySchema;\n    // First 8 bytes reserved for header (vertexCount and featureCount)\n    const headers = parseHeaders(arrayBuffer, tilesetOptions);\n    byteOffset = headers.byteOffset;\n    vertexCount = headers.vertexCount;\n    featureCount = headers.featureCount;\n    // Getting vertex attributes such as positions, normals, colors, etc...\n    const {attributes: normalizedVertexAttributes, byteOffset: offset} = normalizeAttributes(\n      arrayBuffer,\n      byteOffset,\n      vertexAttributes,\n      vertexCount,\n      attributesOrder\n    );\n\n    // Getting feature attributes such as featureIds and faceRange\n    const {attributes: normalizedFeatureAttributes} = normalizeAttributes(\n      arrayBuffer,\n      offset,\n      featureAttributes,\n      featureCount,\n      featureAttributeOrder\n    );\n\n    flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes);\n    attributes = concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes);\n  }\n\n  if (\n    !options?.i3s?.coordinateSystem ||\n    options.i3s.coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS\n  ) {\n    const enuMatrix = parsePositions(attributes.position, tileOptions);\n    content.modelMatrix = enuMatrix.invert();\n    content.coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS;\n  } else {\n    content.modelMatrix = getModelMatrix(attributes.position);\n    content.coordinateSystem = COORDINATE_SYSTEM.LNGLAT_OFFSETS;\n  }\n\n  attributes.color = await customizeColors(\n    attributes.color,\n    attributes.id,\n    tileOptions,\n    tilesetOptions,\n    options\n  );\n\n  content.attributes = {\n    positions: attributes.position,\n    normals: attributes.normal,\n    colors: normalizeAttribute(attributes.color), // Normalize from UInt8\n    texCoords: attributes.uv0,\n    uvRegions: normalizeAttribute(attributes.uvRegion || attributes.region) // Normalize from UInt16\n  };\n  content.indices = indices || null;\n\n  if (attributes.id && attributes.id.value) {\n    content.featureIds = attributes.id.value;\n  }\n\n  // Remove undefined attributes\n  for (const attributeIndex in content.attributes) {\n    if (!content.attributes[attributeIndex]) {\n      delete content.attributes[attributeIndex];\n    }\n  }\n\n  content.vertexCount = vertexCount;\n  content.byteLength = contentByteLength;\n\n  return content;\n}\n\n/**\n * Update attributes with metadata from decompressed geometry.\n * @param decompressedGeometry\n * @param attributes\n */\nfunction updateAttributesMetadata(\n  attributes: I3SMeshAttributes,\n  decompressedGeometry: DracoMesh\n): void {\n  for (const key in decompressedGeometry.loaderData.attributes) {\n    const dracoAttribute = decompressedGeometry.loaderData.attributes[key];\n\n    switch (dracoAttribute.name) {\n      case 'POSITION':\n        attributes.position.metadata = dracoAttribute.metadata;\n        break;\n      case 'feature-index':\n        attributes.id.metadata = dracoAttribute.metadata;\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n/**\n * Do concatenation of attribute objects.\n * Done as separate fucntion to avoid ts errors.\n * @param normalizedVertexAttributes\n * @param normalizedFeatureAttributes\n * @returns - result of attributes concatenation.\n */\nfunction concatAttributes(\n  normalizedVertexAttributes: I3SMeshAttributes,\n  normalizedFeatureAttributes: I3SMeshAttributes\n): I3SMeshAttributes {\n  return {...normalizedVertexAttributes, ...normalizedFeatureAttributes};\n}\n\n/**\n * Normalize attribute to range [0..1] . Eg. convert colors buffer from [255,255,255,255] to [1,1,1,1]\n * @param attribute - geometry attribute\n * @returns - geometry attribute in right format\n */\nfunction normalizeAttribute(attribute: I3SMeshAttribute): I3SMeshAttribute {\n  if (!attribute) {\n    return attribute;\n  }\n  attribute.normalized = true;\n  return attribute;\n}\n\nfunction parseHeaders(arrayBuffer: ArrayBuffer, options: I3STilesetOptions) {\n  let byteOffset = 0;\n  // First 8 bytes reserved for header (vertexCount and featurecount)\n  let vertexCount = 0;\n  let featureCount = 0;\n  for (const {property, type} of options.store.defaultGeometrySchema.header) {\n    const TypedArrayTypeHeader = getConstructorForDataFormat(type);\n    switch (property) {\n      case HeaderAttributeProperty.vertexCount:\n        vertexCount = new TypedArrayTypeHeader(arrayBuffer, 0, 4)[0];\n        byteOffset += sizeOf(type);\n        break;\n      case HeaderAttributeProperty.featureCount:\n        featureCount = new TypedArrayTypeHeader(arrayBuffer, 4, 4)[0];\n        byteOffset += sizeOf(type);\n        break;\n      default:\n        break;\n    }\n  }\n\n  return {\n    vertexCount,\n    featureCount,\n    byteOffset\n  };\n}\n\n/* eslint-enable max-statements */\n\nfunction normalizeAttributes(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  vertexAttributes: VertexAttribute | FeatureAttribute,\n  attributeCount: number,\n  attributesOrder: string[]\n) {\n  const attributes: I3SMeshAttributes = {};\n\n  // the order of attributes depend on the order being added to the vertexAttributes object\n  for (const attribute of attributesOrder) {\n    if (vertexAttributes[attribute]) {\n      const {valueType, valuesPerElement}: {valueType: string; valuesPerElement: number} =\n        vertexAttributes[attribute];\n      // protect from arrayBuffer read overunns by NOT assuming node has regions always even though its declared in defaultGeometrySchema.\n      // In i3s 1.6: client is required to decide that based on ./shared resource of the node (materialDefinitions.[Mat_id].params.vertexRegions == true)\n      // In i3s 1.7 the property has been rolled into the 3d scene layer json/node pages.\n      // Code below does not account when the bytelength is actually bigger than\n      // the calculated value (b\\c the tile potentially could have mesh segmentation information).\n      // In those cases tiles without regions could fail or have garbage values.\n      if (\n        byteOffset + attributeCount * valuesPerElement * sizeOf(valueType) <=\n        arrayBuffer.byteLength\n      ) {\n        const buffer = arrayBuffer.slice(byteOffset);\n        let value: TypedArray;\n\n        if (valueType === 'UInt64') {\n          value = parseUint64Values(buffer, attributeCount * valuesPerElement, sizeOf(valueType));\n        } else {\n          const TypedArrayType = getConstructorForDataFormat(valueType);\n          value = new TypedArrayType(buffer, 0, attributeCount * valuesPerElement);\n        }\n\n        attributes[attribute] = {\n          value,\n          type: GL_TYPE_MAP[valueType],\n          size: valuesPerElement\n        };\n\n        switch (attribute) {\n          case 'color':\n            attributes.color.normalized = true;\n            break;\n          case 'position':\n          case 'region':\n          case 'normal':\n          default:\n        }\n\n        byteOffset = byteOffset + attributeCount * valuesPerElement * sizeOf(valueType);\n      } else if (attribute !== 'uv0') {\n        break;\n      }\n    }\n  }\n\n  return {attributes, byteOffset};\n}\n\n/**\n * Parse buffer to return array of uint64 values\n *\n * @param buffer\n * @param elementsCount\n * @returns 64-bit array of values until precision is lost after Number.MAX_SAFE_INTEGER\n */\nfunction parseUint64Values(\n  buffer: ArrayBuffer,\n  elementsCount: number,\n  attributeSize: number\n): Uint32Array {\n  const values: number[] = [];\n  const dataView = new DataView(buffer);\n  let offset = 0;\n\n  for (let index = 0; index < elementsCount; index++) {\n    // split 64-bit number into two 32-bit parts\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    // combine the two 32-bit values\n    const value = left + 2 ** 32 * right;\n\n    values.push(value);\n    offset += attributeSize;\n  }\n\n  return new Uint32Array(values);\n}\n\nfunction parsePositions(attribute: I3SMeshAttribute, options: I3STileOptions): Matrix4 {\n  const mbs = options.mbs;\n  const value = attribute.value;\n  const metadata = attribute.metadata;\n  const enuMatrix = new Matrix4();\n  const cartographicOrigin = new Vector3(mbs[0], mbs[1], mbs[2]);\n  const cartesianOrigin = new Vector3();\n  Ellipsoid.WGS84.cartographicToCartesian(cartographicOrigin, cartesianOrigin);\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin, enuMatrix);\n  attribute.value = offsetsToCartesians(value, metadata, cartographicOrigin);\n\n  return enuMatrix;\n}\n\n/**\n * Converts position coordinates to absolute cartesian coordinates\n * @param vertices - \"position\" attribute data\n * @param metadata - When the geometry is DRACO compressed, contain position attribute's metadata\n *  https://github.com/Esri/i3s-spec/blob/master/docs/1.7/compressedAttributes.cmn.md\n * @param cartographicOrigin - Cartographic origin coordinates\n * @returns - converted \"position\" data\n */\nfunction offsetsToCartesians(\n  vertices: number[] | TypedArray,\n  metadata: any = {},\n  cartographicOrigin: Vector3\n): Float64Array {\n  const positions = new Float64Array(vertices.length);\n  const scaleX = (metadata['i3s-scale_x'] && metadata['i3s-scale_x'].double) || 1;\n  const scaleY = (metadata['i3s-scale_y'] && metadata['i3s-scale_y'].double) || 1;\n  for (let i = 0; i < positions.length; i += 3) {\n    positions[i] = vertices[i] * scaleX + cartographicOrigin.x;\n    positions[i + 1] = vertices[i + 1] * scaleY + cartographicOrigin.y;\n    positions[i + 2] = vertices[i + 2] + cartographicOrigin.z;\n  }\n\n  for (let i = 0; i < positions.length; i += 3) {\n    // @ts-ignore\n    Ellipsoid.WGS84.cartographicToCartesian(positions.subarray(i, i + 3), scratchVector);\n    positions[i] = scratchVector.x;\n    positions[i + 1] = scratchVector.y;\n    positions[i + 2] = scratchVector.z;\n  }\n\n  return positions;\n}\n\n/**\n * Get model matrix for loaded vertices\n * @param positions positions attribute\n * @returns Matrix4 - model matrix for geometry transformation\n */\nfunction getModelMatrix(positions: I3SMeshAttribute): Matrix4 {\n  const metadata = positions.metadata;\n  const scaleX: number = metadata?.['i3s-scale_x']?.double || 1;\n  const scaleY: number = metadata?.['i3s-scale_y']?.double || 1;\n  const modelMatrix = new Matrix4();\n  modelMatrix[0] = scaleX;\n  modelMatrix[5] = scaleY;\n  return modelMatrix;\n}\n\n/**\n * Makes a glTF-compatible PBR material from an I3S material definition\n * @param materialDefinition - i3s material definition\n *  https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n * @param texture - texture image\n * @returns {object}\n */\nfunction makePbrMaterial(materialDefinition?: I3SMaterialDefinition, texture?: TileContentTexture) {\n  let pbrMaterial;\n  if (materialDefinition) {\n    pbrMaterial = {\n      ...materialDefinition,\n      pbrMetallicRoughness: materialDefinition.pbrMetallicRoughness\n        ? {...materialDefinition.pbrMetallicRoughness}\n        : {baseColorFactor: [255, 255, 255, 255]}\n    };\n  } else {\n    pbrMaterial = {\n      pbrMetallicRoughness: {}\n    };\n    if (texture) {\n      pbrMaterial.pbrMetallicRoughness.baseColorTexture = {texCoord: 0};\n    } else {\n      pbrMaterial.pbrMetallicRoughness.baseColorFactor = [255, 255, 255, 255];\n    }\n  }\n\n  // Set default 0.25 per spec https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n  pbrMaterial.alphaCutoff = pbrMaterial.alphaCutoff || 0.25;\n\n  if (pbrMaterial.alphaMode) {\n    // I3S contain alphaMode in lowerCase\n    pbrMaterial.alphaMode = pbrMaterial.alphaMode.toUpperCase();\n  }\n\n  // Convert colors from [255,255,255,255] to [1,1,1,1]\n  if (pbrMaterial.emissiveFactor) {\n    pbrMaterial.emissiveFactor = convertColorFormat(pbrMaterial.emissiveFactor);\n  }\n  if (pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorFactor) {\n    pbrMaterial.pbrMetallicRoughness.baseColorFactor = convertColorFormat(\n      pbrMaterial.pbrMetallicRoughness.baseColorFactor\n    );\n  }\n\n  if (texture) {\n    setMaterialTexture(pbrMaterial, texture);\n  }\n\n  return pbrMaterial;\n}\n\n/**\n * Convert color from [255,255,255,255] to [1,1,1,1]\n * @param colorFactor - color array\n * @returns - new color array\n */\nfunction convertColorFormat(colorFactor: number[]): number[] {\n  const normalizedColor = [...colorFactor];\n  for (let index = 0; index < colorFactor.length; index++) {\n    normalizedColor[index] = colorFactor[index] / 255;\n  }\n  return normalizedColor;\n}\n\n/**\n * Set texture in PBR material\n * @param {object} material - i3s material definition\n * @param image - texture image\n * @returns\n */\nfunction setMaterialTexture(material, image: TileContentTexture): void {\n  const texture = {source: {image}};\n  // I3SLoader now support loading only one texture. This elseif sequence will assign this texture to one of\n  // properties defined in materialDefinition\n  if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture) {\n    material.pbrMetallicRoughness.baseColorTexture = {\n      ...material.pbrMetallicRoughness.baseColorTexture,\n      texture\n    };\n  } else if (material.emissiveTexture) {\n    material.emissiveTexture = {...material.emissiveTexture, texture};\n  } else if (\n    material.pbrMetallicRoughness &&\n    material.pbrMetallicRoughness.metallicRoughnessTexture\n  ) {\n    material.pbrMetallicRoughness.metallicRoughnessTexture = {\n      ...material.pbrMetallicRoughness.metallicRoughnessTexture,\n      texture\n    };\n  } else if (material.normalTexture) {\n    material.normalTexture = {...material.normalTexture, texture};\n  } else if (material.occlusionTexture) {\n    material.occlusionTexture = {...material.occlusionTexture, texture};\n  }\n}\n\n/**\n * Flatten feature ids using face ranges\n * @param normalizedFeatureAttributes\n * @returns\n */\nfunction flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes: I3SMeshAttributes): void {\n  const {id, faceRange} = normalizedFeatureAttributes;\n\n  if (!id || !faceRange) {\n    return;\n  }\n\n  const featureIds = id.value;\n  const range = faceRange.value;\n  const featureIdsLength = range[range.length - 1] + 1;\n  const orderedFeatureIndices = new Uint32Array(featureIdsLength * 3);\n\n  let featureIndex = 0;\n  let startIndex = 0;\n\n  for (let index = 1; index < range.length; index += 2) {\n    const fillId = Number(featureIds[featureIndex]);\n    const endValue = range[index];\n    const prevValue = range[index - 1];\n    const trianglesCount = endValue - prevValue + 1;\n    const endIndex = startIndex + trianglesCount * 3;\n\n    orderedFeatureIndices.fill(fillId, startIndex, endIndex);\n\n    featureIndex++;\n    startIndex = endIndex;\n  }\n\n  normalizedFeatureAttributes.id.value = orderedFeatureIndices;\n}\n\n/**\n * Flatten feature ids using featureIndices\n * @param attributes\n * @param featureIds\n * @returns\n */\nfunction flattenFeatureIdsByFeatureIndices(\n  attributes: I3SMeshAttributes,\n  featureIds: Int32Array\n): void {\n  const featureIndices = attributes.id.value;\n  const result = new Float32Array(featureIndices.length);\n\n  for (let index = 0; index < featureIndices.length; index++) {\n    result[index] = featureIds[featureIndices[index]];\n  }\n\n  attributes.id.value = result;\n}\n\n/**\n * Flatten feature ids using featureIndices\n * @param featureIndex\n * @returns\n */\nfunction getFeatureIdsFromFeatureIndexMetadata(\n  featureIndex: I3SMeshAttribute\n): Int32Array | undefined {\n  return featureIndex?.metadata?.['i3s-feature-ids']?.intArray;\n}\n"],"mappings":"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"}