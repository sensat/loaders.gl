{"version":3,"file":"i3s-nodepages-tiles.js","names":["load","getSupportedGPUTextureFormats","selectSupportedBasisFormat","I3SNodePageLoader","normalizeTileNonUrlData","getUrlWithToken","generateTilesetAttributeUrls","I3SNodePagesTiles","constructor","tileset","options","_tileset$nodePages","_tileset$nodePages2","_defineProperty","nodesPerPage","nodePages","lodSelectionMetricType","nodesInNodePages","initSelectedFormatsForTextureDefinitions","getNodeById","id","pageIndex","Math","floor","pendingNodePages","_this$options$i3s","nodePageUrl","concat","url","i3s","token","status","promise","nodes","length","nodeIndex","formTileFromNodePages","node","children","childNodesPromises","child","push","childNodes","Promise","all","childNode","index","toString","obb","contentUrl","textureUrl","materialDefinition","textureFormat","attributeUrls","isDracoGeometry","mesh","isDracoGeometryResult","geometry","getContentUrl","textureData","nodeMaterialDefinition","getInformationFromMaterial","material","format","name","resource","attributeStorageInfo","attribute","lodSelection","getLodSelection","textureLoaderOptions","meshGeometryData","result","geometryDefinition","geometryDefinitions","definition","geometryIndex","useDracoGeometry","geometryBuffers","findIndex","buffer","compressedAttributes","encoding","Boolean","metricType","maxError","sqrt","lodThreshold","PI","informationFromMaterial","_this$tileset$materia","materialDefinitions","_materialDefinition$p","_materialDefinition$p2","textureSetDefinitionIndex","pbrMetallicRoughness","baseColorTexture","textureSetDefinitionId","textureDefinitionsSelectedFormats","possibleI3sFormats","getSupportedTextureFormats","textureSetDefinitions","textureSetDefinition","formats","selectedFormat","i3sFormat","find","value","basis","containerFormat","module","useCompressedTextures","supportedCompressedFormats","has"],"sources":["../../../../src/lib/helpers/i3s-nodepages-tiles.ts"],"sourcesContent":["import {load} from '@loaders.gl/core';\nimport {getSupportedGPUTextureFormats, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport {I3SNodePageLoader} from '../../i3s-node-page-loader';\nimport {normalizeTileNonUrlData} from '../parsers/parse-i3s';\nimport {getUrlWithToken, generateTilesetAttributeUrls} from '../utils/url-utils';\nimport type {LoaderOptions} from '@loaders.gl/loader-utils';\nimport {\n  I3STilesetHeader,\n  LodSelection,\n  NodePage,\n  NodeInPage,\n  Obb,\n  MeshMaterial,\n  I3SMaterialDefinition,\n  I3STextureFormat,\n  MeshGeometry,\n  I3STileHeader\n} from '../../types';\n\n/**\n * class I3SNodePagesTiles - loads nodePages and form i3s tiles from them\n */\nexport default class I3SNodePagesTiles {\n  tileset: I3STilesetHeader;\n  nodePages: NodePage[] = [];\n  pendingNodePages: {promise: Promise<NodePage>; status: 'Pending' | 'Done'}[] = [];\n  nodesPerPage: number;\n  options: LoaderOptions;\n  lodSelectionMetricType?: string;\n  textureDefinitionsSelectedFormats: ({format: I3STextureFormat; name: string} | null)[] = [];\n  nodesInNodePages: number;\n  private textureLoaderOptions: {[key: string]: any} = {};\n\n  /**\n   * @constructs\n   * Create a I3SNodePagesTiles instance.\n   * @param tileset - i3s tileset header ('layers/0')\n   * @param options - i3s loader options\n   */\n  constructor(tileset: I3STilesetHeader, options: LoaderOptions) {\n    this.tileset = {...tileset}; // spread the tileset to avoid circular reference\n    this.nodesPerPage = tileset.nodePages?.nodesPerPage || 64;\n    this.lodSelectionMetricType = tileset.nodePages?.lodSelectionMetricType;\n    this.options = options;\n    this.nodesInNodePages = 0;\n\n    this.initSelectedFormatsForTextureDefinitions(tileset);\n  }\n\n  /**\n   * Loads some nodePage and return a particular node from it\n   * @param id - id of node through all node pages\n   */\n  async getNodeById(id: number): Promise<NodeInPage> {\n    const pageIndex = Math.floor(id / this.nodesPerPage);\n    if (!this.nodePages[pageIndex] && !this.pendingNodePages[pageIndex]) {\n      const nodePageUrl = getUrlWithToken(\n        `${this.tileset.url}/nodepages/${pageIndex}`,\n        // @ts-expect-error this.options is not properly typed\n        this.options.i3s?.token\n      );\n      this.pendingNodePages[pageIndex] = {\n        status: 'Pending',\n        promise: load(nodePageUrl, I3SNodePageLoader, this.options)\n      };\n      this.nodePages[pageIndex] = await this.pendingNodePages[pageIndex].promise;\n      this.nodesInNodePages += this.nodePages[pageIndex].nodes.length;\n      this.pendingNodePages[pageIndex].status = 'Done';\n    }\n    if (this.pendingNodePages[pageIndex].status === 'Pending') {\n      this.nodePages[pageIndex] = await this.pendingNodePages[pageIndex].promise;\n    }\n    const nodeIndex = id % this.nodesPerPage;\n    return this.nodePages[pageIndex].nodes[nodeIndex];\n  }\n\n  /**\n   * Forms tile header using node and tileset data\n   * @param id - id of node through all node pages\n   */\n  // eslint-disable-next-line complexity, max-statements\n  async formTileFromNodePages(id: number): Promise<I3STileHeader> {\n    const node: NodeInPage = await this.getNodeById(id);\n    const children: {id: string; obb: Obb}[] = [];\n    const childNodesPromises: Promise<NodeInPage>[] = [];\n    for (const child of node.children || []) {\n      childNodesPromises.push(this.getNodeById(child));\n    }\n\n    const childNodes = await Promise.all(childNodesPromises);\n    for (const childNode of childNodes) {\n      children.push({\n        id: childNode.index.toString(),\n        obb: childNode.obb\n      });\n    }\n\n    let contentUrl: string | undefined;\n    let textureUrl: string | undefined;\n    let materialDefinition: I3SMaterialDefinition | undefined;\n    let textureFormat: I3STextureFormat = 'jpg';\n    let attributeUrls: string[] = [];\n    let isDracoGeometry: boolean = false;\n\n    if (node && node.mesh) {\n      // Get geometry resource URL and type (compressed / non-compressed)\n      const {url, isDracoGeometry: isDracoGeometryResult} = (node.mesh.geometry &&\n        this.getContentUrl(node.mesh.geometry)) || {isDracoGeometry: false};\n      contentUrl = url;\n      isDracoGeometry = isDracoGeometryResult;\n\n      const {textureData, materialDefinition: nodeMaterialDefinition} =\n        this.getInformationFromMaterial(node.mesh.material);\n      materialDefinition = nodeMaterialDefinition;\n      textureFormat = textureData.format || textureFormat;\n      if (textureData.name) {\n        textureUrl = `${this.tileset.url}/nodes/${node.mesh.material.resource}/textures/${textureData.name}`;\n      }\n\n      if (this.tileset.attributeStorageInfo) {\n        attributeUrls = generateTilesetAttributeUrls(this.tileset, node.mesh.attribute.resource);\n      }\n    }\n\n    const lodSelection = this.getLodSelection(node);\n\n    return normalizeTileNonUrlData({\n      id: id.toString(),\n      lodSelection,\n      obb: node.obb,\n      contentUrl,\n      textureUrl,\n      attributeUrls,\n      materialDefinition,\n      textureFormat,\n      textureLoaderOptions: this.textureLoaderOptions,\n      children,\n      isDracoGeometry\n    });\n  }\n\n  /**\n   * Forms url and type of geometry resource by nodepage's data and `geometryDefinitions` in the tileset\n   * @param - data about the node's mesh from the nodepage\n   * @returns -\n   *   {string} url - url to the geometry resource\n   *   {boolean} isDracoGeometry - whether the geometry resource contain DRACO compressed geometry\n   */\n  private getContentUrl(meshGeometryData: MeshGeometry) {\n    let result: {url: string; isDracoGeometry: boolean} | null = null;\n    // @ts-ignore\n    const geometryDefinition = this.tileset.geometryDefinitions[meshGeometryData.definition];\n    let geometryIndex = -1;\n    // Try to find DRACO geometryDefinition of `useDracoGeometry` option is set\n    // @ts-expect-error this.options is not properly typed\n    if (this.options.i3s && this.options.i3s.useDracoGeometry) {\n      geometryIndex = geometryDefinition.geometryBuffers.findIndex(\n        (buffer) => buffer.compressedAttributes && buffer.compressedAttributes.encoding === 'draco'\n      );\n    }\n    // If DRACO geometry is not applicable try to select non-compressed geometry\n    if (geometryIndex === -1) {\n      geometryIndex = geometryDefinition.geometryBuffers.findIndex(\n        (buffer) => !buffer.compressedAttributes\n      );\n    }\n    if (geometryIndex !== -1) {\n      const isDracoGeometry = Boolean(\n        geometryDefinition.geometryBuffers[geometryIndex].compressedAttributes\n      );\n      result = {\n        url: `${this.tileset.url}/nodes/${meshGeometryData.resource}/geometries/${geometryIndex}`,\n        isDracoGeometry\n      };\n    }\n    return result;\n  }\n\n  /**\n   * Forms 1.6 compatible LOD selection object from a nodepage's node data\n   * @param node - a node from nodepage\n   * @returns- Array of LodSelection\n   */\n  private getLodSelection(node: NodeInPage): LodSelection[] {\n    const lodSelection: LodSelection[] = [];\n    if (this.lodSelectionMetricType === 'maxScreenThresholdSQ') {\n      lodSelection.push({\n        metricType: 'maxScreenThreshold',\n        // @ts-ignore\n        maxError: Math.sqrt(node.lodThreshold / (Math.PI * 0.25))\n      });\n    }\n    lodSelection.push({\n      metricType: this.lodSelectionMetricType,\n      // @ts-ignore\n      maxError: node.lodThreshold\n    });\n    return lodSelection;\n  }\n\n  /**\n   * Returns information about texture and material from `materialDefinitions`\n   * @param material - material data from nodepage\n   * @returns - Couple {textureData, materialDefinition}\n   * {string} textureData.name - path name of the texture\n   * {string} textureData.format - format of the texture\n   * materialDefinition - PBR-like material definition from `materialDefinitions`\n   */\n  private getInformationFromMaterial(material: MeshMaterial) {\n    const informationFromMaterial: {\n      textureData: {name: string | null; format?: I3STextureFormat};\n      materialDefinition?: I3SMaterialDefinition;\n    } = {textureData: {name: null}};\n\n    if (material) {\n      const materialDefinition = this.tileset.materialDefinitions?.[material.definition];\n      if (materialDefinition) {\n        informationFromMaterial.materialDefinition = materialDefinition;\n        const textureSetDefinitionIndex =\n          materialDefinition?.pbrMetallicRoughness?.baseColorTexture?.textureSetDefinitionId;\n\n        if (typeof textureSetDefinitionIndex === 'number') {\n          informationFromMaterial.textureData =\n            this.textureDefinitionsSelectedFormats[textureSetDefinitionIndex] ||\n            informationFromMaterial.textureData;\n        }\n      }\n    }\n    return informationFromMaterial;\n  }\n\n  /**\n   * Sets preferable and supported format for each textureDefinition of the tileset\n   * @param tileset - I3S layer data\n   * @returns\n   */\n  private initSelectedFormatsForTextureDefinitions(tileset: I3STilesetHeader): void {\n    this.textureDefinitionsSelectedFormats = [];\n    const possibleI3sFormats = this.getSupportedTextureFormats();\n    const textureSetDefinitions = tileset.textureSetDefinitions || [];\n    for (const textureSetDefinition of textureSetDefinitions) {\n      const formats = (textureSetDefinition && textureSetDefinition.formats) || [];\n      let selectedFormat: {name: string; format: I3STextureFormat} | null = null;\n      for (const i3sFormat of possibleI3sFormats) {\n        const format = formats.find((value) => value.format === i3sFormat);\n        if (format) {\n          selectedFormat = format;\n          break;\n        }\n      }\n      // For I3S 1.8 need to define basis target format to decode\n      if (selectedFormat && selectedFormat.format === 'ktx2') {\n        this.textureLoaderOptions.basis = {\n          format: selectSupportedBasisFormat(),\n          containerFormat: 'ktx2',\n          module: 'encoder'\n        };\n      }\n\n      this.textureDefinitionsSelectedFormats.push(selectedFormat);\n    }\n  }\n\n  /**\n   * Returns the array of supported texture format\n   * @returns list of format strings\n   */\n  private getSupportedTextureFormats(): I3STextureFormat[] {\n    const formats: I3STextureFormat[] = [];\n    // @ts-expect-error this.options is not properly typed\n    if (!this.options.i3s || this.options.i3s.useCompressedTextures) {\n      // I3S 1.7 selection\n      const supportedCompressedFormats = getSupportedGPUTextureFormats();\n      // List of possible in i3s formats:\n      // https://github.com/Esri/i3s-spec/blob/master/docs/1.7/textureSetDefinitionFormat.cmn.md\n      if (supportedCompressedFormats.has('etc2')) {\n        formats.push('ktx-etc2');\n      }\n      if (supportedCompressedFormats.has('dxt')) {\n        formats.push('dds');\n      }\n\n      // I3S 1.8 selection\n      // ktx2 wraps basis texture which at the edge case can be decoded as uncompressed image\n      formats.push('ktx2');\n    }\n\n    formats.push('jpg');\n    formats.push('png');\n    return formats;\n  }\n}\n"],"mappings":"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"}