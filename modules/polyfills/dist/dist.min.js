(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // src/utils/globals.ts
  var isBrowser, globals, global_;
  var init_globals = __esm({
    "src/utils/globals.ts"() {
      isBrowser = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
      globals = {
        self: typeof self !== "undefined" && self,
        window: typeof window !== "undefined" && window,
        global: typeof global !== "undefined" && global
      };
      global_ = globals.global || globals.self || globals.window;
    }
  });

  // src/lib/encoding-indexes.ts
  var encoding_indexes_default;
  var init_encoding_indexes = __esm({
    "src/lib/encoding-indexes.ts"() {
      encoding_indexes_default = {
        "ibm866": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 9617, 9618, 9619, 9474, 9508, 9569, 9570, 9558, 9557, 9571, 9553, 9559, 9565, 9564, 9563, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 9566, 9567, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 9575, 9576, 9572, 9573, 9561, 9560, 9554, 9555, 9579, 9578, 9496, 9484, 9608, 9604, 9612, 9616, 9600, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1025, 1105, 1028, 1108, 1031, 1111, 1038, 1118, 176, 8729, 183, 8730, 8470, 164, 9632, 160],
        "iso-8859-2": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 728, 321, 164, 317, 346, 167, 168, 352, 350, 356, 377, 173, 381, 379, 176, 261, 731, 322, 180, 318, 347, 711, 184, 353, 351, 357, 378, 733, 382, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
        "iso-8859-3": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 294, 728, 163, 164, null, 292, 167, 168, 304, 350, 286, 308, 173, null, 379, 176, 295, 178, 179, 180, 181, 293, 183, 184, 305, 351, 287, 309, 189, null, 380, 192, 193, 194, null, 196, 266, 264, 199, 200, 201, 202, 203, 204, 205, 206, 207, null, 209, 210, 211, 212, 288, 214, 215, 284, 217, 218, 219, 220, 364, 348, 223, 224, 225, 226, null, 228, 267, 265, 231, 232, 233, 234, 235, 236, 237, 238, 239, null, 241, 242, 243, 244, 289, 246, 247, 285, 249, 250, 251, 252, 365, 349, 729],
        "iso-8859-4": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 312, 342, 164, 296, 315, 167, 168, 352, 274, 290, 358, 173, 381, 175, 176, 261, 731, 343, 180, 297, 316, 711, 184, 353, 275, 291, 359, 330, 382, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 298, 272, 325, 332, 310, 212, 213, 214, 215, 216, 370, 218, 219, 220, 360, 362, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 299, 273, 326, 333, 311, 244, 245, 246, 247, 248, 371, 250, 251, 252, 361, 363, 729],
        "iso-8859-5": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 173, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 8470, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 167, 1118, 1119],
        "iso-8859-6": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, null, null, 164, null, null, null, null, null, null, null, 1548, 173, null, null, null, null, null, null, null, null, null, null, null, null, null, 1563, null, null, null, 1567, null, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, null, null, null, null, null, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "iso-8859-7": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8216, 8217, 163, 8364, 8367, 166, 167, 168, 169, 890, 171, 172, 173, null, 8213, 176, 177, 178, 179, 900, 901, 902, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
        "iso-8859-8": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, 162, 163, 164, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 8215, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
        "iso-8859-10": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 274, 290, 298, 296, 310, 167, 315, 272, 352, 358, 381, 173, 362, 330, 176, 261, 275, 291, 299, 297, 311, 183, 316, 273, 353, 359, 382, 8213, 363, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 207, 208, 325, 332, 211, 212, 213, 214, 360, 216, 370, 218, 219, 220, 221, 222, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 239, 240, 326, 333, 243, 244, 245, 246, 361, 248, 371, 250, 251, 252, 253, 254, 312],
        "iso-8859-13": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8221, 162, 163, 164, 8222, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 8220, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 8217],
        "iso-8859-14": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 7682, 7683, 163, 266, 267, 7690, 167, 7808, 169, 7810, 7691, 7922, 173, 174, 376, 7710, 7711, 288, 289, 7744, 7745, 182, 7766, 7809, 7767, 7811, 7776, 7923, 7812, 7813, 7777, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 372, 209, 210, 211, 212, 213, 214, 7786, 216, 217, 218, 219, 220, 221, 374, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 373, 241, 242, 243, 244, 245, 246, 7787, 248, 249, 250, 251, 252, 253, 375, 255],
        "iso-8859-15": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 8364, 165, 352, 167, 353, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 381, 181, 182, 183, 382, 185, 186, 187, 338, 339, 376, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
        "iso-8859-16": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 261, 321, 8364, 8222, 352, 167, 353, 169, 536, 171, 377, 173, 378, 379, 176, 177, 268, 322, 381, 8221, 182, 183, 382, 269, 537, 187, 338, 339, 376, 380, 192, 193, 194, 258, 196, 262, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 272, 323, 210, 211, 212, 336, 214, 346, 368, 217, 218, 219, 220, 280, 538, 223, 224, 225, 226, 259, 228, 263, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 273, 324, 242, 243, 244, 337, 246, 347, 369, 249, 250, 251, 252, 281, 539, 255],
        "koi8-r": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 1025, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
        "koi8-u": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 1108, 9556, 1110, 1111, 9559, 9560, 9561, 9562, 9563, 1169, 1118, 9566, 9567, 9568, 9569, 1025, 1028, 9571, 1030, 1031, 9574, 9575, 9576, 9577, 9578, 1168, 1038, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
        "macintosh": [196, 197, 199, 201, 209, 214, 220, 225, 224, 226, 228, 227, 229, 231, 233, 232, 234, 235, 237, 236, 238, 239, 241, 243, 242, 244, 246, 245, 250, 249, 251, 252, 8224, 176, 162, 163, 167, 8226, 182, 223, 174, 169, 8482, 180, 168, 8800, 198, 216, 8734, 177, 8804, 8805, 165, 181, 8706, 8721, 8719, 960, 8747, 170, 186, 937, 230, 248, 191, 161, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 192, 195, 213, 338, 339, 8211, 8212, 8220, 8221, 8216, 8217, 247, 9674, 255, 376, 8260, 8364, 8249, 8250, 64257, 64258, 8225, 183, 8218, 8222, 8240, 194, 202, 193, 203, 200, 205, 206, 207, 204, 211, 212, 63743, 210, 218, 219, 217, 305, 710, 732, 175, 728, 729, 730, 184, 733, 731, 711],
        "windows-874": [8364, 129, 130, 131, 132, 8230, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 153, 154, 155, 156, 157, 158, 159, 160, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, null, null, null, null, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, null, null, null, null],
        "windows-1250": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 352, 8249, 346, 356, 381, 377, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 353, 8250, 347, 357, 382, 378, 160, 711, 728, 321, 164, 260, 166, 167, 168, 169, 350, 171, 172, 173, 174, 379, 176, 177, 731, 322, 180, 181, 182, 183, 184, 261, 351, 187, 317, 733, 318, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
        "windows-1251": [1026, 1027, 8218, 1107, 8222, 8230, 8224, 8225, 8364, 8240, 1033, 8249, 1034, 1036, 1035, 1039, 1106, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 1113, 8250, 1114, 1116, 1115, 1119, 160, 1038, 1118, 1032, 164, 1168, 166, 167, 1025, 169, 1028, 171, 172, 173, 174, 1031, 176, 177, 1030, 1110, 1169, 181, 182, 183, 1105, 8470, 1108, 187, 1112, 1029, 1109, 1111, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103],
        "windows-1252": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
        "windows-1253": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 157, 158, 159, 160, 901, 902, 163, 164, 165, 166, 167, 168, 169, null, 171, 172, 173, 174, 8213, 176, 177, 178, 179, 900, 181, 182, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
        "windows-1254": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 286, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 304, 350, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 287, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 305, 351, 255],
        "windows-1255": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 156, 157, 158, 159, 160, 161, 162, 163, 8362, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, 191, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1520, 1521, 1522, 1523, 1524, null, null, null, null, null, null, null, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
        "windows-1256": [8364, 1662, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 1657, 8249, 338, 1670, 1688, 1672, 1711, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 1705, 8482, 1681, 8250, 339, 8204, 8205, 1722, 160, 1548, 162, 163, 164, 165, 166, 167, 168, 169, 1726, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 1563, 187, 188, 189, 190, 1567, 1729, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 215, 1591, 1592, 1593, 1594, 1600, 1601, 1602, 1603, 224, 1604, 226, 1605, 1606, 1607, 1608, 231, 232, 233, 234, 235, 1609, 1610, 238, 239, 1611, 1612, 1613, 1614, 244, 1615, 1616, 247, 1617, 249, 1618, 251, 252, 8206, 8207, 1746],
        "windows-1257": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 168, 711, 184, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 175, 731, 159, 160, null, 162, 163, 164, null, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 180, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 729],
        "windows-1258": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 258, 196, 197, 198, 199, 200, 201, 202, 203, 768, 205, 206, 207, 272, 209, 777, 211, 212, 416, 214, 215, 216, 217, 218, 219, 220, 431, 771, 223, 224, 225, 226, 259, 228, 229, 230, 231, 232, 233, 234, 235, 769, 237, 238, 239, 273, 241, 803, 243, 244, 417, 246, 247, 248, 249, 250, 251, 252, 432, 8363, 255],
        "x-mac-cyrillic": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 8224, 176, 1168, 163, 167, 8226, 182, 1030, 174, 169, 8482, 1026, 1106, 8800, 1027, 1107, 8734, 177, 8804, 8805, 1110, 181, 1169, 1032, 1028, 1108, 1031, 1111, 1033, 1113, 1034, 1114, 1112, 1029, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 1035, 1115, 1036, 1116, 1109, 8211, 8212, 8220, 8221, 8216, 8217, 247, 8222, 1038, 1118, 1039, 1119, 8470, 1025, 1105, 1103, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 8364]
      };
    }
  });

  // src/lib/encoding.ts
  function inRange(a, min, max) {
    return min <= a && a <= max;
  }
  function includes(array, item) {
    return array.indexOf(item) !== -1;
  }
  function ToDictionary(o) {
    if (o === void 0)
      return {};
    if (o === Object(o))
      return o;
    throw TypeError("Could not convert argument to dictionary");
  }
  function stringToCodePoints(string) {
    var s = String(string);
    var n = s.length;
    var i = 0;
    var u = [];
    while (i < n) {
      var c = s.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        u.push(c);
      } else if (56320 <= c && c <= 57343) {
        u.push(65533);
      } else if (55296 <= c && c <= 56319) {
        if (i === n - 1) {
          u.push(65533);
        } else {
          var d = s.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            var a = c & 1023;
            var b = d & 1023;
            u.push(65536 + (a << 10) + b);
            i += 1;
          } else {
            u.push(65533);
          }
        }
      }
      i += 1;
    }
    return u;
  }
  function codePointsToString(code_points) {
    var s = "";
    for (var i = 0; i < code_points.length; ++i) {
      var cp = code_points[i];
      if (cp <= 65535) {
        s += String.fromCharCode(cp);
      } else {
        cp -= 65536;
        s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
      }
    }
    return s;
  }
  function isASCIIByte(a) {
    return 0 <= a && a <= 127;
  }
  function Stream(tokens) {
    this.tokens = [].slice.call(tokens);
    this.tokens.reverse();
  }
  function decoderError(fatal, opt_code_point) {
    if (fatal)
      throw TypeError("Decoder error");
    return opt_code_point || 65533;
  }
  function encoderError(code_point) {
    throw TypeError("The code point " + code_point + " could not be encoded.");
  }
  function Decoder() {
  }
  function Encoder() {
  }
  function getEncoding(label) {
    label = String(label).trim().toLowerCase();
    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
      return label_to_encoding[label];
    }
    return null;
  }
  function indexCodePointFor(pointer, index2) {
    if (!index2)
      return null;
    return index2[pointer] || null;
  }
  function indexPointerFor(code_point, index2) {
    var pointer = index2.indexOf(code_point);
    return pointer === -1 ? null : pointer;
  }
  function index(name) {
    if (!("encoding-indexes" in global)) {
      throw Error("Indexes missing. Did you forget to include encoding-indexes.js first?");
    }
    return global["encoding-indexes"][name];
  }
  function indexGB18030RangesCodePointFor(pointer) {
    if (pointer > 39419 && pointer < 189e3 || pointer > 1237575)
      return null;
    if (pointer === 7457)
      return 59335;
    var offset = 0;
    var code_point_offset = 0;
    var idx = index("gb18030-ranges");
    var i;
    for (i = 0; i < idx.length; ++i) {
      var entry = idx[i];
      if (entry[0] <= pointer) {
        offset = entry[0];
        code_point_offset = entry[1];
      } else {
        break;
      }
    }
    return code_point_offset + pointer - offset;
  }
  function indexGB18030RangesPointerFor(code_point) {
    if (code_point === 59335)
      return 7457;
    var offset = 0;
    var pointer_offset = 0;
    var idx = index("gb18030-ranges");
    var i;
    for (i = 0; i < idx.length; ++i) {
      var entry = idx[i];
      if (entry[1] <= code_point) {
        offset = entry[1];
        pointer_offset = entry[0];
      } else {
        break;
      }
    }
    return pointer_offset + code_point - offset;
  }
  function indexShiftJISPointerFor(code_point) {
    shift_jis_index = shift_jis_index || index("jis0208").map(function(code_point2, pointer) {
      return inRange(pointer, 8272, 8835) ? null : code_point2;
    });
    var index_ = shift_jis_index;
    return index_.indexOf(code_point);
  }
  function indexBig5PointerFor(code_point) {
    big5_index_no_hkscs = big5_index_no_hkscs || index("big5").map(function(code_point2, pointer) {
      return pointer < (161 - 129) * 157 ? null : code_point2;
    });
    var index_ = big5_index_no_hkscs;
    if (code_point === 9552 || code_point === 9566 || code_point === 9569 || code_point === 9578 || code_point === 21313 || code_point === 21317) {
      return index_.lastIndexOf(code_point);
    }
    return indexPointerFor(code_point, index_);
  }
  function TextDecoder(label, options) {
    if (!(this instanceof TextDecoder))
      throw TypeError("Called as a function. Did you forget 'new'?");
    label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
    options = ToDictionary(options);
    this._encoding = null;
    this._decoder = null;
    this._ignoreBOM = false;
    this._BOMseen = false;
    this._error_mode = "replacement";
    this._do_not_flush = false;
    var encoding = getEncoding(label);
    if (encoding === null || encoding.name === "replacement")
      throw RangeError("Unknown encoding: " + label);
    if (!decoders[encoding.name]) {
      throw Error("Decoder not present. Did you forget to include encoding-indexes.js first?");
    }
    var dec = this;
    dec._encoding = encoding;
    if (Boolean(options["fatal"]))
      dec._error_mode = "fatal";
    if (Boolean(options["ignoreBOM"]))
      dec._ignoreBOM = true;
    if (!Object.defineProperty) {
      this.encoding = dec._encoding.name.toLowerCase();
      this.fatal = dec._error_mode === "fatal";
      this.ignoreBOM = dec._ignoreBOM;
    }
    return dec;
  }
  function TextEncoder(label, options) {
    if (!(this instanceof TextEncoder))
      throw TypeError("Called as a function. Did you forget 'new'?");
    options = ToDictionary(options);
    this._encoding = null;
    this._encoder = null;
    this._do_not_flush = false;
    this._fatal = Boolean(options["fatal"]) ? "fatal" : "replacement";
    var enc = this;
    if (Boolean(options["NONSTANDARD_allowLegacyEncoding"])) {
      label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
      var encoding = getEncoding(label);
      if (encoding === null || encoding.name === "replacement")
        throw RangeError("Unknown encoding: " + label);
      if (!encoders[encoding.name]) {
        throw Error("Encoder not present. Did you forget to include encoding-indexes.js first?");
      }
      enc._encoding = encoding;
    } else {
      enc._encoding = getEncoding("utf-8");
      if (label !== void 0 && "console" in global) {
        console.warn("TextEncoder constructor called with encoding label, which is ignored.");
      }
    }
    if (!Object.defineProperty)
      this.encoding = enc._encoding.name.toLowerCase();
    return enc;
  }
  function UTF8Decoder(options) {
    var fatal = options.fatal;
    var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal);
      }
      if (bite === end_of_stream)
        return finished;
      if (utf8_bytes_needed === 0) {
        if (inRange(bite, 0, 127)) {
          return bite;
        } else if (inRange(bite, 194, 223)) {
          utf8_bytes_needed = 1;
          utf8_code_point = bite & 31;
        } else if (inRange(bite, 224, 239)) {
          if (bite === 224)
            utf8_lower_boundary = 160;
          if (bite === 237)
            utf8_upper_boundary = 159;
          utf8_bytes_needed = 2;
          utf8_code_point = bite & 15;
        } else if (inRange(bite, 240, 244)) {
          if (bite === 240)
            utf8_lower_boundary = 144;
          if (bite === 244)
            utf8_upper_boundary = 143;
          utf8_bytes_needed = 3;
          utf8_code_point = bite & 7;
        } else {
          return decoderError(fatal);
        }
        return null;
      }
      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 128;
        utf8_upper_boundary = 191;
        stream.prepend(bite);
        return decoderError(fatal);
      }
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      utf8_code_point = utf8_code_point << 6 | bite & 63;
      utf8_bytes_seen += 1;
      if (utf8_bytes_seen !== utf8_bytes_needed)
        return null;
      var code_point = utf8_code_point;
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      return code_point;
    };
  }
  function UTF8Encoder(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point))
        return code_point;
      var count, offset;
      if (inRange(code_point, 128, 2047)) {
        count = 1;
        offset = 192;
      } else if (inRange(code_point, 2048, 65535)) {
        count = 2;
        offset = 224;
      } else if (inRange(code_point, 65536, 1114111)) {
        count = 3;
        offset = 240;
      }
      var bytes = [(code_point >> 6 * count) + offset];
      while (count > 0) {
        var temp = code_point >> 6 * (count - 1);
        bytes.push(128 | temp & 63);
        count -= 1;
      }
      return bytes;
    };
  }
  function SingleByteDecoder(index2, options) {
    var fatal = options.fatal;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream)
        return finished;
      if (isASCIIByte(bite))
        return bite;
      var code_point = index2[bite - 128];
      if (code_point === null)
        return decoderError(fatal);
      return code_point;
    };
  }
  function SingleByteEncoder(index2, options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point))
        return code_point;
      var pointer = indexPointerFor(code_point, index2);
      if (pointer === null)
        encoderError(code_point);
      return pointer + 128;
    };
  }
  function GB18030Decoder(options) {
    var fatal = options.fatal;
    var gb18030_first = 0, gb18030_second = 0, gb18030_third = 0;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && gb18030_first === 0 && gb18030_second === 0 && gb18030_third === 0) {
        return finished;
      }
      if (bite === end_of_stream && (gb18030_first !== 0 || gb18030_second !== 0 || gb18030_third !== 0)) {
        gb18030_first = 0;
        gb18030_second = 0;
        gb18030_third = 0;
        decoderError(fatal);
      }
      var code_point;
      if (gb18030_third !== 0) {
        code_point = null;
        if (inRange(bite, 48, 57)) {
          code_point = indexGB18030RangesCodePointFor((((gb18030_first - 129) * 10 + gb18030_second - 48) * 126 + gb18030_third - 129) * 10 + bite - 48);
        }
        var buffer = [gb18030_second, gb18030_third, bite];
        gb18030_first = 0;
        gb18030_second = 0;
        gb18030_third = 0;
        if (code_point === null) {
          stream.prepend(buffer);
          return decoderError(fatal);
        }
        return code_point;
      }
      if (gb18030_second !== 0) {
        if (inRange(bite, 129, 254)) {
          gb18030_third = bite;
          return null;
        }
        stream.prepend([gb18030_second, bite]);
        gb18030_first = 0;
        gb18030_second = 0;
        return decoderError(fatal);
      }
      if (gb18030_first !== 0) {
        if (inRange(bite, 48, 57)) {
          gb18030_second = bite;
          return null;
        }
        var lead = gb18030_first;
        var pointer = null;
        gb18030_first = 0;
        var offset = bite < 127 ? 64 : 65;
        if (inRange(bite, 64, 126) || inRange(bite, 128, 254))
          pointer = (lead - 129) * 190 + (bite - offset);
        code_point = pointer === null ? null : indexCodePointFor(pointer, index("gb18030"));
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);
        if (code_point === null)
          return decoderError(fatal);
        return code_point;
      }
      if (isASCIIByte(bite))
        return bite;
      if (bite === 128)
        return 8364;
      if (inRange(bite, 129, 254)) {
        gb18030_first = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }
  function GB18030Encoder(options, gbk_flag) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point))
        return code_point;
      if (code_point === 58853)
        return encoderError(code_point);
      if (gbk_flag && code_point === 8364)
        return 128;
      var pointer = indexPointerFor(code_point, index("gb18030"));
      if (pointer !== null) {
        var lead = floor(pointer / 190) + 129;
        var trail = pointer % 190;
        var offset = trail < 63 ? 64 : 65;
        return [lead, trail + offset];
      }
      if (gbk_flag)
        return encoderError(code_point);
      pointer = indexGB18030RangesPointerFor(code_point);
      var byte1 = floor(pointer / 10 / 126 / 10);
      pointer = pointer - byte1 * 10 * 126 * 10;
      var byte2 = floor(pointer / 10 / 126);
      pointer = pointer - byte2 * 10 * 126;
      var byte3 = floor(pointer / 10);
      var byte4 = pointer - byte3 * 10;
      return [byte1 + 129, byte2 + 48, byte3 + 129, byte4 + 48];
    };
  }
  function Big5Decoder(options) {
    var fatal = options.fatal;
    var Big5_lead = 0;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && Big5_lead !== 0) {
        Big5_lead = 0;
        return decoderError(fatal);
      }
      if (bite === end_of_stream && Big5_lead === 0)
        return finished;
      if (Big5_lead !== 0) {
        var lead = Big5_lead;
        var pointer = null;
        Big5_lead = 0;
        var offset = bite < 127 ? 64 : 98;
        if (inRange(bite, 64, 126) || inRange(bite, 161, 254))
          pointer = (lead - 129) * 157 + (bite - offset);
        switch (pointer) {
          case 1133:
            return [202, 772];
          case 1135:
            return [202, 780];
          case 1164:
            return [234, 772];
          case 1166:
            return [234, 780];
        }
        var code_point = pointer === null ? null : indexCodePointFor(pointer, index("big5"));
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);
        if (code_point === null)
          return decoderError(fatal);
        return code_point;
      }
      if (isASCIIByte(bite))
        return bite;
      if (inRange(bite, 129, 254)) {
        Big5_lead = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }
  function Big5Encoder(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point))
        return code_point;
      var pointer = indexBig5PointerFor(code_point);
      if (pointer === null)
        return encoderError(code_point);
      var lead = floor(pointer / 157) + 129;
      if (lead < 161)
        return encoderError(code_point);
      var trail = pointer % 157;
      var offset = trail < 63 ? 64 : 98;
      return [lead, trail + offset];
    };
  }
  function EUCJPDecoder(options) {
    var fatal = options.fatal;
    var eucjp_jis0212_flag = false, eucjp_lead = 0;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && eucjp_lead !== 0) {
        eucjp_lead = 0;
        return decoderError(fatal);
      }
      if (bite === end_of_stream && eucjp_lead === 0)
        return finished;
      if (eucjp_lead === 142 && inRange(bite, 161, 223)) {
        eucjp_lead = 0;
        return 65377 - 161 + bite;
      }
      if (eucjp_lead === 143 && inRange(bite, 161, 254)) {
        eucjp_jis0212_flag = true;
        eucjp_lead = bite;
        return null;
      }
      if (eucjp_lead !== 0) {
        var lead = eucjp_lead;
        eucjp_lead = 0;
        var code_point = null;
        if (inRange(lead, 161, 254) && inRange(bite, 161, 254)) {
          code_point = indexCodePointFor((lead - 161) * 94 + (bite - 161), index(!eucjp_jis0212_flag ? "jis0208" : "jis0212"));
        }
        eucjp_jis0212_flag = false;
        if (!inRange(bite, 161, 254))
          stream.prepend(bite);
        if (code_point === null)
          return decoderError(fatal);
        return code_point;
      }
      if (isASCIIByte(bite))
        return bite;
      if (bite === 142 || bite === 143 || inRange(bite, 161, 254)) {
        eucjp_lead = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }
  function EUCJPEncoder(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point))
        return code_point;
      if (code_point === 165)
        return 92;
      if (code_point === 8254)
        return 126;
      if (inRange(code_point, 65377, 65439))
        return [142, code_point - 65377 + 161];
      if (code_point === 8722)
        code_point = 65293;
      var pointer = indexPointerFor(code_point, index("jis0208"));
      if (pointer === null)
        return encoderError(code_point);
      var lead = floor(pointer / 94) + 161;
      var trail = pointer % 94 + 161;
      return [lead, trail];
    };
  }
  function ISO2022JPDecoder(options) {
    var fatal = options.fatal;
    var states = {
      ASCII: 0,
      Roman: 1,
      Katakana: 2,
      LeadByte: 3,
      TrailByte: 4,
      EscapeStart: 5,
      Escape: 6
    };
    var iso2022jp_decoder_state = states.ASCII, iso2022jp_decoder_output_state = states.ASCII, iso2022jp_lead = 0, iso2022jp_output_flag = false;
    this.handler = function(stream, bite) {
      switch (iso2022jp_decoder_state) {
        default:
        case states.ASCII:
          if (bite === 27) {
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }
          if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27) {
            iso2022jp_output_flag = false;
            return bite;
          }
          if (bite === end_of_stream) {
            return finished;
          }
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.Roman:
          if (bite === 27) {
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }
          if (bite === 92) {
            iso2022jp_output_flag = false;
            return 165;
          }
          if (bite === 126) {
            iso2022jp_output_flag = false;
            return 8254;
          }
          if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27 && bite !== 92 && bite !== 126) {
            iso2022jp_output_flag = false;
            return bite;
          }
          if (bite === end_of_stream) {
            return finished;
          }
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.Katakana:
          if (bite === 27) {
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }
          if (inRange(bite, 33, 95)) {
            iso2022jp_output_flag = false;
            return 65377 - 33 + bite;
          }
          if (bite === end_of_stream) {
            return finished;
          }
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.LeadByte:
          if (bite === 27) {
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }
          if (inRange(bite, 33, 126)) {
            iso2022jp_output_flag = false;
            iso2022jp_lead = bite;
            iso2022jp_decoder_state = states.TrailByte;
            return null;
          }
          if (bite === end_of_stream) {
            return finished;
          }
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.TrailByte:
          if (bite === 27) {
            iso2022jp_decoder_state = states.EscapeStart;
            return decoderError(fatal);
          }
          if (inRange(bite, 33, 126)) {
            iso2022jp_decoder_state = states.LeadByte;
            var pointer = (iso2022jp_lead - 33) * 94 + bite - 33;
            var code_point = indexCodePointFor(pointer, index("jis0208"));
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (bite === end_of_stream) {
            iso2022jp_decoder_state = states.LeadByte;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          iso2022jp_decoder_state = states.LeadByte;
          return decoderError(fatal);
        case states.EscapeStart:
          if (bite === 36 || bite === 40) {
            iso2022jp_lead = bite;
            iso2022jp_decoder_state = states.Escape;
            return null;
          }
          stream.prepend(bite);
          iso2022jp_output_flag = false;
          iso2022jp_decoder_state = iso2022jp_decoder_output_state;
          return decoderError(fatal);
        case states.Escape:
          var lead = iso2022jp_lead;
          iso2022jp_lead = 0;
          var state = null;
          if (lead === 40 && bite === 66)
            state = states.ASCII;
          if (lead === 40 && bite === 74)
            state = states.Roman;
          if (lead === 40 && bite === 73)
            state = states.Katakana;
          if (lead === 36 && (bite === 64 || bite === 66))
            state = states.LeadByte;
          if (state !== null) {
            iso2022jp_decoder_state = iso2022jp_decoder_state = state;
            var output_flag = iso2022jp_output_flag;
            iso2022jp_output_flag = true;
            return !output_flag ? null : decoderError(fatal);
          }
          stream.prepend([lead, bite]);
          iso2022jp_output_flag = false;
          iso2022jp_decoder_state = iso2022jp_decoder_output_state;
          return decoderError(fatal);
      }
    };
  }
  function ISO2022JPEncoder(options) {
    var fatal = options.fatal;
    var states = {
      ASCII: 0,
      Roman: 1,
      jis0208: 2
    };
    var iso2022jp_state = states.ASCII;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [27, 40, 66];
      }
      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
        return finished;
      if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 14 || code_point === 15 || code_point === 27)) {
        return encoderError(65533);
      }
      if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point))
        return code_point;
      if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 92 && code_point !== 126 || code_point == 165 || code_point == 8254)) {
        if (isASCIICodePoint(code_point))
          return code_point;
        if (code_point === 165)
          return 92;
        if (code_point === 8254)
          return 126;
      }
      if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [27, 40, 66];
      }
      if ((code_point === 165 || code_point === 8254) && iso2022jp_state !== states.Roman) {
        stream.prepend(code_point);
        iso2022jp_state = states.Roman;
        return [27, 40, 74];
      }
      if (code_point === 8722)
        code_point = 65293;
      var pointer = indexPointerFor(code_point, index("jis0208"));
      if (pointer === null)
        return encoderError(code_point);
      if (iso2022jp_state !== states.jis0208) {
        stream.prepend(code_point);
        iso2022jp_state = states.jis0208;
        return [27, 36, 66];
      }
      var lead = floor(pointer / 94) + 33;
      var trail = pointer % 94 + 33;
      return [lead, trail];
    };
  }
  function ShiftJISDecoder(options) {
    var fatal = options.fatal;
    var Shift_JIS_lead = 0;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && Shift_JIS_lead !== 0) {
        Shift_JIS_lead = 0;
        return decoderError(fatal);
      }
      if (bite === end_of_stream && Shift_JIS_lead === 0)
        return finished;
      if (Shift_JIS_lead !== 0) {
        var lead = Shift_JIS_lead;
        var pointer = null;
        Shift_JIS_lead = 0;
        var offset = bite < 127 ? 64 : 65;
        var lead_offset = lead < 160 ? 129 : 193;
        if (inRange(bite, 64, 126) || inRange(bite, 128, 252))
          pointer = (lead - lead_offset) * 188 + bite - offset;
        if (inRange(pointer, 8836, 10715))
          return 57344 - 8836 + pointer;
        var code_point = pointer === null ? null : indexCodePointFor(pointer, index("jis0208"));
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);
        if (code_point === null)
          return decoderError(fatal);
        return code_point;
      }
      if (isASCIIByte(bite) || bite === 128)
        return bite;
      if (inRange(bite, 161, 223))
        return 65377 - 161 + bite;
      if (inRange(bite, 129, 159) || inRange(bite, 224, 252)) {
        Shift_JIS_lead = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }
  function ShiftJISEncoder(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point) || code_point === 128)
        return code_point;
      if (code_point === 165)
        return 92;
      if (code_point === 8254)
        return 126;
      if (inRange(code_point, 65377, 65439))
        return code_point - 65377 + 161;
      if (code_point === 8722)
        code_point = 65293;
      var pointer = indexShiftJISPointerFor(code_point);
      if (pointer === null)
        return encoderError(code_point);
      var lead = floor(pointer / 188);
      var lead_offset = lead < 31 ? 129 : 193;
      var trail = pointer % 188;
      var offset = trail < 63 ? 64 : 65;
      return [lead + lead_offset, trail + offset];
    };
  }
  function EUCKRDecoder(options) {
    var fatal = options.fatal;
    var euckr_lead = 0;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && euckr_lead !== 0) {
        euckr_lead = 0;
        return decoderError(fatal);
      }
      if (bite === end_of_stream && euckr_lead === 0)
        return finished;
      if (euckr_lead !== 0) {
        var lead = euckr_lead;
        var pointer = null;
        euckr_lead = 0;
        if (inRange(bite, 65, 254))
          pointer = (lead - 129) * 190 + (bite - 65);
        var code_point = pointer === null ? null : indexCodePointFor(pointer, index("euc-kr"));
        if (pointer === null && isASCIIByte(bite))
          stream.prepend(bite);
        if (code_point === null)
          return decoderError(fatal);
        return code_point;
      }
      if (isASCIIByte(bite))
        return bite;
      if (inRange(bite, 129, 254)) {
        euckr_lead = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }
  function EUCKREncoder(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point))
        return code_point;
      var pointer = indexPointerFor(code_point, index("euc-kr"));
      if (pointer === null)
        return encoderError(code_point);
      var lead = floor(pointer / 190) + 129;
      var trail = pointer % 190 + 65;
      return [lead, trail];
    };
  }
  function convertCodeUnitToBytes(code_unit, utf16be) {
    var byte1 = code_unit >> 8;
    var byte2 = code_unit & 255;
    if (utf16be)
      return [byte1, byte2];
    return [byte2, byte1];
  }
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.fatal;
    var utf16_lead_byte = null, utf16_lead_surrogate = null;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
        return decoderError(fatal);
      }
      if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
        return finished;
      }
      if (utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null;
      }
      var code_unit;
      if (utf16_be) {
        code_unit = (utf16_lead_byte << 8) + bite;
      } else {
        code_unit = (bite << 8) + utf16_lead_byte;
      }
      utf16_lead_byte = null;
      if (utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;
        if (inRange(code_unit, 56320, 57343)) {
          return 65536 + (lead_surrogate - 55296) * 1024 + (code_unit - 56320);
        }
        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
        return decoderError(fatal);
      }
      if (inRange(code_unit, 55296, 56319)) {
        utf16_lead_surrogate = code_unit;
        return null;
      }
      if (inRange(code_unit, 56320, 57343))
        return decoderError(fatal);
      return code_unit;
    };
  }
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (inRange(code_point, 0, 65535))
        return convertCodeUnitToBytes(code_point, utf16_be);
      var lead = convertCodeUnitToBytes((code_point - 65536 >> 10) + 55296, utf16_be);
      var trail = convertCodeUnitToBytes((code_point - 65536 & 1023) + 56320, utf16_be);
      return lead.concat(trail);
    };
  }
  function XUserDefinedDecoder(options) {
    var fatal = options.fatal;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream)
        return finished;
      if (isASCIIByte(bite))
        return bite;
      return 63360 + bite - 128;
    };
  }
  function XUserDefinedEncoder(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (isASCIICodePoint(code_point))
        return code_point;
      if (inRange(code_point, 63360, 63487))
        return code_point - 63360 + 128;
      return encoderError(code_point);
    };
  }
  var floor, isASCIICodePoint, end_of_stream, finished, encodings, label_to_encoding, encoders, decoders, shift_jis_index, big5_index_no_hkscs, DEFAULT_ENCODING;
  var init_encoding = __esm({
    "src/lib/encoding.ts"() {
      init_encoding_indexes();
      global["encoding-indexes"] = encoding_indexes_default || {};
      floor = Math.floor;
      isASCIICodePoint = isASCIIByte;
      end_of_stream = -1;
      Stream.prototype = {
        endOfStream: function() {
          return !this.tokens.length;
        },
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.pop();
        },
        prepend: function(token) {
          if (Array.isArray(token)) {
            var tokens = token;
            while (tokens.length)
              this.tokens.push(tokens.pop());
          } else {
            this.tokens.push(token);
          }
        },
        push: function(token) {
          if (Array.isArray(token)) {
            var tokens = token;
            while (tokens.length)
              this.tokens.unshift(tokens.shift());
          } else {
            this.tokens.unshift(token);
          }
        }
      };
      finished = -1;
      Decoder.prototype = {
        handler: function(stream, bite) {
        }
      };
      Encoder.prototype = {
        handler: function(stream, code_point) {
        }
      };
      encodings = [
        {
          encodings: [
            {
              labels: ["unicode-1-1-utf-8", "utf-8", "utf8"],
              name: "UTF-8"
            }
          ],
          heading: "The Encoding"
        },
        {
          encodings: [
            {
              labels: ["866", "cp866", "csibm866", "ibm866"],
              name: "IBM866"
            },
            {
              labels: [
                "csisolatin2",
                "iso-8859-2",
                "iso-ir-101",
                "iso8859-2",
                "iso88592",
                "iso_8859-2",
                "iso_8859-2:1987",
                "l2",
                "latin2"
              ],
              name: "ISO-8859-2"
            },
            {
              labels: [
                "csisolatin3",
                "iso-8859-3",
                "iso-ir-109",
                "iso8859-3",
                "iso88593",
                "iso_8859-3",
                "iso_8859-3:1988",
                "l3",
                "latin3"
              ],
              name: "ISO-8859-3"
            },
            {
              labels: [
                "csisolatin4",
                "iso-8859-4",
                "iso-ir-110",
                "iso8859-4",
                "iso88594",
                "iso_8859-4",
                "iso_8859-4:1988",
                "l4",
                "latin4"
              ],
              name: "ISO-8859-4"
            },
            {
              labels: [
                "csisolatincyrillic",
                "cyrillic",
                "iso-8859-5",
                "iso-ir-144",
                "iso8859-5",
                "iso88595",
                "iso_8859-5",
                "iso_8859-5:1988"
              ],
              name: "ISO-8859-5"
            },
            {
              labels: [
                "arabic",
                "asmo-708",
                "csiso88596e",
                "csiso88596i",
                "csisolatinarabic",
                "ecma-114",
                "iso-8859-6",
                "iso-8859-6-e",
                "iso-8859-6-i",
                "iso-ir-127",
                "iso8859-6",
                "iso88596",
                "iso_8859-6",
                "iso_8859-6:1987"
              ],
              name: "ISO-8859-6"
            },
            {
              labels: [
                "csisolatingreek",
                "ecma-118",
                "elot_928",
                "greek",
                "greek8",
                "iso-8859-7",
                "iso-ir-126",
                "iso8859-7",
                "iso88597",
                "iso_8859-7",
                "iso_8859-7:1987",
                "sun_eu_greek"
              ],
              name: "ISO-8859-7"
            },
            {
              labels: [
                "csiso88598e",
                "csisolatinhebrew",
                "hebrew",
                "iso-8859-8",
                "iso-8859-8-e",
                "iso-ir-138",
                "iso8859-8",
                "iso88598",
                "iso_8859-8",
                "iso_8859-8:1988",
                "visual"
              ],
              name: "ISO-8859-8"
            },
            {
              labels: ["csiso88598i", "iso-8859-8-i", "logical"],
              name: "ISO-8859-8-I"
            },
            {
              labels: [
                "csisolatin6",
                "iso-8859-10",
                "iso-ir-157",
                "iso8859-10",
                "iso885910",
                "l6",
                "latin6"
              ],
              name: "ISO-8859-10"
            },
            {
              labels: ["iso-8859-13", "iso8859-13", "iso885913"],
              name: "ISO-8859-13"
            },
            {
              labels: ["iso-8859-14", "iso8859-14", "iso885914"],
              name: "ISO-8859-14"
            },
            {
              labels: ["csisolatin9", "iso-8859-15", "iso8859-15", "iso885915", "iso_8859-15", "l9"],
              name: "ISO-8859-15"
            },
            {
              labels: ["iso-8859-16"],
              name: "ISO-8859-16"
            },
            {
              labels: ["cskoi8r", "koi", "koi8", "koi8-r", "koi8_r"],
              name: "KOI8-R"
            },
            {
              labels: ["koi8-ru", "koi8-u"],
              name: "KOI8-U"
            },
            {
              labels: ["csmacintosh", "mac", "macintosh", "x-mac-roman"],
              name: "macintosh"
            },
            {
              labels: ["dos-874", "iso-8859-11", "iso8859-11", "iso885911", "tis-620", "windows-874"],
              name: "windows-874"
            },
            {
              labels: ["cp1250", "windows-1250", "x-cp1250"],
              name: "windows-1250"
            },
            {
              labels: ["cp1251", "windows-1251", "x-cp1251"],
              name: "windows-1251"
            },
            {
              labels: [
                "ansi_x3.4-1968",
                "ascii",
                "cp1252",
                "cp819",
                "csisolatin1",
                "ibm819",
                "iso-8859-1",
                "iso-ir-100",
                "iso8859-1",
                "iso88591",
                "iso_8859-1",
                "iso_8859-1:1987",
                "l1",
                "latin1",
                "us-ascii",
                "windows-1252",
                "x-cp1252"
              ],
              name: "windows-1252"
            },
            {
              labels: ["cp1253", "windows-1253", "x-cp1253"],
              name: "windows-1253"
            },
            {
              labels: [
                "cp1254",
                "csisolatin5",
                "iso-8859-9",
                "iso-ir-148",
                "iso8859-9",
                "iso88599",
                "iso_8859-9",
                "iso_8859-9:1989",
                "l5",
                "latin5",
                "windows-1254",
                "x-cp1254"
              ],
              name: "windows-1254"
            },
            {
              labels: ["cp1255", "windows-1255", "x-cp1255"],
              name: "windows-1255"
            },
            {
              labels: ["cp1256", "windows-1256", "x-cp1256"],
              name: "windows-1256"
            },
            {
              labels: ["cp1257", "windows-1257", "x-cp1257"],
              name: "windows-1257"
            },
            {
              labels: ["cp1258", "windows-1258", "x-cp1258"],
              name: "windows-1258"
            },
            {
              labels: ["x-mac-cyrillic", "x-mac-ukrainian"],
              name: "x-mac-cyrillic"
            }
          ],
          heading: "Legacy single-byte encodings"
        },
        {
          encodings: [
            {
              labels: [
                "chinese",
                "csgb2312",
                "csiso58gb231280",
                "gb2312",
                "gb_2312",
                "gb_2312-80",
                "gbk",
                "iso-ir-58",
                "x-gbk"
              ],
              name: "GBK"
            },
            {
              labels: ["gb18030"],
              name: "gb18030"
            }
          ],
          heading: "Legacy multi-byte Chinese (simplified) encodings"
        },
        {
          encodings: [
            {
              labels: ["big5", "big5-hkscs", "cn-big5", "csbig5", "x-x-big5"],
              name: "Big5"
            }
          ],
          heading: "Legacy multi-byte Chinese (traditional) encodings"
        },
        {
          encodings: [
            {
              labels: ["cseucpkdfmtjapanese", "euc-jp", "x-euc-jp"],
              name: "EUC-JP"
            },
            {
              labels: ["csiso2022jp", "iso-2022-jp"],
              name: "ISO-2022-JP"
            },
            {
              labels: [
                "csshiftjis",
                "ms932",
                "ms_kanji",
                "shift-jis",
                "shift_jis",
                "sjis",
                "windows-31j",
                "x-sjis"
              ],
              name: "Shift_JIS"
            }
          ],
          heading: "Legacy multi-byte Japanese encodings"
        },
        {
          encodings: [
            {
              labels: [
                "cseuckr",
                "csksc56011987",
                "euc-kr",
                "iso-ir-149",
                "korean",
                "ks_c_5601-1987",
                "ks_c_5601-1989",
                "ksc5601",
                "ksc_5601",
                "windows-949"
              ],
              name: "EUC-KR"
            }
          ],
          heading: "Legacy multi-byte Korean encodings"
        },
        {
          encodings: [
            {
              labels: ["csiso2022kr", "hz-gb-2312", "iso-2022-cn", "iso-2022-cn-ext", "iso-2022-kr"],
              name: "replacement"
            },
            {
              labels: ["utf-16be"],
              name: "UTF-16BE"
            },
            {
              labels: ["utf-16", "utf-16le"],
              name: "UTF-16LE"
            },
            {
              labels: ["x-user-defined"],
              name: "x-user-defined"
            }
          ],
          heading: "Legacy miscellaneous encodings"
        }
      ];
      label_to_encoding = {};
      encodings.forEach(function(category) {
        category.encodings.forEach(function(encoding) {
          encoding.labels.forEach(function(label) {
            label_to_encoding[label] = encoding;
          });
        });
      });
      encoders = {};
      decoders = {};
      DEFAULT_ENCODING = "utf-8";
      if (Object.defineProperty) {
        Object.defineProperty(TextDecoder.prototype, "encoding", {
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        });
        Object.defineProperty(TextDecoder.prototype, "fatal", {
          get: function() {
            return this._error_mode === "fatal";
          }
        });
        Object.defineProperty(TextDecoder.prototype, "ignoreBOM", {
          get: function() {
            return this._ignoreBOM;
          }
        });
      }
      TextDecoder.prototype.decode = function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._do_not_flush) {
          this._decoder = decoders[this._encoding.name]({
            fatal: this._error_mode === "fatal"
          });
          this._BOMseen = false;
        }
        this._do_not_flush = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var output = [];
        var result;
        while (true) {
          var token = input_stream.read();
          if (token === end_of_stream)
            break;
          result = this._decoder.handler(input_stream, token);
          if (result === finished)
            break;
          if (result !== null) {
            if (Array.isArray(result))
              output.push.apply(output, result);
            else
              output.push(result);
          }
        }
        if (!this._do_not_flush) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              output.push.apply(output, result);
            else
              output.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        function serializeStream(stream) {
          if (includes(["UTF-8", "UTF-16LE", "UTF-16BE"], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {
            if (stream.length > 0 && stream[0] === 65279) {
              this._BOMseen = true;
              stream.shift();
            } else if (stream.length > 0) {
              this._BOMseen = true;
            } else {
            }
          }
          return codePointsToString(stream);
        }
        return serializeStream.call(this, output);
      };
      if (Object.defineProperty) {
        Object.defineProperty(TextEncoder.prototype, "encoding", {
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        });
      }
      TextEncoder.prototype.encode = function encode(opt_string, options) {
        opt_string = opt_string === void 0 ? "" : String(opt_string);
        options = ToDictionary(options);
        if (!this._do_not_flush)
          this._encoder = encoders[this._encoding.name]({
            fatal: this._fatal === "fatal"
          });
        this._do_not_flush = Boolean(options["stream"]);
        var input = new Stream(stringToCodePoints(opt_string));
        var output = [];
        var result;
        while (true) {
          var token = input.read();
          if (token === end_of_stream)
            break;
          result = this._encoder.handler(input, token);
          if (result === finished)
            break;
          if (Array.isArray(result))
            output.push.apply(output, result);
          else
            output.push(result);
        }
        if (!this._do_not_flush) {
          while (true) {
            result = this._encoder.handler(input, input.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              output.push.apply(output, result);
            else
              output.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(output);
      };
      encoders["UTF-8"] = function(options) {
        return new UTF8Encoder(options);
      };
      decoders["UTF-8"] = function(options) {
        return new UTF8Decoder(options);
      };
      (function() {
        if (!("encoding-indexes" in global))
          return;
        encodings.forEach(function(category) {
          if (category.heading !== "Legacy single-byte encodings")
            return;
          category.encodings.forEach(function(encoding) {
            var name = encoding.name;
            var idx = index(name.toLowerCase());
            decoders[name] = function(options) {
              return new SingleByteDecoder(idx, options);
            };
            encoders[name] = function(options) {
              return new SingleByteEncoder(idx, options);
            };
          });
        });
      })();
      decoders["GBK"] = function(options) {
        return new GB18030Decoder(options);
      };
      encoders["GBK"] = function(options) {
        return new GB18030Encoder(options, true);
      };
      encoders["gb18030"] = function(options) {
        return new GB18030Encoder(options);
      };
      decoders["gb18030"] = function(options) {
        return new GB18030Decoder(options);
      };
      encoders["Big5"] = function(options) {
        return new Big5Encoder(options);
      };
      decoders["Big5"] = function(options) {
        return new Big5Decoder(options);
      };
      encoders["EUC-JP"] = function(options) {
        return new EUCJPEncoder(options);
      };
      decoders["EUC-JP"] = function(options) {
        return new EUCJPDecoder(options);
      };
      encoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPEncoder(options);
      };
      decoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPDecoder(options);
      };
      encoders["Shift_JIS"] = function(options) {
        return new ShiftJISEncoder(options);
      };
      decoders["Shift_JIS"] = function(options) {
        return new ShiftJISDecoder(options);
      };
      encoders["EUC-KR"] = function(options) {
        return new EUCKREncoder(options);
      };
      decoders["EUC-KR"] = function(options) {
        return new EUCKRDecoder(options);
      };
      encoders["UTF-16BE"] = function(options) {
        return new UTF16Encoder(true, options);
      };
      decoders["UTF-16BE"] = function(options) {
        return new UTF16Decoder(true, options);
      };
      encoders["UTF-16LE"] = function(options) {
        return new UTF16Encoder(false, options);
      };
      decoders["UTF-16LE"] = function(options) {
        return new UTF16Decoder(false, options);
      };
      encoders["x-user-defined"] = function(options) {
        return new XUserDefinedEncoder(options);
      };
      decoders["x-user-defined"] = function(options) {
        return new XUserDefinedDecoder(options);
      };
    }
  });

  // src/promise/all-settled.ts
  function allSettled(promises) {
    const mappedPromises = promises.map((promise) => {
      return promise.then((value) => {
        return { status: FULFILLED_STATUS, value };
      }).catch((reason) => {
        return { status: REJECTED_STATUS, reason };
      });
    });
    return Promise.all(mappedPromises);
  }
  var REJECTED_STATUS, FULFILLED_STATUS;
  var init_all_settled = __esm({
    "src/promise/all-settled.ts"() {
      REJECTED_STATUS = "rejected";
      FULFILLED_STATUS = "fulfilled";
    }
  });

  // (disabled):src/node/buffer/btoa.node
  var init_btoa = __esm({
    "(disabled):src/node/buffer/btoa.node"() {
    }
  });

  // (disabled):src/node/fetch/headers.node
  var init_headers = __esm({
    "(disabled):src/node/fetch/headers.node"() {
    }
  });

  // (disabled):src/node/fetch/response.node
  var init_response = __esm({
    "(disabled):src/node/fetch/response.node"() {
    }
  });

  // (disabled):src/node/fetch/fetch.node
  var init_fetch = __esm({
    "(disabled):src/node/fetch/fetch.node"() {
    }
  });

  // (disabled):src/node/images/encode-image.node
  var init_encode_image = __esm({
    "(disabled):src/node/images/encode-image.node"() {
    }
  });

  // (disabled):src/node/images/parse-image.node
  var init_parse_image = __esm({
    "(disabled):src/node/images/parse-image.node"() {
    }
  });

  // (disabled):src/node/file/readable-stream
  var init_readable_stream = __esm({
    "(disabled):src/node/file/readable-stream"() {
    }
  });

  // (disabled):src/node/file/blob
  var init_blob = __esm({
    "(disabled):src/node/file/blob"() {
    }
  });

  // src/node/file/file-reader.ts
  var FileReaderPolyfill;
  var init_file_reader = __esm({
    "src/node/file/file-reader.ts"() {
      init_btoa();
      FileReaderPolyfill = class {
        constructor() {
          this.onload = null;
        }
        abort() {
          return;
        }
        async readAsArrayBuffer(blob) {
          const arrayBuffer = await blob.arrayBuffer();
          if (this.onload) {
            this.onload({ target: { result: arrayBuffer } });
          }
        }
        async readAsBinaryString(blob) {
          throw Error("Not implemented");
        }
        async readAsDataURL(blob) {
          const text = await blob.text();
          const dataUrl = `data://;base64,${(0, import_btoa.atob)(text)}`;
          if (this.onload) {
            this.onload({ target: { result: dataUrl } });
          }
        }
        async readAsText(blob) {
          const text = await blob.text();
          if (this.onload) {
            this.onload({ target: { result: text } });
          }
        }
      };
    }
  });

  // (disabled):src/node/file/file
  var init_file = __esm({
    "(disabled):src/node/file/file"() {
    }
  });

  // src/node/file/install-file-polyfills.ts
  function installFilePolyfills() {
    if (typeof ReadableStream === "undefined" && global) {
      global.ReadableStream = import_readable_stream.ReadableStreamPolyfill;
    }
    if (typeof Blob === "undefined" && global) {
      global.Blob = import_blob.BlobPolyfill;
    }
    if (typeof FileReader === "undefined" && global) {
      global.FileReader = FileReaderPolyfill;
    }
    if (typeof File === "undefined" && global) {
      global.File = import_file.FilePolyfill;
    }
  }
  var init_install_file_polyfills = __esm({
    "src/node/file/install-file-polyfills.ts"() {
      init_readable_stream();
      init_blob();
      init_file_reader();
      init_file();
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // src/node/fetch/fetch-file.node.ts
  async function fetchFileNode(url, options) {
    const noqueryUrl = url.split("?")[0];
    try {
      const body = await new Promise((resolve, reject) => {
        const stream = import_fs.default.createReadStream(noqueryUrl, { encoding: null });
        stream.once("readable", () => resolve(stream));
        stream.on("error", (error) => reject(error));
      });
      const status = 200;
      const statusText = "OK";
      const headers = getHeadersForFile(noqueryUrl);
      return new import_response.Response(body, { headers, status, statusText, url });
    } catch (error) {
      const status = 400;
      const statusText = error.message;
      const headers = {};
      return new import_response.Response(error.message, { headers, status, statusText, url });
    }
  }
  function getHeadersForFile(noqueryUrl) {
    const headers = {};
    if (!headers["content-length"]) {
      const stats = import_fs.default.statSync(noqueryUrl);
      headers["content-length"] = stats.size;
    }
    if (noqueryUrl.endsWith(".gz")) {
      noqueryUrl = noqueryUrl.slice(0, -3);
      headers["content-encoding"] = "gzip";
    }
    return new import_headers.Headers(headers);
  }
  var import_fs;
  var init_fetch_file_node = __esm({
    "src/node/fetch/fetch-file.node.ts"() {
      import_fs = __toModule(require_fs());
      init_response();
      init_headers();
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    BlobPolyfill: () => import_blob2.BlobPolyfill,
    FilePolyfill: () => import_file2.FilePolyfill,
    FileReaderPolyfill: () => FileReaderPolyfill,
    ReadableStreamPolyfill: () => import_readable_stream2.ReadableStreamPolyfill,
    _fetchFileNode: () => fetchFileNode,
    _fetchNode: () => import_fetch2.fetchNode,
    installFilePolyfills: () => installFilePolyfills
  });
  var installTextEncoder, installTextDecoder;
  var init_src = __esm({
    "src/index.ts"() {
      init_globals();
      init_encoding();
      init_all_settled();
      init_btoa();
      init_headers();
      init_response();
      init_fetch();
      init_encode_image();
      init_parse_image();
      init_readable_stream();
      init_blob();
      init_file_reader();
      init_file();
      init_install_file_polyfills();
      init_fetch();
      init_fetch_file_node();
      installTextEncoder = !isBrowser || !("TextEncoder" in global_);
      if (installTextEncoder) {
        global_["TextEncoder"] = TextEncoder;
      }
      installTextDecoder = !isBrowser || !("TextDecoder" in global_);
      if (installTextDecoder) {
        global_["TextDecoder"] = TextDecoder;
      }
      if (!isBrowser && !("atob" in global_) && base64.atob) {
        global_["atob"] = base64.atob;
      }
      if (!isBrowser && !("btoa" in global_) && base64.btoa) {
        global_["btoa"] = base64.btoa;
      }
      if (!isBrowser && !("Headers" in global_) && import_headers2.Headers) {
        global_["Headers"] = import_headers2.Headers;
      }
      if (!isBrowser && !("Response" in global_) && import_response2.Response) {
        global_["Response"] = import_response2.Response;
      }
      if (!isBrowser && !("fetch" in global_) && import_fetch.fetchNode) {
        global_["fetch"] = import_fetch.fetchNode;
      }
      if (!isBrowser && !("_encodeImageNode" in global_) && import_encode_image.encodeImageNode) {
        global_["_encodeImageNode"] = import_encode_image.encodeImageNode;
      }
      if (!isBrowser && !("_parseImageNode" in global_) && import_parse_image.parseImageNode) {
        global_["_parseImageNode"] = import_parse_image.parseImageNode;
        global_["_imageFormatsNode"] = import_parse_image.NODE_FORMAT_SUPPORT;
      }
      if (!("allSettled" in Promise)) {
        Promise.allSettled = allSettled;
      }
    }
  });

  // src/bundle.ts
  var require_bundle = __commonJS({
    "src/bundle.ts"(exports, module) {
      var moduleExports = (init_src(), src_exports);
      globalThis.loaders = globalThis.loaders || {};
      module.exports = Object.assign(globalThis.loaders, moduleExports);
    }
  });
  require_bundle();
})();
