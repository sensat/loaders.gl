{"version":3,"file":"encoding.js","names":["_encodingIndexes","_interopRequireDefault","require","global","indexes","inRange","a","min","max","includes","array","item","indexOf","floor","Math","ToDictionary","o","undefined","Object","TypeError","stringToCodePoints","string","s","String","n","length","i","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","isASCIIByte","isASCIICodePoint","end_of_stream","Stream","tokens","slice","call","reverse","prototype","endOfStream","read","pop","prepend","token","Array","isArray","unshift","shift","finished","decoderError","fatal","opt_code_point","encoderError","code_point","Decoder","handler","stream","bite","Encoder","getEncoding","label","trim","toLowerCase","hasOwnProperty","label_to_encoding","encodings","labels","name","heading","forEach","category","encoding","encoders","decoders","indexCodePointFor","pointer","index","indexPointerFor","Error","indexGB18030RangesCodePointFor","offset","code_point_offset","idx","entry","indexGB18030RangesPointerFor","pointer_offset","indexShiftJISPointerFor","shift_jis_index","map","index_","indexBig5PointerFor","big5_index_no_hkscs","lastIndexOf","DEFAULT_ENCODING","TextDecoder","options","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","RangeError","dec","Boolean","defineProperty","ignoreBOM","get","decode","input","bytes","_typeof2","default","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","input_stream","output","result","apply","serializeStream","TextEncoder","_encoder","_fatal","enc","console","warn","encode","opt_string","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","UTF8Encoder","count","temp","SingleByteDecoder","SingleByteEncoder","GB18030Decoder","GB18030Encoder","gb18030_first","gb18030_second","gb18030_third","lead","gbk_flag","trail","byte1","byte2","byte3","byte4","Big5Decoder","Big5_lead","Big5Encoder","EUCJPDecoder","eucjp_jis0212_flag","eucjp_lead","EUCJPEncoder","ISO2022JPDecoder","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","ShiftJISDecoder","Shift_JIS_lead","lead_offset","ShiftJISEncoder","EUCKRDecoder","euckr_lead","EUCKREncoder","convertCodeUnitToBytes","code_unit","utf16be","UTF16Decoder","utf16_be","utf16_lead_byte","utf16_lead_surrogate","lead_surrogate","UTF16Encoder","concat","XUserDefinedDecoder","XUserDefinedEncoder"],"sources":["../../../src/lib/encoding.ts"],"sourcesContent":["// @ts-nocheck\n/* eslint-disable */\n\n// Copied from https://github.com/inexorabletash/text-encoding/blob/b4e5bc26e26e51f56e3daa9f13138c79f49d3c34/lib/encoding.js\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\nimport indexes from './encoding-indexes';\n// Note: Aaian character indices add half a megabyte to bundle. Ignore, since we really only want the built-in UTF8...\n// import indexes from './encoding-indexes-asian.js';\nglobal['encoding-indexes'] = indexes || {};\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {!Array.<*>} array The array to check.\n * @param {*} item The item to look for in the array.\n * @return {boolean} True if the item appears in the array.\n */\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\nvar floor = Math.floor;\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xd800 || c > 0xdfff) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xdc00 <= c && c <= 0xdfff) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xfffd);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xd800 <= c && c <= 0xdbff) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xfffd);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = s.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xdc00 <= d && d <= 0xdfff) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3ff;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3ff;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else {\n          u.push(0xfffd);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xffff) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return s;\n}\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 4. Terminology\n//\n\n/**\n * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n * @param {number} a The number to test.\n * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n */\nfunction isASCIIByte(a) {\n  return 0x00 <= a && a <= 0x7f;\n}\n\n/**\n * An ASCII code point is a code point in the range U+0000 to\n * U+007F, inclusive.\n */\nvar isASCIICodePoint = isASCIIByte;\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n * the stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n  // Reversed as push/pop is more efficient than shift/unshift.\n  this.tokens.reverse();\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function () {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read: function () {\n    if (!this.tokens.length) return end_of_stream;\n    return this.tokens.pop();\n  },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n   * stream.\n   */\n  prepend: function (token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/ token;\n      while (tokens.length) this.tokens.push(tokens.pop());\n    } else {\n      this.tokens.push(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n   * stream.\n   */\n  push: function (token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/ token;\n      while (tokens.length) this.tokens.unshift(tokens.shift());\n    } else {\n      this.tokens.unshift(token);\n    }\n  }\n};\n\n//\n// 5. Encodings\n//\n\n// 5.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal) throw TypeError('Decoder error');\n  return opt_code_point || 0xfffd;\n}\n\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\nfunction encoderError(code_point) {\n  throw TypeError('The code point ' + code_point + ' could not be encoded.');\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function (stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function (stream, code_point) {}\n};\n\n// 5.2 Names and labels\n\n// TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n// https://github.com/google/closure-compiler/issues/247\n\n/**\n * @param {string} label The encoding label.\n * @return {?{name:string,labels:Array.<string>}}\n */\nfunction getEncoding(label) {\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  label = String(label).trim().toLowerCase();\n\n  // 2. If label is an ASCII case-insensitive match for any of the\n  // labels listed in the table below, return the corresponding\n  // encoding, and failure otherwise.\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label];\n  }\n  return null;\n}\n\n/**\n * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n * @const\n * @type {!Array.<{\n *          heading: string,\n *          encodings: Array.<{name:string,labels:Array.<string>}>\n *        }>}\n */\nvar encodings = [\n  {\n    encodings: [\n      {\n        labels: ['unicode-1-1-utf-8', 'utf-8', 'utf8'],\n        name: 'UTF-8'\n      }\n    ],\n    heading: 'The Encoding'\n  },\n  {\n    encodings: [\n      {\n        labels: ['866', 'cp866', 'csibm866', 'ibm866'],\n        name: 'IBM866'\n      },\n      {\n        labels: [\n          'csisolatin2',\n          'iso-8859-2',\n          'iso-ir-101',\n          'iso8859-2',\n          'iso88592',\n          'iso_8859-2',\n          'iso_8859-2:1987',\n          'l2',\n          'latin2'\n        ],\n        name: 'ISO-8859-2'\n      },\n      {\n        labels: [\n          'csisolatin3',\n          'iso-8859-3',\n          'iso-ir-109',\n          'iso8859-3',\n          'iso88593',\n          'iso_8859-3',\n          'iso_8859-3:1988',\n          'l3',\n          'latin3'\n        ],\n        name: 'ISO-8859-3'\n      },\n      {\n        labels: [\n          'csisolatin4',\n          'iso-8859-4',\n          'iso-ir-110',\n          'iso8859-4',\n          'iso88594',\n          'iso_8859-4',\n          'iso_8859-4:1988',\n          'l4',\n          'latin4'\n        ],\n        name: 'ISO-8859-4'\n      },\n      {\n        labels: [\n          'csisolatincyrillic',\n          'cyrillic',\n          'iso-8859-5',\n          'iso-ir-144',\n          'iso8859-5',\n          'iso88595',\n          'iso_8859-5',\n          'iso_8859-5:1988'\n        ],\n        name: 'ISO-8859-5'\n      },\n      {\n        labels: [\n          'arabic',\n          'asmo-708',\n          'csiso88596e',\n          'csiso88596i',\n          'csisolatinarabic',\n          'ecma-114',\n          'iso-8859-6',\n          'iso-8859-6-e',\n          'iso-8859-6-i',\n          'iso-ir-127',\n          'iso8859-6',\n          'iso88596',\n          'iso_8859-6',\n          'iso_8859-6:1987'\n        ],\n        name: 'ISO-8859-6'\n      },\n      {\n        labels: [\n          'csisolatingreek',\n          'ecma-118',\n          'elot_928',\n          'greek',\n          'greek8',\n          'iso-8859-7',\n          'iso-ir-126',\n          'iso8859-7',\n          'iso88597',\n          'iso_8859-7',\n          'iso_8859-7:1987',\n          'sun_eu_greek'\n        ],\n        name: 'ISO-8859-7'\n      },\n      {\n        labels: [\n          'csiso88598e',\n          'csisolatinhebrew',\n          'hebrew',\n          'iso-8859-8',\n          'iso-8859-8-e',\n          'iso-ir-138',\n          'iso8859-8',\n          'iso88598',\n          'iso_8859-8',\n          'iso_8859-8:1988',\n          'visual'\n        ],\n        name: 'ISO-8859-8'\n      },\n      {\n        labels: ['csiso88598i', 'iso-8859-8-i', 'logical'],\n        name: 'ISO-8859-8-I'\n      },\n      {\n        labels: [\n          'csisolatin6',\n          'iso-8859-10',\n          'iso-ir-157',\n          'iso8859-10',\n          'iso885910',\n          'l6',\n          'latin6'\n        ],\n        name: 'ISO-8859-10'\n      },\n      {\n        labels: ['iso-8859-13', 'iso8859-13', 'iso885913'],\n        name: 'ISO-8859-13'\n      },\n      {\n        labels: ['iso-8859-14', 'iso8859-14', 'iso885914'],\n        name: 'ISO-8859-14'\n      },\n      {\n        labels: ['csisolatin9', 'iso-8859-15', 'iso8859-15', 'iso885915', 'iso_8859-15', 'l9'],\n        name: 'ISO-8859-15'\n      },\n      {\n        labels: ['iso-8859-16'],\n        name: 'ISO-8859-16'\n      },\n      {\n        labels: ['cskoi8r', 'koi', 'koi8', 'koi8-r', 'koi8_r'],\n        name: 'KOI8-R'\n      },\n      {\n        labels: ['koi8-ru', 'koi8-u'],\n        name: 'KOI8-U'\n      },\n      {\n        labels: ['csmacintosh', 'mac', 'macintosh', 'x-mac-roman'],\n        name: 'macintosh'\n      },\n      {\n        labels: ['dos-874', 'iso-8859-11', 'iso8859-11', 'iso885911', 'tis-620', 'windows-874'],\n        name: 'windows-874'\n      },\n      {\n        labels: ['cp1250', 'windows-1250', 'x-cp1250'],\n        name: 'windows-1250'\n      },\n      {\n        labels: ['cp1251', 'windows-1251', 'x-cp1251'],\n        name: 'windows-1251'\n      },\n      {\n        labels: [\n          'ansi_x3.4-1968',\n          'ascii',\n          'cp1252',\n          'cp819',\n          'csisolatin1',\n          'ibm819',\n          'iso-8859-1',\n          'iso-ir-100',\n          'iso8859-1',\n          'iso88591',\n          'iso_8859-1',\n          'iso_8859-1:1987',\n          'l1',\n          'latin1',\n          'us-ascii',\n          'windows-1252',\n          'x-cp1252'\n        ],\n        name: 'windows-1252'\n      },\n      {\n        labels: ['cp1253', 'windows-1253', 'x-cp1253'],\n        name: 'windows-1253'\n      },\n      {\n        labels: [\n          'cp1254',\n          'csisolatin5',\n          'iso-8859-9',\n          'iso-ir-148',\n          'iso8859-9',\n          'iso88599',\n          'iso_8859-9',\n          'iso_8859-9:1989',\n          'l5',\n          'latin5',\n          'windows-1254',\n          'x-cp1254'\n        ],\n        name: 'windows-1254'\n      },\n      {\n        labels: ['cp1255', 'windows-1255', 'x-cp1255'],\n        name: 'windows-1255'\n      },\n      {\n        labels: ['cp1256', 'windows-1256', 'x-cp1256'],\n        name: 'windows-1256'\n      },\n      {\n        labels: ['cp1257', 'windows-1257', 'x-cp1257'],\n        name: 'windows-1257'\n      },\n      {\n        labels: ['cp1258', 'windows-1258', 'x-cp1258'],\n        name: 'windows-1258'\n      },\n      {\n        labels: ['x-mac-cyrillic', 'x-mac-ukrainian'],\n        name: 'x-mac-cyrillic'\n      }\n    ],\n    heading: 'Legacy single-byte encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          'chinese',\n          'csgb2312',\n          'csiso58gb231280',\n          'gb2312',\n          'gb_2312',\n          'gb_2312-80',\n          'gbk',\n          'iso-ir-58',\n          'x-gbk'\n        ],\n        name: 'GBK'\n      },\n      {\n        labels: ['gb18030'],\n        name: 'gb18030'\n      }\n    ],\n    heading: 'Legacy multi-byte Chinese (simplified) encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['big5', 'big5-hkscs', 'cn-big5', 'csbig5', 'x-x-big5'],\n        name: 'Big5'\n      }\n    ],\n    heading: 'Legacy multi-byte Chinese (traditional) encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['cseucpkdfmtjapanese', 'euc-jp', 'x-euc-jp'],\n        name: 'EUC-JP'\n      },\n      {\n        labels: ['csiso2022jp', 'iso-2022-jp'],\n        name: 'ISO-2022-JP'\n      },\n      {\n        labels: [\n          'csshiftjis',\n          'ms932',\n          'ms_kanji',\n          'shift-jis',\n          'shift_jis',\n          'sjis',\n          'windows-31j',\n          'x-sjis'\n        ],\n        name: 'Shift_JIS'\n      }\n    ],\n    heading: 'Legacy multi-byte Japanese encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          'cseuckr',\n          'csksc56011987',\n          'euc-kr',\n          'iso-ir-149',\n          'korean',\n          'ks_c_5601-1987',\n          'ks_c_5601-1989',\n          'ksc5601',\n          'ksc_5601',\n          'windows-949'\n        ],\n        name: 'EUC-KR'\n      }\n    ],\n    heading: 'Legacy multi-byte Korean encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['csiso2022kr', 'hz-gb-2312', 'iso-2022-cn', 'iso-2022-cn-ext', 'iso-2022-kr'],\n        name: 'replacement'\n      },\n      {\n        labels: ['utf-16be'],\n        name: 'UTF-16BE'\n      },\n      {\n        labels: ['utf-16', 'utf-16le'],\n        name: 'UTF-16LE'\n      },\n      {\n        labels: ['x-user-defined'],\n        name: 'x-user-defined'\n      }\n    ],\n    heading: 'Legacy miscellaneous encodings'\n  }\n];\n\n// Label to encoding registry.\n/** @type {Object.<string,{name:string,labels:Array.<string>}>} */\nvar label_to_encoding = {};\nencodings.forEach(function (category) {\n  category.encodings.forEach(function (encoding) {\n    encoding.labels.forEach(function (label) {\n      label_to_encoding[label] = encoding;\n    });\n  });\n});\n\n// Registry of of encoder/decoder factories, by encoding name.\n/** @type {Object.<string, function({fatal:boolean}): Encoder>} */\nvar encoders = {};\n/** @type {Object.<string, function({fatal:boolean}): Decoder>} */\nvar decoders = {};\n\n//\n// 6. Indexes\n//\n\n/**\n * @param {number} pointer The |pointer| to search for.\n * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in |index|.\n */\nfunction indexCodePointFor(pointer, index) {\n  if (!index) return null;\n  return index[pointer] || null;\n}\n\n/**\n * @param {number} code_point The |code point| to search for.\n * @param {!Array.<?number>} index The |index| to search within.\n * @return {?number} The first pointer corresponding to |code point| in\n *     |index|, or null if |code point| is not in |index|.\n */\nfunction indexPointerFor(code_point, index) {\n  var pointer = index.indexOf(code_point);\n  return pointer === -1 ? null : pointer;\n}\n\n/**\n * @param {string} name Name of the index.\n * @return {(!Array.<number>|!Array.<Array.<number>>)}\n *  */\nfunction index(name) {\n  if (!('encoding-indexes' in global)) {\n    throw Error('Indexes missing.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n  return global['encoding-indexes'][name];\n}\n\n/**\n * @param {number} pointer The |pointer| to search for in the gb18030 index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the gb18030 index.\n */\nfunction indexGB18030RangesCodePointFor(pointer) {\n  // 1. If pointer is greater than 39419 and less than 189000, or\n  // pointer is greater than 1237575, return null.\n  if ((pointer > 39419 && pointer < 189000) || pointer > 1237575) return null;\n\n  // 2. If pointer is 7457, return code point U+E7C7.\n  if (pointer === 7457) return 0xe7c7;\n\n  // 3. Let offset be the last pointer in index gb18030 ranges that\n  // is equal to or less than pointer and let code point offset be\n  // its corresponding code point.\n  var offset = 0;\n  var code_point_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[0] <= pointer) {\n      offset = entry[0];\n      code_point_offset = entry[1];\n    } else {\n      break;\n    }\n  }\n\n  // 4. Return a code point whose value is code point offset +\n  // pointer − offset.\n  return code_point_offset + pointer - offset;\n}\n\n/**\n * @param {number} code_point The |code point| to locate in the gb18030 index.\n * @return {number} The first pointer corresponding to |code point| in the\n *     gb18030 index.\n */\nfunction indexGB18030RangesPointerFor(code_point) {\n  // 1. If code point is U+E7C7, return pointer 7457.\n  if (code_point === 0xe7c7) return 7457;\n\n  // 2. Let offset be the last code point in index gb18030 ranges\n  // that is equal to or less than code point and let pointer offset\n  // be its corresponding pointer.\n  var offset = 0;\n  var pointer_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[1] <= code_point) {\n      offset = entry[1];\n      pointer_offset = entry[0];\n    } else {\n      break;\n    }\n  }\n\n  // 3. Return a pointer whose value is pointer offset + code point\n  // − offset.\n  return pointer_offset + code_point - offset;\n}\n\n/**\n * @param {number} code_point The |code_point| to search for in the Shift_JIS\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the Shift_JIS index.\n */\nfunction indexShiftJISPointerFor(code_point) {\n  // 1. Let index be index jis0208 excluding all entries whose\n  // pointer is in the range 8272 to 8835, inclusive.\n  shift_jis_index =\n    shift_jis_index ||\n    index('jis0208').map(function (code_point, pointer) {\n      return inRange(pointer, 8272, 8835) ? null : code_point;\n    });\n  var index_ = shift_jis_index;\n\n  // 2. Return the index pointer for code point in index.\n  return index_.indexOf(code_point);\n}\nvar shift_jis_index;\n\n/**\n * @param {number} code_point The |code_point| to search for in the big5\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the big5 index.\n */\nfunction indexBig5PointerFor(code_point) {\n  // 1. Let index be index Big5 excluding all entries whose pointer\n  big5_index_no_hkscs =\n    big5_index_no_hkscs ||\n    index('big5').map(function (code_point, pointer) {\n      return pointer < (0xa1 - 0x81) * 157 ? null : code_point;\n    });\n  var index_ = big5_index_no_hkscs;\n\n  // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n  // U+5345, return the last pointer corresponding to code point in\n  // index.\n  if (\n    code_point === 0x2550 ||\n    code_point === 0x255e ||\n    code_point === 0x2561 ||\n    code_point === 0x256a ||\n    code_point === 0x5341 ||\n    code_point === 0x5345\n  ) {\n    return index_.lastIndexOf(code_point);\n  }\n\n  // 3. Return the index pointer for code point in index.\n  return indexPointerFor(code_point, index_);\n}\nvar big5_index_no_hkscs;\n\n//\n// 8. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 8.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextDecoder))\n    throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n  options = ToDictionary(options);\n\n  // A TextDecoder object has an associated encoding, decoder,\n  // stream, ignore BOM flag (initially unset), BOM seen flag\n  // (initially unset), error mode (initially replacement), and do\n  // not flush flag (initially unset).\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._ignoreBOM = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {string} */\n  this._error_mode = 'replacement';\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n\n  // 1. Let encoding be the result of getting an encoding from\n  // label.\n  var encoding = getEncoding(label);\n\n  // 2. If encoding is failure or replacement, throw a RangeError.\n  if (encoding === null || encoding.name === 'replacement')\n    throw RangeError('Unknown encoding: ' + label);\n  if (!decoders[encoding.name]) {\n    throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n\n  // 3. Let dec be a new TextDecoder object.\n  var dec = this;\n\n  // 4. Set dec's encoding to encoding.\n  dec._encoding = encoding;\n\n  // 5. If options's fatal member is true, set dec's error mode to\n  // fatal.\n  if (Boolean(options['fatal'])) dec._error_mode = 'fatal';\n\n  // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n  // flag.\n  if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true;\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) {\n    this.encoding = dec._encoding.name.toLowerCase();\n    this.fatal = dec._error_mode === 'fatal';\n    this.ignoreBOM = dec._ignoreBOM;\n  }\n\n  // 7. Return dec.\n  return dec;\n}\n\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextDecoder.prototype, 'encoding', {\n    /** @this {TextDecoder} */\n    get: function () {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n\n  // The fatal attribute's getter must return true if error mode\n  // is fatal, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'fatal', {\n    /** @this {TextDecoder} */\n    get: function () {\n      return this._error_mode === 'fatal';\n    }\n  });\n\n  // The ignoreBOM attribute's getter must return true if ignore\n  // BOM flag is set, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n    /** @this {TextDecoder} */\n    get: function () {\n      return this._ignoreBOM;\n    }\n  });\n}\n\n/**\n * @param {BufferSource=} input The buffer of bytes to decode.\n * @param {Object=} options\n * @return {string} The decoded string.\n */\nTextDecoder.prototype.decode = function decode(input, options) {\n  var bytes;\n  if (typeof input === 'object' && input instanceof ArrayBuffer) {\n    bytes = new Uint8Array(input);\n  } else if (\n    typeof input === 'object' &&\n    'buffer' in input &&\n    input.buffer instanceof ArrayBuffer\n  ) {\n    bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n  } else {\n    bytes = new Uint8Array(0);\n  }\n\n  options = ToDictionary(options);\n\n  // 1. If the do not flush flag is unset, set decoder to a new\n  // encoding's decoder, set stream to a new stream, and unset the\n  // BOM seen flag.\n  if (!this._do_not_flush) {\n    this._decoder = decoders[this._encoding.name]({\n      fatal: this._error_mode === 'fatal'\n    });\n    this._BOMseen = false;\n  }\n\n  // 2. If options's stream is true, set the do not flush flag, and\n  // unset the do not flush flag otherwise.\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 3. If input is given, push a copy of input to stream.\n  // TODO: Align with spec algorithm - maintain stream on instance.\n  var input_stream = new Stream(bytes);\n\n  // 4. Let output be a new stream.\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n\n  // 5. While true:\n  while (true) {\n    // 1. Let token be the result of reading from stream.\n    var token = input_stream.read();\n\n    // 2. If token is end-of-stream and the do not flush flag is\n    // set, return output, serialized.\n    // TODO: Align with spec algorithm.\n    if (token === end_of_stream) break;\n\n    // 3. Otherwise, run these subsubsteps:\n\n    // 1. Let result be the result of processing token for decoder,\n    // stream, output, and error mode.\n    result = this._decoder.handler(input_stream, token);\n\n    // 2. If result is finished, return output, serialized.\n    if (result === finished) break;\n\n    if (result !== null) {\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ result);\n      else output.push(result);\n    }\n\n    // 3. Otherwise, if result is error, throw a TypeError.\n    // (Thrown in handler)\n\n    // 4. Otherwise, do nothing.\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    do {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished) break;\n      if (result === null) continue;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ result);\n      else output.push(result);\n    } while (!input_stream.endOfStream());\n    this._decoder = null;\n  }\n\n  // A TextDecoder object also has an associated serialize stream\n  // algorithm...\n  /**\n   * @param {!Array.<number>} stream\n   * @return {string}\n   * @this {TextDecoder}\n   */\n  function serializeStream(stream) {\n    // 1. Let token be the result of reading from stream.\n    // (Done in-place on array, rather than as a stream)\n\n    // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n    // BOM flag and BOM seen flag are unset, run these subsubsteps:\n    if (\n      includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n      !this._ignoreBOM &&\n      !this._BOMseen\n    ) {\n      if (stream.length > 0 && stream[0] === 0xfeff) {\n        // 1. If token is U+FEFF, set BOM seen flag.\n        this._BOMseen = true;\n        stream.shift();\n      } else if (stream.length > 0) {\n        // 2. Otherwise, if token is not end-of-stream, set BOM seen\n        // flag and append token to stream.\n        this._BOMseen = true;\n      } else {\n        // 3. Otherwise, if token is not end-of-stream, append token\n        // to output.\n        // (no-op)\n      }\n    }\n    // 4. Otherwise, return output.\n    return codePointsToString(stream);\n  }\n\n  return serializeStream.call(this, output);\n};\n\n// 8.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding. NONSTANDARD.\n * @param {Object=} options NONSTANDARD.\n */\nfunction TextEncoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextEncoder))\n    throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  options = ToDictionary(options);\n\n  // A TextEncoder object has an associated encoding and encoder.\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n\n  // Non-standard\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n  /** @private @type {string} */\n  this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n  // 1. Let enc be a new TextEncoder object.\n  var enc = this;\n\n  // 2. Set enc's encoding to UTF-8's encoder.\n  if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n    // NONSTANDARD behavior.\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    var encoding = getEncoding(label);\n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!encoders[encoding.name]) {\n      throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    }\n    enc._encoding = encoding;\n  } else {\n    // Standard behavior.\n    enc._encoding = getEncoding('utf-8');\n\n    if (label !== undefined && 'console' in global) {\n      console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');\n    }\n  }\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase();\n\n  // 3. Return enc.\n  return enc;\n}\n\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextEncoder.prototype, 'encoding', {\n    /** @this {TextEncoder} */\n    get: function () {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n}\n\n/**\n * @param {string=} opt_string The string to encode.\n * @param {Object=} options\n * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n */\nTextEncoder.prototype.encode = function encode(opt_string, options) {\n  opt_string = opt_string === undefined ? '' : String(opt_string);\n  options = ToDictionary(options);\n\n  // NOTE: This option is nonstandard. None of the encodings\n  // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n  // the input is a USVString so streaming is not necessary.\n  if (!this._do_not_flush)\n    this._encoder = encoders[this._encoding.name]({\n      fatal: this._fatal === 'fatal'\n    });\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 1. Convert input to a stream.\n  var input = new Stream(stringToCodePoints(opt_string));\n\n  // 2. Let output be a new stream\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n  // 3. While true, run these substeps:\n  while (true) {\n    // 1. Let token be the result of reading from input.\n    var token = input.read();\n    if (token === end_of_stream) break;\n    // 2. Let result be the result of processing token for encoder,\n    // input, output.\n    result = this._encoder.handler(input, token);\n    if (result === finished) break;\n    if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ result);\n    else output.push(result);\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    while (true) {\n      result = this._encoder.handler(input, input.read());\n      if (result === finished) break;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ result);\n      else output.push(result);\n    }\n    this._encoder = null;\n  }\n  // 3. If result is finished, convert output into a byte sequence,\n  // and then return a Uint8Array object wrapping an ArrayBuffer\n  // containing output.\n  return new Uint8Array(output);\n};\n\n//\n// 9. The encoding\n//\n\n// 9.1 utf-8\n\n// 9.1.1 utf-8 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n    /** @type {number} */ utf8_bytes_seen = 0,\n    /** @type {number} */ utf8_bytes_needed = 0,\n    /** @type {number} */ utf8_lower_boundary = 0x80,\n    /** @type {number} */ utf8_upper_boundary = 0xbf;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      else if (inRange(bite, 0xc2, 0xdf)) {\n        // 1. Set utf-8 bytes needed to 1.\n        utf8_bytes_needed = 1;\n\n        // 2. Set UTF-8 code point to byte & 0x1F.\n        utf8_code_point = bite & 0x1f;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xe0, 0xef)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xe0) utf8_lower_boundary = 0xa0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xed) utf8_upper_boundary = 0x9f;\n        // 3. Set utf-8 bytes needed to 2.\n        utf8_bytes_needed = 2;\n        // 4. Set UTF-8 code point to byte & 0xF.\n        utf8_code_point = bite & 0xf;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xf0, 0xf4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xf0) utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xf4) utf8_upper_boundary = 0x8f;\n        // 3. Set utf-8 bytes needed to 3.\n        utf8_bytes_needed = 3;\n        // 4. Set UTF-8 code point to byte & 0x7.\n        utf8_code_point = bite & 0x7;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Return continue.\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, inclusive, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xbf;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xbf;\n\n    // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n    // 0x3F)\n    utf8_code_point = (utf8_code_point << 6) | (bite & 0x3f);\n\n    // 7. Increase utf-8 bytes seen by one.\n    utf8_bytes_seen += 1;\n\n    // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed) return null;\n\n    // 9. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 11. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 9.1.2 utf-8 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF, inclusive:\n    if (inRange(code_point, 0x0080, 0x07ff)) {\n      // 1 and 0xC0\n      count = 1;\n      offset = 0xc0;\n    }\n    // U+0800 to U+FFFF, inclusive:\n    else if (inRange(code_point, 0x0800, 0xffff)) {\n      // 2 and 0xE0\n      count = 2;\n      offset = 0xe0;\n    }\n    // U+10000 to U+10FFFF, inclusive:\n    else if (inRange(code_point, 0x10000, 0x10ffff)) {\n      // 3 and 0xF0\n      count = 3;\n      offset = 0xf0;\n    }\n\n    // 4. Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3f));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['UTF-8'] = function (options) {\n  return new UTF8Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-8'] = function (options) {\n  return new UTF8Decoder(options);\n};\n\n//\n// 10. Legacy single-byte encodings\n//\n\n// 10.1 single-byte decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {!Array.<number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteDecoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Let code point be the index code point for byte − 0x80 in\n    // index single-byte.\n    var code_point = index[bite - 0x80];\n\n    // 4. If code point is null, return error.\n    if (code_point === null) return decoderError(fatal);\n\n    // 5. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 10.2 single-byte encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {!Array.<?number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteEncoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // single-byte.\n    var pointer = indexPointerFor(code_point, index);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) encoderError(code_point);\n\n    // 5. Return a byte whose value is pointer + 0x80.\n    return pointer + 0x80;\n  };\n}\n\n(function () {\n  if (!('encoding-indexes' in global)) return;\n  encodings.forEach(function (category) {\n    if (category.heading !== 'Legacy single-byte encodings') return;\n    category.encodings.forEach(function (encoding) {\n      var name = encoding.name;\n      var idx = index(name.toLowerCase());\n      /** @param {{fatal: boolean}} options */\n      decoders[name] = function (options) {\n        return new SingleByteDecoder(idx, options);\n      };\n      /** @param {{fatal: boolean}} options */\n      encoders[name] = function (options) {\n        return new SingleByteEncoder(idx, options);\n      };\n    });\n  });\n})();\n\n//\n// 11. Legacy multi-byte Chinese (simplified) encodings\n//\n\n// 11.1 gbk\n\n// 11.1.1 gbk decoder\n// gbk's decoder is gb18030's decoder.\n/** @param {{fatal: boolean}} options */\ndecoders['GBK'] = function (options) {\n  return new GB18030Decoder(options);\n};\n\n// 11.1.2 gbk encoder\n// gbk's encoder is gb18030's encoder with its gbk flag set.\n/** @param {{fatal: boolean}} options */\nencoders['GBK'] = function (options) {\n  return new GB18030Encoder(options, true);\n};\n\n// 11.2 gb18030\n\n// 11.2.1 gb18030 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction GB18030Decoder(options) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gb18030 first, gb18030\n  // second, and gb18030 third (all initially 0x00).\n  var /** @type {number} */ gb18030_first = 0x00,\n    /** @type {number} */ gb18030_second = 0x00,\n    /** @type {number} */ gb18030_third = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and gb18030 first, gb18030\n    // second, and gb18030 third are 0x00, return finished.\n    if (\n      bite === end_of_stream &&\n      gb18030_first === 0x00 &&\n      gb18030_second === 0x00 &&\n      gb18030_third === 0x00\n    ) {\n      return finished;\n    }\n    // 2. If byte is end-of-stream, and gb18030 first, gb18030\n    // second, or gb18030 third is not 0x00, set gb18030 first,\n    // gb18030 second, and gb18030 third to 0x00, and return error.\n    if (\n      bite === end_of_stream &&\n      (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)\n    ) {\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n      decoderError(fatal);\n    }\n    var code_point;\n    // 3. If gb18030 third is not 0x00, run these substeps:\n    if (gb18030_third !== 0x00) {\n      // 1. Let code point be null.\n      code_point = null;\n      // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n      // code point to the index gb18030 ranges code point for\n      // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n      // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030RangesCodePointFor(\n          (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) *\n            10 +\n            bite -\n            0x30\n        );\n      }\n\n      // 3. Let buffer be a byte sequence consisting of gb18030\n      // second, gb18030 third, and byte, in order.\n      var buffer = [gb18030_second, gb18030_third, bite];\n\n      // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n      // 0x00.\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n\n      // 5. If code point is null, prepend buffer to stream and\n      // return error.\n      if (code_point === null) {\n        stream.prepend(buffer);\n        return decoderError(fatal);\n      }\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If gb18030 second is not 0x00, run these substeps:\n    if (gb18030_second !== 0x00) {\n      // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 third to byte and return continue.\n      if (inRange(bite, 0x81, 0xfe)) {\n        gb18030_third = bite;\n        return null;\n      }\n\n      // 2. Prepend gb18030 second followed by byte to stream, set\n      // gb18030 first and gb18030 second to 0x00, and return error.\n      stream.prepend([gb18030_second, bite]);\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 5. If gb18030 first is not 0x00, run these substeps:\n    if (gb18030_first !== 0x00) {\n      // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n      // gb18030 second to byte and return continue.\n      if (inRange(bite, 0x30, 0x39)) {\n        gb18030_second = bite;\n        return null;\n      }\n\n      // 2. Let lead be gb18030 first, let pointer be null, and set\n      // gb18030 first to 0x00.\n      var lead = gb18030_first;\n      var pointer = null;\n      gb18030_first = 0x00;\n\n      // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfe))\n        pointer = (lead - 0x81) * 190 + (bite - offset);\n\n      // 5. Let code point be null if pointer is null and the index\n      // code point for pointer in index gb18030 otherwise.\n      code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x80, return code point U+20AC.\n    if (bite === 0x80) return 0x20ac;\n\n    // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // gb18030 first to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      gb18030_first = bite;\n      return null;\n    }\n\n    // 9. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 11.2.2 gb18030 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n * @param {boolean=} gbk_flag\n */\nfunction GB18030Encoder(options, gbk_flag) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gbk flag (initially unset).\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+E5E5, return error with code point.\n    if (code_point === 0xe5e5) return encoderError(code_point);\n\n    // 4. If the gbk flag is set and code point is U+20AC, return\n    // byte 0x80.\n    if (gbk_flag && code_point === 0x20ac) return 0x80;\n\n    // 5. Let pointer be the index pointer for code point in index\n    // gb18030.\n    var pointer = indexPointerFor(code_point, index('gb18030'));\n\n    // 6. If pointer is not null, run these substeps:\n    if (pointer !== null) {\n      // 1. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 2. Let trail be pointer % 190.\n      var trail = pointer % 190;\n\n      // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n      var offset = trail < 0x3f ? 0x40 : 0x41;\n\n      // 4. Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    }\n\n    // 7. If gbk flag is set, return error with code point.\n    if (gbk_flag) return encoderError(code_point);\n\n    // 8. Set pointer to the index gb18030 ranges pointer for code\n    // point.\n    pointer = indexGB18030RangesPointerFor(code_point);\n\n    // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n    var byte1 = floor(pointer / 10 / 126 / 10);\n\n    // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n    pointer = pointer - byte1 * 10 * 126 * 10;\n\n    // 11. Let byte2 be floor(pointer / 10 / 126).\n    var byte2 = floor(pointer / 10 / 126);\n\n    // 12. Set pointer to pointer − byte2 × 10 × 126.\n    pointer = pointer - byte2 * 10 * 126;\n\n    // 13. Let byte3 be floor(pointer / 10).\n    var byte3 = floor(pointer / 10);\n\n    // 14. Let byte4 be pointer − byte3 × 10.\n    var byte4 = pointer - byte3 * 10;\n\n    // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n    // 0x30, byte3 + 0x81, byte4 + 0x30.\n    return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['gb18030'] = function (options) {\n  return new GB18030Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['gb18030'] = function (options) {\n  return new GB18030Decoder(options);\n};\n\n//\n// 12. Legacy multi-byte Chinese (traditional) encodings\n//\n\n// 12.1 Big5\n\n// 12.1.1 Big5 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Decoder(options) {\n  var fatal = options.fatal;\n  // Big5's decoder has an associated Big5 lead (initially 0x00).\n  var /** @type {number} */ Big5_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n    // Big5 lead to 0x00 and return error.\n    if (bite === end_of_stream && Big5_lead !== 0x00) {\n      Big5_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && Big5_lead === 0x00) return finished;\n\n    // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n    // pointer be null, set Big5 lead to 0x00, and then run these\n    // substeps:\n    if (Big5_lead !== 0x00) {\n      var lead = Big5_lead;\n      var pointer = null;\n      Big5_lead = 0x00;\n\n      // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x62;\n\n      // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0xa1, 0xfe))\n        pointer = (lead - 0x81) * 157 + (bite - offset);\n\n      // 3. If there is a row in the table below whose first column\n      // is pointer, return the two code points listed in its second\n      // column\n      // Pointer | Code points\n      // --------+--------------\n      // 1133    | U+00CA U+0304\n      // 1135    | U+00CA U+030C\n      // 1164    | U+00EA U+0304\n      // 1166    | U+00EA U+030C\n      switch (pointer) {\n        case 1133:\n          return [0x00ca, 0x0304];\n        case 1135:\n          return [0x00ca, 0x030c];\n        case 1164:\n          return [0x00ea, 0x0304];\n        case 1166:\n          return [0x00ea, 0x030c];\n      }\n\n      // 4. Let code point be null if pointer is null and the index\n      // code point for pointer in index Big5 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5'));\n\n      // 5. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 6. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 7. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n    // lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      Big5_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 12.1.2 Big5 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index Big5 pointer for code point.\n    var pointer = indexBig5PointerFor(code_point);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 157) + 0x81.\n    var lead = floor(pointer / 157) + 0x81;\n\n    // 6. If lead is less than 0xA1, return error with code point.\n    if (lead < 0xa1) return encoderError(code_point);\n\n    // 7. Let trail be pointer % 157.\n    var trail = pointer % 157;\n\n    // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x62;\n\n    // Return two bytes whose values are lead and trail + offset.\n    return [lead, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Big5'] = function (options) {\n  return new Big5Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Big5'] = function (options) {\n  return new Big5Decoder(options);\n};\n\n//\n// 13. Legacy multi-byte Japanese encodings\n//\n\n// 13.1 euc-jp\n\n// 13.1.1 euc-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-jp's decoder has an associated euc-jp jis0212 flag\n  // (initially unset) and euc-jp lead (initially 0x00).\n  var /** @type {boolean} */ eucjp_jis0212_flag = false,\n    /** @type {number} */ eucjp_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n    // euc-jp lead to 0x00, and return error.\n    if (bite === end_of_stream && eucjp_lead !== 0x00) {\n      eucjp_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && eucjp_lead === 0x00) return finished;\n\n    // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n    // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n    // point whose value is 0xFF61 − 0xA1 + byte.\n    if (eucjp_lead === 0x8e && inRange(bite, 0xa1, 0xdf)) {\n      eucjp_lead = 0x00;\n      return 0xff61 - 0xa1 + bite;\n    }\n\n    // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n    // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n    // to byte, and return continue.\n    if (eucjp_lead === 0x8f && inRange(bite, 0xa1, 0xfe)) {\n      eucjp_jis0212_flag = true;\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n    // euc-jp lead to 0x00, and run these substeps:\n    if (eucjp_lead !== 0x00) {\n      var lead = eucjp_lead;\n      eucjp_lead = 0x00;\n\n      // 1. Let code point be null.\n      var code_point = null;\n\n      // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n      // inclusive, set code point to the index code point for (lead\n      // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n      // jis0212 flag is unset and in index jis0212 otherwise.\n      if (inRange(lead, 0xa1, 0xfe) && inRange(bite, 0xa1, 0xfe)) {\n        code_point = indexCodePointFor(\n          (lead - 0xa1) * 94 + (bite - 0xa1),\n          index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212')\n        );\n      }\n\n      // 3. Unset the euc-jp jis0212 flag.\n      eucjp_jis0212_flag = false;\n\n      // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n      // prepend byte to stream.\n      if (!inRange(bite, 0xa1, 0xfe)) stream.prepend(bite);\n\n      // 5. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n    // inclusive, set euc-jp lead to byte and return continue.\n    if (bite === 0x8e || bite === 0x8f || inRange(bite, 0xa1, 0xfe)) {\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 8. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.1.2 euc-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return two bytes whose values are 0x8E and code point −\n    // 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return [0x8e, code_point - 0xff61 + 0xa1];\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 94) + 0xA1.\n    var lead = floor(pointer / 94) + 0xa1;\n\n    // 10. Let trail be pointer % 94 + 0xA1.\n    var trail = (pointer % 94) + 0xa1;\n\n    // 11. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-JP'] = function (options) {\n  return new EUCJPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-JP'] = function (options) {\n  return new EUCJPDecoder(options);\n};\n\n// 13.2 iso-2022-jp\n\n// 13.2.1 iso-2022-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPDecoder(options) {\n  var fatal = options.fatal;\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    Katakana: 2,\n    LeadByte: 3,\n    TrailByte: 4,\n    EscapeStart: 5,\n    Escape: 6\n  };\n  // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n  // state (initially ASCII), iso-2022-jp decoder output state\n  // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n  // iso-2022-jp output flag (initially unset).\n  var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n    /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n    /** @type {number} */ iso2022jp_lead = 0x00,\n    /** @type {boolean} */ iso2022jp_output_flag = false;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // switching on iso-2022-jp decoder state:\n    switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7f) && bite !== 0x0e && bite !== 0x0f && bite !== 0x1b) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5c) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00a5;\n        }\n\n        // 0x7E\n        if (bite === 0x7e) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203e;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (\n          inRange(bite, 0x00, 0x7f) &&\n          bite !== 0x0e &&\n          bite !== 0x0f &&\n          bite !== 0x1b &&\n          bite !== 0x5c &&\n          bite !== 0x7e\n        ) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5f)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xff61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null) return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42) state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4a) state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49) state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n    }\n  };\n}\n\n// 13.2.2 iso-2022-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPEncoder(options) {\n  var fatal = options.fatal;\n  // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n  // state which is one of ASCII, Roman, and jis0208 (initially\n  // ASCII).\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    jis0208: 2\n  };\n  var /** @type {number} */ iso2022jp_state = states.ASCII;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream and iso-2022-jp encoder\n    // state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 2. If code point is end-of-stream and iso-2022-jp encoder\n    // state is ASCII, return finished.\n    if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished;\n\n    // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n    // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n    if (\n      (iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) &&\n      (code_point === 0x000e || code_point === 0x000f || code_point === 0x001b)\n    ) {\n      return encoderError(0xfffd);\n    }\n\n    // 4. If iso-2022-jp encoder state is ASCII and code point is an\n    // ASCII code point, return a byte whose value is code point.\n    if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point;\n\n    // 5. If iso-2022-jp encoder state is Roman and code point is an\n    // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n    // or U+203E, run these substeps:\n    if (\n      iso2022jp_state === states.Roman &&\n      ((isASCIICodePoint(code_point) && code_point !== 0x005c && code_point !== 0x007e) ||\n        code_point == 0x00a5 ||\n        code_point == 0x203e)\n    ) {\n      // 1. If code point is an ASCII code point, return a byte\n      // whose value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 2. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00a5) return 0x5c;\n\n      // 3. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203e) return 0x7e;\n    }\n\n    // 6. If code point is an ASCII code point, and iso-2022-jp\n    // encoder state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n    // encoder state is not Roman, prepend code point to stream, set\n    // iso-2022-jp encoder state to Roman, and return three bytes\n    // 0x1B 0x28 0x4A.\n    if ((code_point === 0x00a5 || code_point === 0x203e) && iso2022jp_state !== states.Roman) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.Roman;\n      return [0x1b, 0x28, 0x4a];\n    }\n\n    // 8. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 9. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 10. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n    // point to stream, set iso-2022-jp encoder state to jis0208,\n    // and return three bytes 0x1B 0x24 0x42.\n    if (iso2022jp_state !== states.jis0208) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.jis0208;\n      return [0x1b, 0x24, 0x42];\n    }\n\n    // 12. Let lead be floor(pointer / 94) + 0x21.\n    var lead = floor(pointer / 94) + 0x21;\n\n    // 13. Let trail be pointer % 94 + 0x21.\n    var trail = (pointer % 94) + 0x21;\n\n    // 14. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['ISO-2022-JP'] = function (options) {\n  return new ISO2022JPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['ISO-2022-JP'] = function (options) {\n  return new ISO2022JPDecoder(options);\n};\n\n// 13.3 Shift_JIS\n\n// 13.3.1 Shift_JIS decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISDecoder(options) {\n  var fatal = options.fatal;\n  // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n  // 0x00).\n  var /** @type {number} */ Shift_JIS_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n    // set Shift_JIS lead to 0x00 and return error.\n    if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n      Shift_JIS_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n    // return finished.\n    if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished;\n\n    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n    // let pointer be null, set Shift_JIS lead to 0x00, and then run\n    // these substeps:\n    if (Shift_JIS_lead !== 0x00) {\n      var lead = Shift_JIS_lead;\n      var pointer = null;\n      Shift_JIS_lead = 0x00;\n\n      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n      // 0xC1 otherwise.\n      var lead_offset = lead < 0xa0 ? 0x81 : 0xc1;\n\n      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n      // 188 + byte − offset.\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfc))\n        pointer = (lead - lead_offset) * 188 + bite - offset;\n\n      // 4. If pointer is in the range 8836 to 10715, inclusive,\n      // return a code point whose value is 0xE000 − 8836 + pointer.\n      if (inRange(pointer, 8836, 10715)) return 0xe000 - 8836 + pointer;\n\n      // 5. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index jis0208 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte or 0x80, return a code point\n    // whose value is byte.\n    if (isASCIIByte(bite) || bite === 0x80) return bite;\n\n    // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n    // code point whose value is 0xFF61 − 0xA1 + byte.\n    if (inRange(bite, 0xa1, 0xdf)) return 0xff61 - 0xa1 + bite;\n\n    // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n    // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n    // continue.\n    if (inRange(bite, 0x81, 0x9f) || inRange(bite, 0xe0, 0xfc)) {\n      Shift_JIS_lead = bite;\n      return null;\n    }\n\n    // 7. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.3.2 Shift_JIS encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point or U+0080, return a\n    // byte whose value is code point.\n    if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return a byte whose value is code point − 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return code_point - 0xff61 + 0xa1;\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index Shift_JIS pointer for code point.\n    var pointer = indexShiftJISPointerFor(code_point);\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 188).\n    var lead = floor(pointer / 188);\n\n    // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n    // 0xC1 otherwise.\n    var lead_offset = lead < 0x1f ? 0x81 : 0xc1;\n\n    // 11. Let trail be pointer % 188.\n    var trail = pointer % 188;\n\n    // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x41;\n\n    // 13. Return two bytes whose values are lead + lead offset and\n    // trail + offset.\n    return [lead + lead_offset, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Shift_JIS'] = function (options) {\n  return new ShiftJISEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Shift_JIS'] = function (options) {\n  return new ShiftJISDecoder(options);\n};\n\n//\n// 14. Legacy multi-byte Korean encodings\n//\n\n// 14.1 euc-kr\n\n// 14.1.1 euc-kr decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKRDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n  var /** @type {number} */ euckr_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n    // euc-kr lead to 0x00 and return error.\n    if (bite === end_of_stream && euckr_lead !== 0) {\n      euckr_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && euckr_lead === 0) return finished;\n\n    // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n    // pointer be null, set euc-kr lead to 0x00, and then run these\n    // substeps:\n    if (euckr_lead !== 0x00) {\n      var lead = euckr_lead;\n      var pointer = null;\n      euckr_lead = 0x00;\n\n      // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n      // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n      if (inRange(bite, 0x41, 0xfe)) pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n      // 2. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index euc-kr otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n      // 3. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (pointer === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 4. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // euc-kr lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      euckr_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 14.1.2 euc-kr encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKREncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // euc-kr.\n    var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 190) + 0x81.\n    var lead = floor(pointer / 190) + 0x81;\n\n    // 6. Let trail be pointer % 190 + 0x41.\n    var trail = (pointer % 190) + 0x41;\n\n    // 7. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-KR'] = function (options) {\n  return new EUCKREncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-KR'] = function (options) {\n  return new EUCKRDecoder(options);\n};\n\n//\n// 15. Legacy miscellaneous encodings\n//\n\n// 15.1 replacement\n\n// Not needed - API throws RangeError\n\n// 15.2 Common infrastructure for utf-16be and utf-16le\n\n/**\n * @param {number} code_unit\n * @param {boolean} utf16be\n * @return {!Array.<number>} bytes\n */\nfunction convertCodeUnitToBytes(code_unit, utf16be) {\n  // 1. Let byte1 be code unit >> 8.\n  var byte1 = code_unit >> 8;\n\n  // 2. Let byte2 be code unit & 0x00FF.\n  var byte2 = code_unit & 0x00ff;\n\n  // 3. Then return the bytes in order:\n  // utf-16be flag is set: byte1, then byte2.\n  if (utf16be) return [byte1, byte2];\n  // utf-16be flag is unset: byte2, then byte1.\n  return [byte2, byte1];\n}\n\n// 15.2.1 shared utf-16 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Decoder(utf16_be, options) {\n  var fatal = options.fatal;\n  var /** @type {?number} */ utf16_lead_byte = null,\n    /** @type {?number} */ utf16_lead_surrogate = null;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and either utf-16 lead byte or\n    // utf-16 lead surrogate is not null, set utf-16 lead byte and\n    // utf-16 lead surrogate to null, and return error.\n    if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n    // lead surrogate are null, return finished.\n    if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n      return finished;\n    }\n\n    // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n    // and return continue.\n    if (utf16_lead_byte === null) {\n      utf16_lead_byte = bite;\n      return null;\n    }\n\n    // 4. Let code unit be the result of:\n    var code_unit;\n    if (utf16_be) {\n      // utf-16be decoder flag is set\n      //   (utf-16 lead byte << 8) + byte.\n      code_unit = (utf16_lead_byte << 8) + bite;\n    } else {\n      // utf-16be decoder flag is unset\n      //   (byte << 8) + utf-16 lead byte.\n      code_unit = (bite << 8) + utf16_lead_byte;\n    }\n    // Then set utf-16 lead byte to null.\n    utf16_lead_byte = null;\n\n    // 5. If utf-16 lead surrogate is not null, let lead surrogate\n    // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n    // and then run these substeps:\n    if (utf16_lead_surrogate !== null) {\n      var lead_surrogate = utf16_lead_surrogate;\n      utf16_lead_surrogate = null;\n\n      // 1. If code unit is in the range U+DC00 to U+DFFF,\n      // inclusive, return a code point whose value is 0x10000 +\n      // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n      if (inRange(code_unit, 0xdc00, 0xdfff)) {\n        return 0x10000 + (lead_surrogate - 0xd800) * 0x400 + (code_unit - 0xdc00);\n      }\n\n      // 2. Prepend the sequence resulting of converting code unit\n      // to bytes using utf-16be decoder flag to stream and return\n      // error.\n      stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n      return decoderError(fatal);\n    }\n\n    // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n    // set utf-16 lead surrogate to code unit and return continue.\n    if (inRange(code_unit, 0xd800, 0xdbff)) {\n      utf16_lead_surrogate = code_unit;\n      return null;\n    }\n\n    // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n    // return error.\n    if (inRange(code_unit, 0xdc00, 0xdfff)) return decoderError(fatal);\n\n    // 8. Return code point code unit.\n    return code_unit;\n  };\n}\n\n// 15.2.2 shared utf-16 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Encoder(utf16_be, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n    // return the sequence resulting of converting code point to\n    // bytes using utf-16be encoder flag.\n    if (inRange(code_point, 0x0000, 0xffff)) return convertCodeUnitToBytes(code_point, utf16_be);\n\n    // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n    // converted to bytes using utf-16be encoder flag.\n    var lead = convertCodeUnitToBytes(((code_point - 0x10000) >> 10) + 0xd800, utf16_be);\n\n    // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n    // converted to bytes using utf-16be encoder flag.\n    var trail = convertCodeUnitToBytes(((code_point - 0x10000) & 0x3ff) + 0xdc00, utf16_be);\n\n    // 5. Return a byte sequence of lead followed by trail.\n    return lead.concat(trail);\n  };\n}\n\n// 15.3 utf-16be\n// 15.3.1 utf-16be decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16BE'] = function (options) {\n  return new UTF16Encoder(true, options);\n};\n// 15.3.2 utf-16be encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16BE'] = function (options) {\n  return new UTF16Decoder(true, options);\n};\n\n// 15.4 utf-16le\n// 15.4.1 utf-16le decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16LE'] = function (options) {\n  return new UTF16Encoder(false, options);\n};\n// 15.4.2 utf-16le encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16LE'] = function (options) {\n  return new UTF16Decoder(false, options);\n};\n\n// 15.5 x-user-defined\n\n// 15.5.1 x-user-defined decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedDecoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n    return 0xf780 + bite - 0x80;\n  };\n}\n\n// 15.5.2 x-user-defined encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1.If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n    // return a byte whose value is code point − 0xF780 + 0x80.\n    if (inRange(code_point, 0xf780, 0xf7ff)) return code_point - 0xf780 + 0x80;\n\n    // 4. Return error with code point.\n    return encoderError(code_point);\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['x-user-defined'] = function (options) {\n  return new XUserDefinedEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['x-user-defined'] = function (options) {\n  return new XUserDefinedDecoder(options);\n};\n\n// FORK\n// if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;\n// if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;\n// babel.config.js skip transpiling files in `libs/`\n// module.exports = {TextEncoder, TextDecoder};\nexport {TextEncoder, TextDecoder};\n"],"mappings":"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"}