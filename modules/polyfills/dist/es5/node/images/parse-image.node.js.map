{"version":3,"file":"parse-image.node.js","names":["_getPixels","_interopRequireDefault","require","NODE_FORMAT_SUPPORT","exports","parseImageNode","_x","_x2","_parseImageNode","apply","arguments","_asyncToGenerator2","default","_regenerator","mark","_callee","arrayBuffer","mimeType","buffer","ndarray","wrap","_callee$","_context","prev","next","Error","Buffer","from","getPixelsAsync","sent","abrupt","stop","Promise","resolve","getPixels","err","shape","_toConsumableArray2","layers","length","shift","data","Uint8Array","width","height","components"],"sources":["../../../../src/node/images/parse-image.node.ts"],"sourcesContent":["// loaders.gl, MIT license\n\nimport getPixels from 'get-pixels';\n\n/** Declares which image format mime types this loader polyfill supports */\nexport const NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];\n\n// Note: These types are also defined in @loaders.gl/images and need to be kept in sync\ntype NDArray = {\n  shape: number[];\n  data: Uint8Array;\n  width: number;\n  height: number;\n  components: number;\n  layers: number[];\n};\n\nexport async function parseImageNode(arrayBuffer: ArrayBuffer, mimeType: string): Promise<NDArray> {\n  if (!mimeType) {\n    throw new Error('MIMEType is required to parse image under Node.js');\n  }\n\n  const buffer = arrayBuffer instanceof Buffer ? arrayBuffer : Buffer.from(arrayBuffer);\n  const ndarray = await getPixelsAsync(buffer, mimeType);\n  return ndarray;\n}\n\n// TODO - check if getPixels callback is asynchronous if provided with buffer input\n// if not, parseImage can be a sync function\nfunction getPixelsAsync(buffer: Buffer, mimeType: string): Promise<NDArray> {\n  return new Promise<NDArray>((resolve) =>\n    getPixels(buffer, mimeType, (err, ndarray) => {\n      if (err) {\n        throw err;\n      }\n\n      const shape = [...ndarray.shape];\n      const layers = ndarray.shape.length === 4 ? ndarray.shape.shift() : 1;\n      const data = ndarray.data instanceof Buffer ? new Uint8Array(ndarray.data) : ndarray.data;\n\n      // extract width/height etc\n      resolve({\n        shape,\n        data,\n        width: ndarray.shape[0],\n        height: ndarray.shape[1],\n        components: ndarray.shape[2],\n        // TODO - error\n        layers: layers ? [layers] : []\n      });\n    })\n  );\n}\n"],"mappings":";;;;;;;;;;;AAEA,IAAAA,UAAA,GAAAC,sBAAA,CAAAC,OAAA;AAGO,IAAMC,mBAAmB,GAAG,CAAC,WAAW,EAAE,YAAY,EAAE,WAAW,CAAC;AAACC,OAAA,CAAAD,mBAAA,GAAAA,mBAAA;AAAA,SAYtDE,cAAcA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,gBAAA;EAAAA,eAAA,OAAAG,kBAAA,CAAAC,OAAA,EAAAC,YAAA,CAAAD,OAAA,CAAAE,IAAA,CAA7B,SAAAC,QAA8BC,WAAwB,EAAEC,QAAgB;IAAA,IAAAC,MAAA,EAAAC,OAAA;IAAA,OAAAN,YAAA,CAAAD,OAAA,CAAAQ,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,IACxEP,QAAQ;YAAAK,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACL,IAAIC,KAAK,CAAC,mDAAmD,CAAC;QAAA;UAGhEP,MAAM,GAAGF,WAAW,YAAYU,MAAM,GAAGV,WAAW,GAAGU,MAAM,CAACC,IAAI,CAACX,WAAW,CAAC;UAAAM,QAAA,CAAAE,IAAA;UAAA,OAC/DI,cAAc,CAACV,MAAM,EAAED,QAAQ,CAAC;QAAA;UAAhDE,OAAO,GAAAG,QAAA,CAAAO,IAAA;UAAA,OAAAP,QAAA,CAAAQ,MAAA,WACNX,OAAO;QAAA;QAAA;UAAA,OAAAG,QAAA,CAAAS,IAAA;MAAA;IAAA,GAAAhB,OAAA;EAAA,CACf;EAAA,OAAAP,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAID,SAASkB,cAAcA,CAACV,MAAc,EAAED,QAAgB,EAAoB;EAC1E,OAAO,IAAIe,OAAO,CAAU,UAACC,OAAO;IAAA,OAClC,IAAAC,kBAAS,EAAChB,MAAM,EAAED,QAAQ,EAAE,UAACkB,GAAG,EAAEhB,OAAO,EAAK;MAC5C,IAAIgB,GAAG,EAAE;QACP,MAAMA,GAAG;MACX;MAEA,IAAMC,KAAK,OAAAC,mBAAA,CAAAzB,OAAA,EAAOO,OAAO,CAACiB,KAAK,CAAC;MAChC,IAAME,MAAM,GAAGnB,OAAO,CAACiB,KAAK,CAACG,MAAM,KAAK,CAAC,GAAGpB,OAAO,CAACiB,KAAK,CAACI,KAAK,CAAC,CAAC,GAAG,CAAC;MACrE,IAAMC,IAAI,GAAGtB,OAAO,CAACsB,IAAI,YAAYf,MAAM,GAAG,IAAIgB,UAAU,CAACvB,OAAO,CAACsB,IAAI,CAAC,GAAGtB,OAAO,CAACsB,IAAI;MAGzFR,OAAO,CAAC;QACNG,KAAK,EAALA,KAAK;QACLK,IAAI,EAAJA,IAAI;QACJE,KAAK,EAAExB,OAAO,CAACiB,KAAK,CAAC,CAAC,CAAC;QACvBQ,MAAM,EAAEzB,OAAO,CAACiB,KAAK,CAAC,CAAC,CAAC;QACxBS,UAAU,EAAE1B,OAAO,CAACiB,KAAK,CAAC,CAAC,CAAC;QAE5BE,MAAM,EAAEA,MAAM,GAAG,CAACA,MAAM,CAAC,GAAG;MAC9B,CAAC,CAAC;IACJ,CAAC,CAAC;EAAA,CACJ,CAAC;AACH"}