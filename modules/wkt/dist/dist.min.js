(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // src/lib/utils/version.ts
  var VERSION;
  var init_version = __esm({
    "src/lib/utils/version.ts"() {
      VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    }
  });

  // src/lib/parse-wkb.ts
  function parseWKB(arrayBuffer) {
    const view = new DataView(arrayBuffer);
    let offset = 0;
    const littleEndian = view.getUint8(offset) === 1;
    offset++;
    const geometryCode = view.getUint32(offset, littleEndian);
    offset += 4;
    const geometryType = geometryCode % 1e3;
    const type = (geometryCode - geometryType) / 1e3;
    const dimension = NUM_DIMENSIONS[type];
    switch (geometryType) {
      case 1:
        const point = parsePoint(view, offset, dimension, littleEndian);
        return point.geometry;
      case 2:
        const line = parseLineString(view, offset, dimension, littleEndian);
        return line.geometry;
      case 3:
        const polygon = parsePolygon(view, offset, dimension, littleEndian);
        return polygon.geometry;
      case 4:
        const multiPoint = parseMultiPoint(view, offset, dimension, littleEndian);
        multiPoint.type = "Point";
        return multiPoint;
      case 5:
        const multiLine = parseMultiLineString(view, offset, dimension, littleEndian);
        multiLine.type = "LineString";
        return multiLine;
      case 6:
        const multiPolygon = parseMultiPolygon(view, offset, dimension, littleEndian);
        multiPolygon.type = "Polygon";
        return multiPolygon;
      default:
        throw new Error(`WKB: Unsupported geometry type: ${geometryType}`);
    }
  }
  function parsePoint(view, offset, dimension, littleEndian) {
    const positions = new Float64Array(dimension);
    for (let i = 0; i < dimension; i++) {
      positions[i] = view.getFloat64(offset, littleEndian);
      offset += 8;
    }
    return {
      geometry: { type: "Point", positions: { value: positions, size: dimension } },
      offset
    };
  }
  function parseLineString(view, offset, dimension, littleEndian) {
    const nPoints = view.getUint32(offset, littleEndian);
    offset += 4;
    const positions = new Float64Array(nPoints * dimension);
    for (let i = 0; i < nPoints * dimension; i++) {
      positions[i] = view.getFloat64(offset, littleEndian);
      offset += 8;
    }
    const pathIndices = [0];
    if (nPoints > 0) {
      pathIndices.push(nPoints);
    }
    return {
      geometry: {
        type: "LineString",
        positions: { value: positions, size: dimension },
        pathIndices: { value: new Uint16Array(pathIndices), size: 1 }
      },
      offset
    };
  }
  function parsePolygon(view, offset, dimension, littleEndian) {
    const nRings = view.getUint32(offset, littleEndian);
    offset += 4;
    const rings = [];
    for (let i = 0; i < nRings; i++) {
      const parsed = parseLineString(view, offset, dimension, littleEndian);
      const { positions } = parsed.geometry;
      offset = parsed.offset;
      rings.push(positions.value);
    }
    const concatenatedPositions = new Float64Array(concatTypedArrays(rings).buffer);
    const polygonIndices = [0];
    if (concatenatedPositions.length > 0) {
      polygonIndices.push(concatenatedPositions.length / dimension);
    }
    const primitivePolygonIndices = rings.map((l) => l.length / dimension).map(cumulativeSum(0));
    primitivePolygonIndices.unshift(0);
    return {
      geometry: {
        type: "Polygon",
        positions: { value: concatenatedPositions, size: dimension },
        polygonIndices: {
          value: new Uint16Array(polygonIndices),
          size: 1
        },
        primitivePolygonIndices: { value: new Uint16Array(primitivePolygonIndices), size: 1 }
      },
      offset
    };
  }
  function parseMultiPoint(view, offset, dimension, littleEndian) {
    const nPoints = view.getUint32(offset, littleEndian);
    offset += 4;
    const binaryPointGeometries = [];
    for (let i = 0; i < nPoints; i++) {
      const littleEndianPoint = view.getUint8(offset) === 1;
      offset++;
      if (view.getUint32(offset, littleEndianPoint) % 1e3 !== 1) {
        throw new Error("WKB: Inner geometries of MultiPoint not of type Point");
      }
      offset += 4;
      const parsed = parsePoint(view, offset, dimension, littleEndianPoint);
      offset = parsed.offset;
      binaryPointGeometries.push(parsed.geometry);
    }
    return concatenateBinaryPointGeometries(binaryPointGeometries, dimension);
  }
  function parseMultiLineString(view, offset, dimension, littleEndian) {
    const nLines = view.getUint32(offset, littleEndian);
    offset += 4;
    const binaryLineGeometries = [];
    for (let i = 0; i < nLines; i++) {
      const littleEndianLine = view.getUint8(offset) === 1;
      offset++;
      if (view.getUint32(offset, littleEndianLine) % 1e3 !== 2) {
        throw new Error("WKB: Inner geometries of MultiLineString not of type LineString");
      }
      offset += 4;
      const parsed = parseLineString(view, offset, dimension, littleEndianLine);
      offset = parsed.offset;
      binaryLineGeometries.push(parsed.geometry);
    }
    return concatenateBinaryLineGeometries(binaryLineGeometries, dimension);
  }
  function parseMultiPolygon(view, offset, dimension, littleEndian) {
    const nPolygons = view.getUint32(offset, littleEndian);
    offset += 4;
    const binaryPolygonGeometries = [];
    for (let i = 0; i < nPolygons; i++) {
      const littleEndianPolygon = view.getUint8(offset) === 1;
      offset++;
      if (view.getUint32(offset, littleEndianPolygon) % 1e3 !== 3) {
        throw new Error("WKB: Inner geometries of MultiPolygon not of type Polygon");
      }
      offset += 4;
      const parsed = parsePolygon(view, offset, dimension, littleEndianPolygon);
      offset = parsed.offset;
      binaryPolygonGeometries.push(parsed.geometry);
    }
    return concatenateBinaryPolygonGeometries(binaryPolygonGeometries, dimension);
  }
  function concatenateBinaryPointGeometries(binaryPointGeometries, dimension) {
    const positions = binaryPointGeometries.map((geometry) => geometry.positions.value);
    const concatenatedPositions = new Float64Array(concatTypedArrays(positions).buffer);
    return {
      type: "Point",
      positions: { value: concatenatedPositions, size: dimension }
    };
  }
  function concatenateBinaryLineGeometries(binaryLineGeometries, dimension) {
    const lines = binaryLineGeometries.map((geometry) => geometry.positions.value);
    const concatenatedPositions = new Float64Array(concatTypedArrays(lines).buffer);
    const pathIndices = lines.map((line) => line.length / dimension).map(cumulativeSum(0));
    pathIndices.unshift(0);
    return {
      type: "LineString",
      positions: { value: concatenatedPositions, size: dimension },
      pathIndices: { value: new Uint16Array(pathIndices), size: 1 }
    };
  }
  function concatenateBinaryPolygonGeometries(binaryPolygonGeometries, dimension) {
    const polygons = [];
    const primitivePolygons = [];
    for (const binaryPolygon of binaryPolygonGeometries) {
      const { positions, primitivePolygonIndices: primitivePolygonIndices2 } = binaryPolygon;
      polygons.push(positions.value);
      primitivePolygons.push(primitivePolygonIndices2.value);
    }
    const concatenatedPositions = new Float64Array(concatTypedArrays(polygons).buffer);
    const polygonIndices = polygons.map((p) => p.length / dimension).map(cumulativeSum(0));
    polygonIndices.unshift(0);
    const primitivePolygonIndices = [0];
    for (const primitivePolygon of primitivePolygons) {
      primitivePolygonIndices.push(...primitivePolygon.filter((x) => x > 0).map((x) => x + primitivePolygonIndices[primitivePolygonIndices.length - 1]));
    }
    return {
      type: "Polygon",
      positions: { value: concatenatedPositions, size: dimension },
      polygonIndices: { value: new Uint16Array(polygonIndices), size: 1 },
      primitivePolygonIndices: { value: new Uint16Array(primitivePolygonIndices), size: 1 }
    };
  }
  function concatTypedArrays(arrays) {
    let byteLength = 0;
    for (let i = 0; i < arrays.length; ++i) {
      byteLength += arrays[i].byteLength;
    }
    const buffer = new Uint8Array(byteLength);
    let byteOffset = 0;
    for (let i = 0; i < arrays.length; ++i) {
      const data = new Uint8Array(arrays[i].buffer);
      byteLength = data.length;
      for (let j = 0; j < byteLength; ++j) {
        buffer[byteOffset++] = data[j];
      }
    }
    return buffer;
  }
  var NUM_DIMENSIONS, cumulativeSum;
  var init_parse_wkb = __esm({
    "src/lib/parse-wkb.ts"() {
      NUM_DIMENSIONS = {
        0: 2,
        1: 3,
        2: 3,
        3: 4
      };
      cumulativeSum = (sum) => (value) => sum += value;
    }
  });

  // src/wkb-loader.ts
  var WKBWorkerLoader, WKBLoader;
  var init_wkb_loader = __esm({
    "src/wkb-loader.ts"() {
      init_version();
      init_parse_wkb();
      WKBWorkerLoader = {
        name: "WKB",
        id: "wkb",
        module: "wkt",
        version: VERSION,
        worker: true,
        category: "geometry",
        extensions: ["wkb"],
        mimeTypes: [],
        options: {
          wkb: {}
        }
      };
      WKBLoader = {
        ...WKBWorkerLoader,
        parse: async (arrayBuffer) => parseWKB(arrayBuffer),
        parseSync: parseWKB
      };
    }
  });

  // src/lib/parse-wkt.ts
  function parseWKT(input) {
    const parts = input.split(";");
    let _ = parts.pop();
    const srid = (parts.shift() || "").split("=").pop();
    let i = 0;
    function $(re) {
      const match = _.substring(i).match(re);
      if (!match)
        return null;
      else {
        i += match[0].length;
        return match[0];
      }
    }
    function crs(obj) {
      if (obj && srid.match(/\d+/)) {
        obj.crs = {
          type: "name",
          properties: {
            name: "urn:ogc:def:crs:EPSG::" + srid
          }
        };
      }
      return obj;
    }
    function white() {
      $(/^\s*/);
    }
    function multicoords() {
      white();
      let depth = 0;
      const rings = [];
      const stack = [rings];
      let pointer = rings;
      let elem;
      while (elem = $(/^(\()/) || $(/^(\))/) || $(/^(,)/) || $(tuples)) {
        if (elem === "(") {
          stack.push(pointer);
          pointer = [];
          stack[stack.length - 1].push(pointer);
          depth++;
        } else if (elem === ")") {
          if (pointer.length === 0)
            return null;
          pointer = stack.pop();
          if (!pointer)
            return null;
          depth--;
          if (depth === 0)
            break;
        } else if (elem === ",") {
          pointer = [];
          stack[stack.length - 1].push(pointer);
        } else if (!elem.split(/\s/g).some(isNaN)) {
          Array.prototype.push.apply(pointer, elem.split(/\s/g).map(parseFloat));
        } else {
          return null;
        }
        white();
      }
      if (depth !== 0)
        return null;
      return rings;
    }
    function coords() {
      const list = [];
      let item;
      let pt;
      while (pt = $(tuples) || $(/^(,)/)) {
        if (pt === ",") {
          list.push(item);
          item = [];
        } else if (!pt.split(/\s/g).some(isNaN)) {
          if (!item)
            item = [];
          Array.prototype.push.apply(item, pt.split(/\s/g).map(parseFloat));
        }
        white();
      }
      if (item)
        list.push(item);
      else
        return null;
      return list.length ? list : null;
    }
    function point() {
      if (!$(/^(point(\sz)?)/i))
        return null;
      white();
      if (!$(/^(\()/))
        return null;
      const c = coords();
      if (!c)
        return null;
      white();
      if (!$(/^(\))/))
        return null;
      return {
        type: "Point",
        coordinates: c[0]
      };
    }
    function multipoint() {
      if (!$(/^(multipoint)/i))
        return null;
      white();
      const newCoordsFormat = _.substring(_.indexOf("(") + 1, _.length - 1).replace(/\(/g, "").replace(/\)/g, "");
      _ = "MULTIPOINT (" + newCoordsFormat + ")";
      const c = multicoords();
      if (!c)
        return null;
      white();
      return {
        type: "MultiPoint",
        coordinates: c
      };
    }
    function multilinestring() {
      if (!$(/^(multilinestring)/i))
        return null;
      white();
      const c = multicoords();
      if (!c)
        return null;
      white();
      return {
        type: "MultiLineString",
        coordinates: c
      };
    }
    function linestring() {
      if (!$(/^(linestring(\sz)?)/i))
        return null;
      white();
      if (!$(/^(\()/))
        return null;
      const c = coords();
      if (!c)
        return null;
      if (!$(/^(\))/))
        return null;
      return {
        type: "LineString",
        coordinates: c
      };
    }
    function polygon() {
      if (!$(/^(polygon(\sz)?)/i))
        return null;
      white();
      const c = multicoords();
      if (!c)
        return null;
      return {
        type: "Polygon",
        coordinates: c
      };
    }
    function multipolygon() {
      if (!$(/^(multipolygon)/i))
        return null;
      white();
      const c = multicoords();
      if (!c)
        return null;
      return {
        type: "MultiPolygon",
        coordinates: c
      };
    }
    function geometrycollection() {
      const geometries = [];
      let geometry;
      if (!$(/^(geometrycollection)/i))
        return null;
      white();
      if (!$(/^(\()/))
        return null;
      while (geometry = root()) {
        geometries.push(geometry);
        white();
        $(/^(,)/);
        white();
      }
      if (!$(/^(\))/))
        return null;
      return {
        type: "GeometryCollection",
        geometries
      };
    }
    function root() {
      return point() || linestring() || polygon() || multipoint() || multilinestring() || multipolygon() || geometrycollection();
    }
    return crs(root());
  }
  var numberRegexp, tuples;
  var init_parse_wkt = __esm({
    "src/lib/parse-wkt.ts"() {
      numberRegexp = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;
      tuples = new RegExp("^" + numberRegexp.source + "(\\s" + numberRegexp.source + "){1,}");
    }
  });

  // src/wkt-loader.ts
  var WKTWorkerLoader, WKTLoader;
  var init_wkt_loader = __esm({
    "src/wkt-loader.ts"() {
      init_version();
      init_parse_wkt();
      WKTWorkerLoader = {
        name: "WKT (Well-Known Text)",
        id: "wkt",
        module: "wkt",
        version: VERSION,
        worker: true,
        extensions: ["wkt"],
        mimeTypes: ["text/plain"],
        category: "geometry",
        text: true,
        options: {
          wkt: {}
        }
      };
      WKTLoader = {
        ...WKTWorkerLoader,
        parse: async (arrayBuffer) => parseWKT(new TextDecoder().decode(arrayBuffer)),
        parseTextSync: parseWKT
      };
    }
  });

  // src/lib/encode-wkt.ts
  function encodeWKT(geometry) {
    if (geometry.type === "Feature") {
      geometry = geometry.geometry;
    }
    switch (geometry.type) {
      case "Point":
        return `POINT ${wrapParens(pairWKT(geometry.coordinates))}`;
      case "LineString":
        return `LINESTRING ${wrapParens(ringWKT(geometry.coordinates))}`;
      case "Polygon":
        return `POLYGON ${wrapParens(ringsWKT(geometry.coordinates))}`;
      case "MultiPoint":
        return `MULTIPOINT ${wrapParens(ringWKT(geometry.coordinates))}`;
      case "MultiPolygon":
        return `MULTIPOLYGON ${wrapParens(multiRingsWKT(geometry.coordinates))}`;
      case "MultiLineString":
        return `MULTILINESTRING ${wrapParens(ringsWKT(geometry.coordinates))}`;
      case "GeometryCollection":
        return `GEOMETRYCOLLECTION ${wrapParens(geometry.geometries.map(encodeWKT).join(", "))}`;
      default:
        throw new Error("stringify requires a valid GeoJSON Feature or geometry object as input");
    }
  }
  function pairWKT(c) {
    return c.join(" ");
  }
  function ringWKT(r) {
    return r.map(pairWKT).join(", ");
  }
  function ringsWKT(r) {
    return r.map(ringWKT).map(wrapParens).join(", ");
  }
  function multiRingsWKT(r) {
    return r.map(ringsWKT).map(wrapParens).join(", ");
  }
  function wrapParens(s) {
    return `(${s})`;
  }
  var init_encode_wkt = __esm({
    "src/lib/encode-wkt.ts"() {
    }
  });

  // src/wkt-writer.ts
  var WKTWriter;
  var init_wkt_writer = __esm({
    "src/wkt-writer.ts"() {
      init_version();
      init_encode_wkt();
      WKTWriter = {
        name: "WKT (Well Known Text)",
        id: "wkt",
        module: "wkt",
        version: VERSION,
        extensions: ["wkt"],
        encode: encodeWKT,
        options: {
          wkt: {}
        }
      };
    }
  });

  // src/lib/utils/binary-writer.ts
  var LE, BE, BinaryWriter;
  var init_binary_writer = __esm({
    "src/lib/utils/binary-writer.ts"() {
      LE = true;
      BE = false;
      BinaryWriter = class {
        constructor(size, allowResize) {
          this.byteOffset = 0;
          this.allowResize = false;
          this.arrayBuffer = new ArrayBuffer(size);
          this.dataView = new DataView(this.arrayBuffer);
          this.byteOffset = 0;
          this.allowResize = allowResize || false;
        }
        writeUInt8(value) {
          this._ensureSize(1);
          this.dataView.setUint8(this.byteOffset, value);
          this.byteOffset += 1;
        }
        writeUInt16LE(value) {
          this._ensureSize(2);
          this.dataView.setUint16(this.byteOffset, value, LE);
          this.byteOffset += 2;
        }
        writeUInt16BE(value) {
          this._ensureSize(2);
          this.dataView.setUint16(this.byteOffset, value, BE);
          this.byteOffset += 2;
        }
        writeUInt32LE(value) {
          this._ensureSize(4);
          this.dataView.setUint32(this.byteOffset, value, LE);
          this.byteOffset += 4;
        }
        writeUInt32BE(value) {
          this._ensureSize(4);
          this.dataView.setUint32(this.byteOffset, value, BE);
          this.byteOffset += 4;
        }
        writeInt8(value) {
          this._ensureSize(1);
          this.dataView.setInt8(this.byteOffset, value);
          this.byteOffset += 1;
        }
        writeInt16LE(value) {
          this._ensureSize(2);
          this.dataView.setInt16(this.byteOffset, value, LE);
          this.byteOffset += 2;
        }
        writeInt16BE(value) {
          this._ensureSize(2);
          this.dataView.setInt16(this.byteOffset, value, BE);
          this.byteOffset += 2;
        }
        writeInt32LE(value) {
          this._ensureSize(4);
          this.dataView.setInt32(this.byteOffset, value, LE);
          this.byteOffset += 4;
        }
        writeInt32BE(value) {
          this._ensureSize(4);
          this.dataView.setInt32(this.byteOffset, value, BE);
          this.byteOffset += 4;
        }
        writeFloatLE(value) {
          this._ensureSize(4);
          this.dataView.setFloat32(this.byteOffset, value, LE);
          this.byteOffset += 4;
        }
        writeFloatBE(value) {
          this._ensureSize(4);
          this.dataView.setFloat32(this.byteOffset, value, BE);
          this.byteOffset += 4;
        }
        writeDoubleLE(value) {
          this._ensureSize(8);
          this.dataView.setFloat64(this.byteOffset, value, LE);
          this.byteOffset += 8;
        }
        writeDoubleBE(value) {
          this._ensureSize(8);
          this.dataView.setFloat64(this.byteOffset, value, BE);
          this.byteOffset += 8;
        }
        writeVarInt(value) {
          let length = 1;
          while ((value & 4294967168) !== 0) {
            this.writeUInt8(value & 127 | 128);
            value >>>= 7;
            length++;
          }
          this.writeUInt8(value & 127);
          return length;
        }
        writeBuffer(arrayBuffer) {
          this._ensureSize(arrayBuffer.byteLength);
          const tempArray = new Uint8Array(this.arrayBuffer);
          tempArray.set(new Uint8Array(arrayBuffer), this.byteOffset);
          this.byteOffset += arrayBuffer.byteLength;
        }
        _ensureSize(size) {
          if (this.arrayBuffer.byteLength < this.byteOffset + size) {
            if (this.allowResize) {
              const newArrayBuffer = new ArrayBuffer(this.byteOffset + size);
              const tempArray = new Uint8Array(newArrayBuffer);
              tempArray.set(new Uint8Array(this.arrayBuffer));
              this.arrayBuffer = newArrayBuffer;
            } else {
              throw new Error("BinaryWriter overflow");
            }
          }
        }
      };
    }
  });

  // src/lib/encode-wkb.ts
  function encodeWKB(geometry, options = {}) {
    if (geometry.type === "Feature") {
      geometry = geometry.geometry;
    }
    if ("wkb" in options) {
      options = options.wkb;
    }
    switch (geometry.type) {
      case "Point":
        return encodePoint(geometry.coordinates, options);
      case "LineString":
        return encodeLineString(geometry.coordinates, options);
      case "Polygon":
        return encodePolygon(geometry.coordinates, options);
      case "MultiPoint":
        return encodeMultiPoint(geometry, options);
      case "MultiPolygon":
        return encodeMultiPolygon(geometry, options);
      case "MultiLineString":
        return encodeMultiLineString(geometry, options);
      case "GeometryCollection":
        return encodeGeometryCollection(geometry, options);
      default:
        const exhaustiveCheck = geometry;
        throw new Error(`Unhandled case: ${exhaustiveCheck}`);
    }
  }
  function getGeometrySize(geometry, options) {
    switch (geometry.type) {
      case "Point":
        return getPointSize(options);
      case "LineString":
        return getLineStringSize(geometry.coordinates, options);
      case "Polygon":
        return getPolygonSize(geometry.coordinates, options);
      case "MultiPoint":
        return getMultiPointSize(geometry, options);
      case "MultiPolygon":
        return getMultiPolygonSize(geometry, options);
      case "MultiLineString":
        return getMultiLineStringSize(geometry, options);
      case "GeometryCollection":
        return getGeometryCollectionSize(geometry, options);
      default:
        const exhaustiveCheck = geometry;
        throw new Error(`Unhandled case: ${exhaustiveCheck}`);
    }
  }
  function encodePoint(coordinates, options) {
    const writer = new BinaryWriter(getPointSize(options));
    writer.writeInt8(1);
    writeWkbType(writer, 1, options);
    if (typeof coordinates[0] === "undefined" && typeof coordinates[1] === "undefined") {
      writer.writeDoubleLE(NaN);
      writer.writeDoubleLE(NaN);
      if (options.hasZ) {
        writer.writeDoubleLE(NaN);
      }
      if (options.hasM) {
        writer.writeDoubleLE(NaN);
      }
    } else {
      writeCoordinate(writer, coordinates, options);
    }
    return writer.arrayBuffer;
  }
  function writeCoordinate(writer, coordinate, options) {
    writer.writeDoubleLE(coordinate[0]);
    writer.writeDoubleLE(coordinate[1]);
    if (options.hasZ) {
      writer.writeDoubleLE(coordinate[2]);
    }
    if (options.hasM) {
      writer.writeDoubleLE(coordinate[3]);
    }
  }
  function getPointSize(options) {
    const coordinateSize = getCoordinateSize(options);
    return 1 + 4 + coordinateSize;
  }
  function encodeLineString(coordinates, options) {
    const size = getLineStringSize(coordinates, options);
    const writer = new BinaryWriter(size);
    writer.writeInt8(1);
    writeWkbType(writer, 2, options);
    writer.writeUInt32LE(coordinates.length);
    for (const coordinate of coordinates) {
      writeCoordinate(writer, coordinate, options);
    }
    return writer.arrayBuffer;
  }
  function getLineStringSize(coordinates, options) {
    const coordinateSize = getCoordinateSize(options);
    return 1 + 4 + 4 + coordinates.length * coordinateSize;
  }
  function encodePolygon(coordinates, options) {
    const writer = new BinaryWriter(getPolygonSize(coordinates, options));
    writer.writeInt8(1);
    writeWkbType(writer, 3, options);
    const [exteriorRing, ...interiorRings] = coordinates;
    if (exteriorRing.length > 0) {
      writer.writeUInt32LE(1 + interiorRings.length);
      writer.writeUInt32LE(exteriorRing.length);
    } else {
      writer.writeUInt32LE(0);
    }
    for (const coordinate of exteriorRing) {
      writeCoordinate(writer, coordinate, options);
    }
    for (const interiorRing of interiorRings) {
      writer.writeUInt32LE(interiorRing.length);
      for (const coordinate of interiorRing) {
        writeCoordinate(writer, coordinate, options);
      }
    }
    return writer.arrayBuffer;
  }
  function getPolygonSize(coordinates, options) {
    const coordinateSize = getCoordinateSize(options);
    const [exteriorRing, ...interiorRings] = coordinates;
    let size = 1 + 4 + 4;
    if (exteriorRing.length > 0) {
      size += 4 + exteriorRing.length * coordinateSize;
    }
    for (const interiorRing of interiorRings) {
      size += 4 + interiorRing.length * coordinateSize;
    }
    return size;
  }
  function encodeMultiPoint(multiPoint, options) {
    const writer = new BinaryWriter(getMultiPointSize(multiPoint, options));
    const points = multiPoint.coordinates;
    writer.writeInt8(1);
    writeWkbType(writer, 4, options);
    writer.writeUInt32LE(points.length);
    for (const point of points) {
      const arrayBuffer = encodePoint(point, options);
      writer.writeBuffer(arrayBuffer);
    }
    return writer.arrayBuffer;
  }
  function getMultiPointSize(multiPoint, options) {
    let coordinateSize = getCoordinateSize(options);
    const points = multiPoint.coordinates;
    coordinateSize += 5;
    return 1 + 4 + 4 + points.length * coordinateSize;
  }
  function encodeMultiLineString(multiLineString, options) {
    const writer = new BinaryWriter(getMultiLineStringSize(multiLineString, options));
    const lineStrings = multiLineString.coordinates;
    writer.writeInt8(1);
    writeWkbType(writer, 5, options);
    writer.writeUInt32LE(lineStrings.length);
    for (const lineString of lineStrings) {
      const encodedLineString = encodeLineString(lineString, options);
      writer.writeBuffer(encodedLineString);
    }
    return writer.arrayBuffer;
  }
  function getMultiLineStringSize(multiLineString, options) {
    let size = 1 + 4 + 4;
    const lineStrings = multiLineString.coordinates;
    for (const lineString of lineStrings) {
      size += getLineStringSize(lineString, options);
    }
    return size;
  }
  function encodeMultiPolygon(multiPolygon, options) {
    const writer = new BinaryWriter(getMultiPolygonSize(multiPolygon, options));
    const polygons = multiPolygon.coordinates;
    writer.writeInt8(1);
    writeWkbType(writer, 6, options);
    writer.writeUInt32LE(polygons.length);
    for (const polygon of polygons) {
      const encodedPolygon = encodePolygon(polygon, options);
      writer.writeBuffer(encodedPolygon);
    }
    return writer.arrayBuffer;
  }
  function getMultiPolygonSize(multiPolygon, options) {
    let size = 1 + 4 + 4;
    const polygons = multiPolygon.coordinates;
    for (const polygon of polygons) {
      size += getPolygonSize(polygon, options);
    }
    return size;
  }
  function encodeGeometryCollection(collection, options) {
    const writer = new BinaryWriter(getGeometryCollectionSize(collection, options));
    writer.writeInt8(1);
    writeWkbType(writer, 7, options);
    writer.writeUInt32LE(collection.geometries.length);
    for (const geometry of collection.geometries) {
      const arrayBuffer = encodeWKB(geometry, options);
      writer.writeBuffer(arrayBuffer);
    }
    return writer.arrayBuffer;
  }
  function getGeometryCollectionSize(collection, options) {
    let size = 1 + 4 + 4;
    for (const geometry of collection.geometries) {
      size += getGeometrySize(geometry, options);
    }
    return size;
  }
  function writeWkbType(writer, geometryType, options) {
    const { hasZ, hasM, srid } = options;
    let dimensionType = 0;
    if (!srid) {
      if (hasZ && hasM) {
        dimensionType += 3e3;
      } else if (hasZ) {
        dimensionType += 1e3;
      } else if (hasM) {
        dimensionType += 2e3;
      }
    } else {
      if (hasZ) {
        dimensionType |= 2147483648;
      }
      if (hasM) {
        dimensionType |= 1073741824;
      }
    }
    writer.writeUInt32LE(dimensionType + geometryType >>> 0);
  }
  function getCoordinateSize(options) {
    let coordinateSize = 16;
    if (options.hasZ) {
      coordinateSize += 8;
    }
    if (options.hasM) {
      coordinateSize += 8;
    }
    return coordinateSize;
  }
  var WKB;
  var init_encode_wkb = __esm({
    "src/lib/encode-wkb.ts"() {
      init_binary_writer();
      (function(WKB2) {
        WKB2[WKB2["Point"] = 1] = "Point";
        WKB2[WKB2["LineString"] = 2] = "LineString";
        WKB2[WKB2["Polygon"] = 3] = "Polygon";
        WKB2[WKB2["MultiPoint"] = 4] = "MultiPoint";
        WKB2[WKB2["MultiLineString"] = 5] = "MultiLineString";
        WKB2[WKB2["MultiPolygon"] = 6] = "MultiPolygon";
        WKB2[WKB2["GeometryCollection"] = 7] = "GeometryCollection";
      })(WKB || (WKB = {}));
    }
  });

  // src/wkb-writer.ts
  var WKBWriter;
  var init_wkb_writer = __esm({
    "src/wkb-writer.ts"() {
      init_version();
      init_encode_wkb();
      WKBWriter = {
        name: "WKB (Well Known Binary)",
        id: "wkb",
        module: "wkt",
        version: VERSION,
        extensions: ["wkb"],
        encodeSync: encodeWKB,
        options: {
          wkb: {
            hasZ: false,
            hasM: false
          }
        }
      };
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    WKBLoader: () => WKBLoader,
    WKBWorkerLoader: () => WKBWorkerLoader,
    WKBWriter: () => WKBWriter,
    WKTLoader: () => WKTLoader,
    WKTWorkerLoader: () => WKTWorkerLoader,
    WKTWriter: () => WKTWriter
  });
  var init_src = __esm({
    "src/index.ts"() {
      init_wkb_loader();
      init_wkt_loader();
      init_wkt_writer();
      init_wkb_writer();
    }
  });

  // src/bundle.ts
  var require_bundle = __commonJS({
    "src/bundle.ts"(exports, module) {
      var moduleExports = (init_src(), src_exports);
      globalThis.loaders = globalThis.loaders || {};
      module.exports = Object.assign(globalThis.loaders, moduleExports);
    }
  });
  require_bundle();
})();
