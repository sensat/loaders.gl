{"version":3,"file":"parse-shp-geometry.js","names":["LITTLE_ENDIAN","parseRecord","view","options","_maxDimensions","shp","offset","type","getInt32","Int32Array","BYTES_PER_ELEMENT","parseNull","parsePoint","Math","min","parsePoly","parseMultiPoint","Error","concat","dim","positions","parsePositions","value","size","Float64Array","nPoints","xyPositions","mPositions","zPositions","concatPositions","nParts","bufferOffset","byteOffset","bufferLength","ringIndices","set","buffer","slice","pathIndices","polygonIndices","i","length","startRingIndex","endRingIndex","ring","subarray","sign","getWindingDirection","push","primitivePolygonIndices","Uint32Array","arrayLength","nDim","getSignedArea","area","nCoords"],"sources":["../../../../src/lib/parsers/parse-shp-geometry.ts"],"sourcesContent":["import {BinaryGeometry, BinaryGeometryType} from '@loaders.gl/schema';\nimport {SHPLoaderOptions} from './types';\n\nconst LITTLE_ENDIAN = true;\n\n/**\n * Parse individual record\n *\n * @param view Record data\n * @return Binary Geometry Object\n */\n// eslint-disable-next-line complexity\nexport function parseRecord(view: DataView, options?: SHPLoaderOptions): BinaryGeometry | null {\n  const {_maxDimensions = 4} = options?.shp || {};\n\n  let offset = 0;\n  const type: number = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  switch (type) {\n    case 0:\n      // Null Shape\n      return parseNull();\n    case 1:\n      // Point\n      return parsePoint(view, offset, Math.min(2, _maxDimensions));\n    case 3:\n      // PolyLine\n      return parsePoly(view, offset, Math.min(2, _maxDimensions), 'LineString');\n    case 5:\n      // Polygon\n      return parsePoly(view, offset, Math.min(2, _maxDimensions), 'Polygon');\n    case 8:\n      // MultiPoint\n      return parseMultiPoint(view, offset, Math.min(2, _maxDimensions));\n    // GeometryZ can have 3 or 4 dimensions, since the M is not required to\n    // exist\n    case 11:\n      // PointZ\n      return parsePoint(view, offset, Math.min(4, _maxDimensions));\n    case 13:\n      // PolyLineZ\n      return parsePoly(view, offset, Math.min(4, _maxDimensions), 'LineString');\n    case 15:\n      // PolygonZ\n      return parsePoly(view, offset, Math.min(4, _maxDimensions), 'Polygon');\n    case 18:\n      // MultiPointZ\n      return parseMultiPoint(view, offset, Math.min(4, _maxDimensions));\n    case 21:\n      // PointM\n      return parsePoint(view, offset, Math.min(3, _maxDimensions));\n    case 23:\n      // PolyLineM\n      return parsePoly(view, offset, Math.min(3, _maxDimensions), 'LineString');\n    case 25:\n      // PolygonM\n      return parsePoly(view, offset, Math.min(3, _maxDimensions), 'Polygon');\n    case 28:\n      // MultiPointM\n      return parseMultiPoint(view, offset, Math.min(3, _maxDimensions));\n    default:\n      throw new Error(`unsupported shape type: ${type}`);\n  }\n}\n\n// TODO handle null\n/**\n * Parse Null geometry\n *\n * @return null\n */\nfunction parseNull(): null {\n  return null;\n}\n\n/**\n * Parse point geometry\n *\n * @param view Geometry data\n * @param offset Offset in view\n * @param dim Dimension size\n */\nfunction parsePoint(view: DataView, offset: number, dim: number): BinaryGeometry {\n  let positions: Float64Array;\n  [positions, offset] = parsePositions(view, offset, 1, dim);\n\n  return {\n    positions: {value: positions, size: dim},\n    type: 'Point'\n  };\n}\n\n/**\n * Parse MultiPoint geometry\n *\n * @param view Geometry data\n * @param offset Offset in view\n * @param dim Input dimension\n * @return Binary geometry object\n */\nfunction parseMultiPoint(view: DataView, offset: number, dim: number): BinaryGeometry {\n  // skip parsing box\n  offset += 4 * Float64Array.BYTES_PER_ELEMENT;\n\n  const nPoints = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  let xyPositions: Float64Array | null = null;\n  let mPositions: Float64Array | null = null;\n  let zPositions: Float64Array | null = null;\n  [xyPositions, offset] = parsePositions(view, offset, nPoints, 2);\n\n  // Parse Z coordinates\n  if (dim === 4) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [zPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  // Parse M coordinates\n  if (dim >= 3) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [mPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  const positions = concatPositions(xyPositions, mPositions, zPositions);\n\n  return {\n    positions: {value: positions, size: dim},\n    type: 'Point'\n  };\n}\n\n/**\n * Polygon and PolyLine parsing\n *\n * @param view Geometry data\n * @param offset Offset in view\n * @param dim Input dimension\n * @param type Either 'Polygon' or 'Polyline'\n * @return Binary geometry object\n */\n// eslint-disable-next-line max-statements\nfunction parsePoly(\n  view: DataView,\n  offset: number,\n  dim: number,\n  type: BinaryGeometryType\n): BinaryGeometry {\n  // skip parsing bounding box\n  offset += 4 * Float64Array.BYTES_PER_ELEMENT;\n\n  const nParts = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n  const nPoints = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  // Create longer indices array by 1 because output format is expected to\n  // include the last index as the total number of positions\n  const bufferOffset = view.byteOffset + offset;\n  const bufferLength = nParts * Int32Array.BYTES_PER_ELEMENT;\n  const ringIndices = new Int32Array(nParts + 1);\n  ringIndices.set(new Int32Array(view.buffer.slice(bufferOffset, bufferOffset + bufferLength)));\n  ringIndices[nParts] = nPoints;\n  offset += nParts * Int32Array.BYTES_PER_ELEMENT;\n\n  let xyPositions: Float64Array | null = null;\n  let mPositions: Float64Array | null = null;\n  let zPositions: Float64Array | null = null;\n  [xyPositions, offset] = parsePositions(view, offset, nPoints, 2);\n\n  // Parse Z coordinates\n  if (dim === 4) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [zPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  // Parse M coordinates\n  if (dim >= 3) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [mPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  const positions = concatPositions(xyPositions, mPositions, zPositions);\n\n  // parsePoly only accepts type = LineString or Polygon\n  if (type === 'LineString') {\n    return {\n      type,\n      positions: {value: positions, size: dim},\n      pathIndices: {value: ringIndices, size: 1}\n    };\n  }\n\n  // for every ring, determine sign of polygon\n  // Use only 2D positions for ring calc\n  const polygonIndices: number[] = [];\n  for (let i = 1; i < ringIndices.length; i++) {\n    const startRingIndex = ringIndices[i - 1];\n    const endRingIndex = ringIndices[i];\n    // @ts-ignore\n    const ring = xyPositions.subarray(startRingIndex * 2, endRingIndex * 2);\n    const sign = getWindingDirection(ring);\n\n    // A positive sign implies clockwise\n    // A clockwise ring is a filled ring\n    if (sign > 0) {\n      polygonIndices.push(startRingIndex);\n    }\n  }\n\n  polygonIndices.push(nPoints);\n\n  return {\n    type,\n    positions: {value: positions, size: dim},\n    primitivePolygonIndices: {value: ringIndices, size: 1},\n    // TODO: Dynamically choose Uint32Array over Uint16Array only when\n    // necessary. I believe the implementation requires nPoints to be the\n    // largest value in the array, so you should be able to use Uint32Array only\n    // when nPoints > 65535.\n    polygonIndices: {value: new Uint32Array(polygonIndices), size: 1}\n  };\n}\n\n/**\n * Parse a contiguous block of positions into a Float64Array\n *\n * @param view  Geometry data\n * @param offset  Offset in view\n * @param nPoints Number of points\n * @param dim     Input dimension\n * @return Data and offset\n */\nfunction parsePositions(\n  view: DataView,\n  offset: number,\n  nPoints: number,\n  dim: number\n): [Float64Array, number] {\n  const bufferOffset = view.byteOffset + offset;\n  const bufferLength = nPoints * dim * Float64Array.BYTES_PER_ELEMENT;\n  return [\n    new Float64Array(view.buffer.slice(bufferOffset, bufferOffset + bufferLength)),\n    offset + bufferLength\n  ];\n}\n\n/**\n * Concatenate and interleave positions arrays\n * xy positions are interleaved; mPositions, zPositions are their own arrays\n *\n * @param xyPositions 2d positions\n * @param mPositions  M positions\n * @param zPositions  Z positions\n * @return Combined interleaved positions\n */\n// eslint-disable-next-line complexity\nfunction concatPositions(\n  xyPositions: Float64Array,\n  mPositions: Float64Array | null,\n  zPositions: Float64Array | null\n): Float64Array {\n  if (!(mPositions || zPositions)) {\n    return xyPositions;\n  }\n\n  let arrayLength = xyPositions.length;\n  let nDim = 2;\n\n  if (zPositions && zPositions.length) {\n    arrayLength += zPositions.length;\n    nDim++;\n  }\n\n  if (mPositions && mPositions.length) {\n    arrayLength += mPositions.length;\n    nDim++;\n  }\n\n  const positions = new Float64Array(arrayLength);\n  for (let i = 0; i < xyPositions.length / 2; i++) {\n    positions[nDim * i] = xyPositions[i * 2];\n    positions[nDim * i + 1] = xyPositions[i * 2 + 1];\n  }\n\n  if (zPositions && zPositions.length) {\n    for (let i = 0; i < zPositions.length; i++) {\n      // If Z coordinates exist; used as third coord in positions array\n      positions[nDim * i + 2] = zPositions[i];\n    }\n  }\n\n  if (mPositions && mPositions.length) {\n    for (let i = 0; i < mPositions.length; i++) {\n      // M is always last, either 3rd or 4th depending on if Z exists\n      positions[nDim * i + (nDim - 1)] = mPositions[i];\n    }\n  }\n\n  return positions;\n}\n\n/**\n * Returns the direction of the polygon path\n * A positive number is clockwise.\n * A negative number is counter clockwise.\n *\n * @param positions\n * @return Sign of polygon ring\n */\nfunction getWindingDirection(positions: Float64Array): number {\n  return Math.sign(getSignedArea(positions));\n}\n\n/**\n * Get signed area of flat typed array of 2d positions\n *\n * @param positions\n * @return Signed area of polygon ring\n */\nfunction getSignedArea(positions: Float64Array): number {\n  let area = 0;\n\n  // Rings are closed according to shapefile spec\n  const nCoords = positions.length / 2 - 1;\n  for (let i = 0; i < nCoords; i++) {\n    area +=\n      (positions[i * 2] + positions[(i + 1) * 2]) *\n      (positions[i * 2 + 1] - positions[(i + 1) * 2 + 1]);\n  }\n\n  return area / 2;\n}\n"],"mappings":"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"}