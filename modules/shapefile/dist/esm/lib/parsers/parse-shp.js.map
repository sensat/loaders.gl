{"version":3,"file":"parse-shp.js","names":["BinaryChunkReader","parseSHPHeader","parseRecord","LITTLE_ENDIAN","BIG_ENDIAN","SHP_HEADER_SIZE","SHP_RECORD_HEADER_SIZE","STATE","EXPECTING_HEADER","EXPECTING_RECORD","END","ERROR","SHPParser","constructor","options","_defineProperty","maxRewindBytes","geometries","progress","bytesTotal","NaN","bytesUsed","rows","currentIndex","write","arrayBuffer","binaryReader","state","parseState","result","end","error","parseSHP","shpParser","parseSHPInBatches","asyncIterator","parser","headerReturned","header","length","dataView","getDataView","hasAvailableBytes","_result$header","recordHeaderView","recordHeader","recordNumber","getInt32","byteLength","type","rewind","invalidRecord","recordView","geometry","push","ended","concat","message"],"sources":["../../../../src/lib/parsers/parse-shp.ts"],"sourcesContent":["import type {BinaryGeometry} from '@loaders.gl/schema';\nimport BinaryChunkReader from '../streaming/binary-chunk-reader';\nimport {parseSHPHeader, SHPHeader} from './parse-shp-header';\nimport {parseRecord} from './parse-shp-geometry';\nimport {SHPLoaderOptions} from './types';\n\nconst LITTLE_ENDIAN = true;\nconst BIG_ENDIAN = false;\n\nconst SHP_HEADER_SIZE = 100;\n// According to the spec, the record header is just 8 bytes, but here we set it\n// to 12 so that we can also access the record's type\nconst SHP_RECORD_HEADER_SIZE = 12;\n\nconst STATE = {\n  EXPECTING_HEADER: 0,\n  EXPECTING_RECORD: 1,\n  END: 2,\n  ERROR: 3\n};\n\ntype SHPResult = {\n  geometries: (BinaryGeometry | null)[];\n  header?: SHPHeader;\n  error?: string;\n  progress: {\n    bytesUsed: number;\n    bytesTotal: number;\n    rows: number;\n  };\n  currentIndex: number;\n};\n\nclass SHPParser {\n  options?: SHPLoaderOptions = {};\n  binaryReader = new BinaryChunkReader({maxRewindBytes: SHP_RECORD_HEADER_SIZE});\n  state = STATE.EXPECTING_HEADER;\n  result: SHPResult = {\n    geometries: [],\n    // Initialize with number values to make TS happy\n    // These are initialized for real in STATE.EXPECTING_HEADER\n    progress: {\n      bytesTotal: NaN,\n      bytesUsed: NaN,\n      rows: NaN\n    },\n    currentIndex: NaN\n  };\n\n  constructor(options?: SHPLoaderOptions) {\n    this.options = options;\n  }\n\n  write(arrayBuffer: ArrayBuffer) {\n    this.binaryReader.write(arrayBuffer);\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n  }\n\n  end() {\n    this.binaryReader.end();\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n    // this.result.progress.bytesUsed = this.binaryReader.bytesUsed();\n    if (this.state !== STATE.END) {\n      this.state = STATE.ERROR;\n      this.result.error = 'SHP incomplete file';\n    }\n  }\n}\n\nexport function parseSHP(arrayBuffer: ArrayBuffer, options?: SHPLoaderOptions): BinaryGeometry[] {\n  const shpParser = new SHPParser(options);\n  shpParser.write(arrayBuffer);\n  shpParser.end();\n\n  // @ts-ignore\n  return shpParser.result;\n}\n\n/**\n * @param asyncIterator\n * @param options\n * @returns\n */\nexport async function* parseSHPInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: SHPLoaderOptions\n): AsyncIterable<BinaryGeometry | object> {\n  const parser = new SHPParser(options);\n  let headerReturned = false;\n  for await (const arrayBuffer of asyncIterator) {\n    parser.write(arrayBuffer);\n    if (!headerReturned && parser.result.header) {\n      headerReturned = true;\n      yield parser.result.header;\n    }\n\n    if (parser.result.geometries.length > 0) {\n      yield parser.result.geometries;\n      parser.result.geometries = [];\n    }\n  }\n  parser.end();\n  if (parser.result.geometries.length > 0) {\n    yield parser.result.geometries;\n  }\n\n  return;\n}\n\n/**\n * State-machine parser for SHP data\n *\n * Note that whenever more data is needed, a `return`, not a `break`, is\n * necessary, as the `break` keeps the context within `parseState`, while\n * `return` releases context so that more data can be written into the\n * BinaryChunkReader.\n *\n * @param  state Current state\n * @param  result An object to hold result data\n * @param  binaryReader\n * @return State at end of current parsing\n */\n/* eslint-disable complexity, max-depth */\nfunction parseState(\n  state: number,\n  result: SHPResult,\n  binaryReader: BinaryChunkReader,\n  options?: SHPLoaderOptions\n): number {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      switch (state) {\n        case STATE.ERROR:\n        case STATE.END:\n          return state;\n\n        case STATE.EXPECTING_HEADER:\n          // Parse initial file header\n          const dataView = binaryReader.getDataView(SHP_HEADER_SIZE);\n          if (!dataView) {\n            return state;\n          }\n\n          result.header = parseSHPHeader(dataView);\n          result.progress = {\n            bytesUsed: 0,\n            bytesTotal: result.header.length,\n            rows: 0\n          };\n          // index numbering starts at 1\n          result.currentIndex = 1;\n          state = STATE.EXPECTING_RECORD;\n          break;\n\n        case STATE.EXPECTING_RECORD:\n          while (binaryReader.hasAvailableBytes(SHP_RECORD_HEADER_SIZE)) {\n            const recordHeaderView = binaryReader.getDataView(SHP_RECORD_HEADER_SIZE) as DataView;\n            const recordHeader = {\n              recordNumber: recordHeaderView.getInt32(0, BIG_ENDIAN),\n              // 2 byte words; includes the four words of record header\n              byteLength: recordHeaderView.getInt32(4, BIG_ENDIAN) * 2,\n              // This is actually part of the record, not the header...\n              type: recordHeaderView.getInt32(8, LITTLE_ENDIAN)\n            };\n\n            if (!binaryReader.hasAvailableBytes(recordHeader.byteLength - 4)) {\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE);\n              return state;\n            }\n\n            const invalidRecord =\n              recordHeader.byteLength < 4 ||\n              recordHeader.type !== result.header?.type ||\n              recordHeader.recordNumber !== result.currentIndex;\n\n            // All records must have at least four bytes (for the record shape type)\n            if (invalidRecord) {\n              // Malformed record, try again, advancing just 4 bytes\n              // Note: this is a rewind because binaryReader.getDataView above\n              // moved the pointer forward 12 bytes, so rewinding 8 bytes still\n              // leaves us 4 bytes ahead\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE - 4);\n            } else {\n              // Note: type is actually part of the record, not the header, so\n              // rewind 4 bytes before reading record\n              binaryReader.rewind(4);\n\n              const recordView = binaryReader.getDataView(recordHeader.byteLength) as DataView;\n              const geometry = parseRecord(recordView, options);\n              result.geometries.push(geometry);\n\n              result.currentIndex++;\n              result.progress.rows = result.currentIndex - 1;\n            }\n          }\n\n          if (binaryReader.ended) {\n            state = STATE.END;\n          }\n\n          return state;\n\n        default:\n          state = STATE.ERROR;\n          result.error = `illegal parser state ${state}`;\n          return state;\n      }\n    } catch (error) {\n      state = STATE.ERROR;\n      result.error = `SHP parsing failed: ${(error as Error)?.message}`;\n      return state;\n    }\n  }\n}\n"],"mappings":"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"}