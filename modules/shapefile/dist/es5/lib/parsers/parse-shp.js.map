{"version":3,"file":"parse-shp.js","names":["_binaryChunkReader","_interopRequireDefault","require","_parseShpHeader","_parseShpGeometry","_asyncIterator","iterable","method","async","sync","retry","Symbol","asyncIterator","iterator","call","AsyncFromSyncIterator","TypeError","s","AsyncFromSyncIteratorContinuation","r","Object","Promise","reject","done","resolve","value","then","n","next","prototype","apply","arguments","return","_return","ret","throw","_throw","thr","LITTLE_ENDIAN","BIG_ENDIAN","SHP_HEADER_SIZE","SHP_RECORD_HEADER_SIZE","STATE","EXPECTING_HEADER","EXPECTING_RECORD","END","ERROR","SHPParser","options","_classCallCheck2","default","_defineProperty2","BinaryChunkReader","maxRewindBytes","geometries","progress","bytesTotal","NaN","bytesUsed","rows","currentIndex","_createClass2","key","write","arrayBuffer","binaryReader","state","parseState","result","end","error","parseSHP","shpParser","parseSHPInBatches","_x","_x2","_parseSHPInBatches","_wrapAsyncGenerator2","_regenerator","mark","_callee","parser","headerReturned","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","wrap","_callee$","_context","prev","_awaitAsyncGenerator2","sent","header","length","t0","finish","abrupt","stop","dataView","getDataView","parseSHPHeader","hasAvailableBytes","_result$header","recordHeaderView","recordHeader","recordNumber","getInt32","byteLength","type","rewind","invalidRecord","recordView","geometry","parseRecord","push","ended","concat","message"],"sources":["../../../../src/lib/parsers/parse-shp.ts"],"sourcesContent":["import type {BinaryGeometry} from '@loaders.gl/schema';\nimport BinaryChunkReader from '../streaming/binary-chunk-reader';\nimport {parseSHPHeader, SHPHeader} from './parse-shp-header';\nimport {parseRecord} from './parse-shp-geometry';\nimport {SHPLoaderOptions} from './types';\n\nconst LITTLE_ENDIAN = true;\nconst BIG_ENDIAN = false;\n\nconst SHP_HEADER_SIZE = 100;\n// According to the spec, the record header is just 8 bytes, but here we set it\n// to 12 so that we can also access the record's type\nconst SHP_RECORD_HEADER_SIZE = 12;\n\nconst STATE = {\n  EXPECTING_HEADER: 0,\n  EXPECTING_RECORD: 1,\n  END: 2,\n  ERROR: 3\n};\n\ntype SHPResult = {\n  geometries: (BinaryGeometry | null)[];\n  header?: SHPHeader;\n  error?: string;\n  progress: {\n    bytesUsed: number;\n    bytesTotal: number;\n    rows: number;\n  };\n  currentIndex: number;\n};\n\nclass SHPParser {\n  options?: SHPLoaderOptions = {};\n  binaryReader = new BinaryChunkReader({maxRewindBytes: SHP_RECORD_HEADER_SIZE});\n  state = STATE.EXPECTING_HEADER;\n  result: SHPResult = {\n    geometries: [],\n    // Initialize with number values to make TS happy\n    // These are initialized for real in STATE.EXPECTING_HEADER\n    progress: {\n      bytesTotal: NaN,\n      bytesUsed: NaN,\n      rows: NaN\n    },\n    currentIndex: NaN\n  };\n\n  constructor(options?: SHPLoaderOptions) {\n    this.options = options;\n  }\n\n  write(arrayBuffer: ArrayBuffer) {\n    this.binaryReader.write(arrayBuffer);\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n  }\n\n  end() {\n    this.binaryReader.end();\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n    // this.result.progress.bytesUsed = this.binaryReader.bytesUsed();\n    if (this.state !== STATE.END) {\n      this.state = STATE.ERROR;\n      this.result.error = 'SHP incomplete file';\n    }\n  }\n}\n\nexport function parseSHP(arrayBuffer: ArrayBuffer, options?: SHPLoaderOptions): BinaryGeometry[] {\n  const shpParser = new SHPParser(options);\n  shpParser.write(arrayBuffer);\n  shpParser.end();\n\n  // @ts-ignore\n  return shpParser.result;\n}\n\n/**\n * @param asyncIterator\n * @param options\n * @returns\n */\nexport async function* parseSHPInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: SHPLoaderOptions\n): AsyncIterable<BinaryGeometry | object> {\n  const parser = new SHPParser(options);\n  let headerReturned = false;\n  for await (const arrayBuffer of asyncIterator) {\n    parser.write(arrayBuffer);\n    if (!headerReturned && parser.result.header) {\n      headerReturned = true;\n      yield parser.result.header;\n    }\n\n    if (parser.result.geometries.length > 0) {\n      yield parser.result.geometries;\n      parser.result.geometries = [];\n    }\n  }\n  parser.end();\n  if (parser.result.geometries.length > 0) {\n    yield parser.result.geometries;\n  }\n\n  return;\n}\n\n/**\n * State-machine parser for SHP data\n *\n * Note that whenever more data is needed, a `return`, not a `break`, is\n * necessary, as the `break` keeps the context within `parseState`, while\n * `return` releases context so that more data can be written into the\n * BinaryChunkReader.\n *\n * @param  state Current state\n * @param  result An object to hold result data\n * @param  binaryReader\n * @return State at end of current parsing\n */\n/* eslint-disable complexity, max-depth */\nfunction parseState(\n  state: number,\n  result: SHPResult,\n  binaryReader: BinaryChunkReader,\n  options?: SHPLoaderOptions\n): number {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      switch (state) {\n        case STATE.ERROR:\n        case STATE.END:\n          return state;\n\n        case STATE.EXPECTING_HEADER:\n          // Parse initial file header\n          const dataView = binaryReader.getDataView(SHP_HEADER_SIZE);\n          if (!dataView) {\n            return state;\n          }\n\n          result.header = parseSHPHeader(dataView);\n          result.progress = {\n            bytesUsed: 0,\n            bytesTotal: result.header.length,\n            rows: 0\n          };\n          // index numbering starts at 1\n          result.currentIndex = 1;\n          state = STATE.EXPECTING_RECORD;\n          break;\n\n        case STATE.EXPECTING_RECORD:\n          while (binaryReader.hasAvailableBytes(SHP_RECORD_HEADER_SIZE)) {\n            const recordHeaderView = binaryReader.getDataView(SHP_RECORD_HEADER_SIZE) as DataView;\n            const recordHeader = {\n              recordNumber: recordHeaderView.getInt32(0, BIG_ENDIAN),\n              // 2 byte words; includes the four words of record header\n              byteLength: recordHeaderView.getInt32(4, BIG_ENDIAN) * 2,\n              // This is actually part of the record, not the header...\n              type: recordHeaderView.getInt32(8, LITTLE_ENDIAN)\n            };\n\n            if (!binaryReader.hasAvailableBytes(recordHeader.byteLength - 4)) {\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE);\n              return state;\n            }\n\n            const invalidRecord =\n              recordHeader.byteLength < 4 ||\n              recordHeader.type !== result.header?.type ||\n              recordHeader.recordNumber !== result.currentIndex;\n\n            // All records must have at least four bytes (for the record shape type)\n            if (invalidRecord) {\n              // Malformed record, try again, advancing just 4 bytes\n              // Note: this is a rewind because binaryReader.getDataView above\n              // moved the pointer forward 12 bytes, so rewinding 8 bytes still\n              // leaves us 4 bytes ahead\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE - 4);\n            } else {\n              // Note: type is actually part of the record, not the header, so\n              // rewind 4 bytes before reading record\n              binaryReader.rewind(4);\n\n              const recordView = binaryReader.getDataView(recordHeader.byteLength) as DataView;\n              const geometry = parseRecord(recordView, options);\n              result.geometries.push(geometry);\n\n              result.currentIndex++;\n              result.progress.rows = result.currentIndex - 1;\n            }\n          }\n\n          if (binaryReader.ended) {\n            state = STATE.END;\n          }\n\n          return state;\n\n        default:\n          state = STATE.ERROR;\n          result.error = `illegal parser state ${state}`;\n          return state;\n      }\n    } catch (error) {\n      state = STATE.ERROR;\n      result.error = `SHP parsing failed: ${(error as Error)?.message}`;\n      return state;\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AACA,IAAAA,kBAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,eAAA,GAAAD,OAAA;AACA,IAAAE,iBAAA,GAAAF,OAAA;AAAiD,SAAAG,eAAAC,QAAA,QAAAC,MAAA,EAAAC,KAAA,EAAAC,IAAA,EAAAC,KAAA,iCAAAC,MAAA,KAAAH,KAAA,GAAAG,MAAA,CAAAC,aAAA,EAAAH,IAAA,GAAAE,MAAA,CAAAE,QAAA,GAAAH,KAAA,WAAAF,KAAA,aAAAD,MAAA,GAAAD,QAAA,CAAAE,KAAA,WAAAD,MAAA,CAAAO,IAAA,CAAAR,QAAA,OAAAG,IAAA,aAAAF,MAAA,GAAAD,QAAA,CAAAG,IAAA,eAAAM,qBAAA,CAAAR,MAAA,CAAAO,IAAA,CAAAR,QAAA,IAAAE,KAAA,sBAAAC,IAAA,6BAAAO,SAAA;AAAA,SAAAD,sBAAAE,CAAA,aAAAC,kCAAAC,CAAA,QAAAC,MAAA,CAAAD,CAAA,MAAAA,CAAA,SAAAE,OAAA,CAAAC,MAAA,KAAAN,SAAA,CAAAG,CAAA,+BAAAI,IAAA,GAAAJ,CAAA,CAAAI,IAAA,SAAAF,OAAA,CAAAG,OAAA,CAAAL,CAAA,CAAAM,KAAA,EAAAC,IAAA,WAAAD,KAAA,aAAAA,KAAA,EAAAA,KAAA,EAAAF,IAAA,EAAAA,IAAA,iBAAAR,qBAAA,YAAAA,sBAAAE,CAAA,SAAAA,CAAA,GAAAA,CAAA,OAAAU,CAAA,GAAAV,CAAA,CAAAW,IAAA,KAAAb,qBAAA,CAAAc,SAAA,KAAAZ,CAAA,QAAAU,CAAA,QAAAC,IAAA,WAAAA,KAAA,WAAAV,iCAAA,MAAAS,CAAA,CAAAG,KAAA,MAAAb,CAAA,EAAAc,SAAA,OAAAC,MAAA,WAAAC,QAAAR,KAAA,QAAAS,GAAA,QAAAjB,CAAA,CAAAe,MAAA,oBAAAE,GAAA,GAAAb,OAAA,CAAAG,OAAA,GAAAC,KAAA,EAAAA,KAAA,EAAAF,IAAA,UAAAL,iCAAA,CAAAgB,GAAA,CAAAJ,KAAA,MAAAb,CAAA,EAAAc,SAAA,OAAAI,KAAA,WAAAC,OAAAX,KAAA,QAAAY,GAAA,QAAApB,CAAA,CAAAe,MAAA,oBAAAK,GAAA,GAAAhB,OAAA,CAAAC,MAAA,CAAAG,KAAA,IAAAP,iCAAA,CAAAmB,GAAA,CAAAP,KAAA,MAAAb,CAAA,EAAAc,SAAA,aAAAhB,qBAAA,CAAAE,CAAA;AAGjD,IAAMqB,aAAa,GAAG,IAAI;AAC1B,IAAMC,UAAU,GAAG,KAAK;AAExB,IAAMC,eAAe,GAAG,GAAG;AAG3B,IAAMC,sBAAsB,GAAG,EAAE;AAEjC,IAAMC,KAAK,GAAG;EACZC,gBAAgB,EAAE,CAAC;EACnBC,gBAAgB,EAAE,CAAC;EACnBC,GAAG,EAAE,CAAC;EACNC,KAAK,EAAE;AACT,CAAC;AAAC,IAcIC,SAAS;EAgBb,SAAAA,UAAYC,OAA0B,EAAE;IAAA,IAAAC,gBAAA,CAAAC,OAAA,QAAAH,SAAA;IAAA,IAAAI,gBAAA,CAAAD,OAAA,mBAfX,CAAC,CAAC;IAAA,IAAAC,gBAAA,CAAAD,OAAA,wBAChB,IAAIE,0BAAiB,CAAC;MAACC,cAAc,EAAEZ;IAAsB,CAAC,CAAC;IAAA,IAAAU,gBAAA,CAAAD,OAAA,iBACtER,KAAK,CAACC,gBAAgB;IAAA,IAAAQ,gBAAA,CAAAD,OAAA,kBACV;MAClBI,UAAU,EAAE,EAAE;MAGdC,QAAQ,EAAE;QACRC,UAAU,EAAEC,GAAG;QACfC,SAAS,EAAED,GAAG;QACdE,IAAI,EAAEF;MACR,CAAC;MACDG,YAAY,EAAEH;IAChB,CAAC;IAGC,IAAI,CAACT,OAAO,GAAGA,OAAO;EACxB;EAAC,IAAAa,aAAA,CAAAX,OAAA,EAAAH,SAAA;IAAAe,GAAA;IAAArC,KAAA,EAED,SAAAsC,MAAMC,WAAwB,EAAE;MAC9B,IAAI,CAACC,YAAY,CAACF,KAAK,CAACC,WAAW,CAAC;MACpC,IAAI,CAACE,KAAK,GAAGC,UAAU,CAAC,IAAI,CAACD,KAAK,EAAE,IAAI,CAACE,MAAM,EAAE,IAAI,CAACH,YAAY,EAAE,IAAI,CAACjB,OAAO,CAAC;IACnF;EAAC;IAAAc,GAAA;IAAArC,KAAA,EAED,SAAA4C,IAAA,EAAM;MACJ,IAAI,CAACJ,YAAY,CAACI,GAAG,CAAC,CAAC;MACvB,IAAI,CAACH,KAAK,GAAGC,UAAU,CAAC,IAAI,CAACD,KAAK,EAAE,IAAI,CAACE,MAAM,EAAE,IAAI,CAACH,YAAY,EAAE,IAAI,CAACjB,OAAO,CAAC;MAEjF,IAAI,IAAI,CAACkB,KAAK,KAAKxB,KAAK,CAACG,GAAG,EAAE;QAC5B,IAAI,CAACqB,KAAK,GAAGxB,KAAK,CAACI,KAAK;QACxB,IAAI,CAACsB,MAAM,CAACE,KAAK,GAAG,qBAAqB;MAC3C;IACF;EAAC;EAAA,OAAAvB,SAAA;AAAA;AAGI,SAASwB,QAAQA,CAACP,WAAwB,EAAEhB,OAA0B,EAAoB;EAC/F,IAAMwB,SAAS,GAAG,IAAIzB,SAAS,CAACC,OAAO,CAAC;EACxCwB,SAAS,CAACT,KAAK,CAACC,WAAW,CAAC;EAC5BQ,SAAS,CAACH,GAAG,CAAC,CAAC;EAGf,OAAOG,SAAS,CAACJ,MAAM;AACzB;AAAC,SAOsBK,iBAAiBA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,kBAAA,CAAA9C,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA6C,mBAAA;EAAAA,kBAAA,OAAAC,oBAAA,CAAA3B,OAAA,EAAA4B,YAAA,CAAA5B,OAAA,CAAA6B,IAAA,CAAjC,SAAAC,QACLpE,aAAiE,EACjEoC,OAA0B;IAAA,IAAAiC,MAAA,EAAAC,cAAA,EAAAC,yBAAA,EAAAC,iBAAA,EAAAC,cAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAvB,WAAA;IAAA,OAAAc,YAAA,CAAA5B,OAAA,CAAAsC,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAA9D,IAAA;QAAA;UAEpBqD,MAAM,GAAG,IAAIlC,SAAS,CAACC,OAAO,CAAC;UACjCkC,cAAc,GAAG,KAAK;UAAAC,yBAAA;UAAAC,iBAAA;UAAAM,QAAA,CAAAC,IAAA;UAAAL,SAAA,GAAAjF,cAAA,CACMO,aAAa;QAAA;UAAA8E,QAAA,CAAA9D,IAAA;UAAA,WAAAgE,qBAAA,CAAA1C,OAAA,EAAAoC,SAAA,CAAA1D,IAAA;QAAA;UAAA,MAAAuD,yBAAA,KAAAI,KAAA,GAAAG,QAAA,CAAAG,IAAA,EAAAtE,IAAA;YAAAmE,QAAA,CAAA9D,IAAA;YAAA;UAAA;UAA5BoC,WAAW,GAAAuB,KAAA,CAAA9D,KAAA;UAC1BwD,MAAM,CAAClB,KAAK,CAACC,WAAW,CAAC;UAAC,MACtB,CAACkB,cAAc,IAAID,MAAM,CAACb,MAAM,CAAC0B,MAAM;YAAAJ,QAAA,CAAA9D,IAAA;YAAA;UAAA;UACzCsD,cAAc,GAAG,IAAI;UAACQ,QAAA,CAAA9D,IAAA;UACtB,OAAMqD,MAAM,CAACb,MAAM,CAAC0B,MAAM;QAAA;UAAA,MAGxBb,MAAM,CAACb,MAAM,CAACd,UAAU,CAACyC,MAAM,GAAG,CAAC;YAAAL,QAAA,CAAA9D,IAAA;YAAA;UAAA;UAAA8D,QAAA,CAAA9D,IAAA;UACrC,OAAMqD,MAAM,CAACb,MAAM,CAACd,UAAU;QAAA;UAC9B2B,MAAM,CAACb,MAAM,CAACd,UAAU,GAAG,EAAE;QAAC;UAAA6B,yBAAA;UAAAO,QAAA,CAAA9D,IAAA;UAAA;QAAA;UAAA8D,QAAA,CAAA9D,IAAA;UAAA;QAAA;UAAA8D,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAM,EAAA,GAAAN,QAAA;UAAAN,iBAAA;UAAAC,cAAA,GAAAK,QAAA,CAAAM,EAAA;QAAA;UAAAN,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAC,IAAA;UAAA,MAAAR,yBAAA,IAAAG,SAAA,CAAAtD,MAAA;YAAA0D,QAAA,CAAA9D,IAAA;YAAA;UAAA;UAAA8D,QAAA,CAAA9D,IAAA;UAAA,WAAAgE,qBAAA,CAAA1C,OAAA,EAAAoC,SAAA,CAAAtD,MAAA;QAAA;UAAA0D,QAAA,CAAAC,IAAA;UAAA,KAAAP,iBAAA;YAAAM,QAAA,CAAA9D,IAAA;YAAA;UAAA;UAAA,MAAAyD,cAAA;QAAA;UAAA,OAAAK,QAAA,CAAAO,MAAA;QAAA;UAAA,OAAAP,QAAA,CAAAO,MAAA;QAAA;UAGlChB,MAAM,CAACZ,GAAG,CAAC,CAAC;UAAC,MACTY,MAAM,CAACb,MAAM,CAACd,UAAU,CAACyC,MAAM,GAAG,CAAC;YAAAL,QAAA,CAAA9D,IAAA;YAAA;UAAA;UAAA8D,QAAA,CAAA9D,IAAA;UACrC,OAAMqD,MAAM,CAACb,MAAM,CAACd,UAAU;QAAA;UAAA,OAAAoC,QAAA,CAAAQ,MAAA;QAAA;QAAA;UAAA,OAAAR,QAAA,CAAAS,IAAA;MAAA;IAAA,GAAAnB,OAAA;EAAA,CAIjC;EAAA,OAAAJ,kBAAA,CAAA9C,KAAA,OAAAC,SAAA;AAAA;AAgBD,SAASoC,UAAUA,CACjBD,KAAa,EACbE,MAAiB,EACjBH,YAA+B,EAC/BjB,OAA0B,EAClB;EAER,OAAO,IAAI,EAAE;IACX,IAAI;MACF,QAAQkB,KAAK;QACX,KAAKxB,KAAK,CAACI,KAAK;QAChB,KAAKJ,KAAK,CAACG,GAAG;UACZ,OAAOqB,KAAK;QAEd,KAAKxB,KAAK,CAACC,gBAAgB;UAEzB,IAAMyD,QAAQ,GAAGnC,YAAY,CAACoC,WAAW,CAAC7D,eAAe,CAAC;UAC1D,IAAI,CAAC4D,QAAQ,EAAE;YACb,OAAOlC,KAAK;UACd;UAEAE,MAAM,CAAC0B,MAAM,GAAG,IAAAQ,8BAAc,EAACF,QAAQ,CAAC;UACxChC,MAAM,CAACb,QAAQ,GAAG;YAChBG,SAAS,EAAE,CAAC;YACZF,UAAU,EAAEY,MAAM,CAAC0B,MAAM,CAACC,MAAM;YAChCpC,IAAI,EAAE;UACR,CAAC;UAEDS,MAAM,CAACR,YAAY,GAAG,CAAC;UACvBM,KAAK,GAAGxB,KAAK,CAACE,gBAAgB;UAC9B;QAEF,KAAKF,KAAK,CAACE,gBAAgB;UACzB,OAAOqB,YAAY,CAACsC,iBAAiB,CAAC9D,sBAAsB,CAAC,EAAE;YAAA,IAAA+D,cAAA;YAC7D,IAAMC,gBAAgB,GAAGxC,YAAY,CAACoC,WAAW,CAAC5D,sBAAsB,CAAa;YACrF,IAAMiE,YAAY,GAAG;cACnBC,YAAY,EAAEF,gBAAgB,CAACG,QAAQ,CAAC,CAAC,EAAErE,UAAU,CAAC;cAEtDsE,UAAU,EAAEJ,gBAAgB,CAACG,QAAQ,CAAC,CAAC,EAAErE,UAAU,CAAC,GAAG,CAAC;cAExDuE,IAAI,EAAEL,gBAAgB,CAACG,QAAQ,CAAC,CAAC,EAAEtE,aAAa;YAClD,CAAC;YAED,IAAI,CAAC2B,YAAY,CAACsC,iBAAiB,CAACG,YAAY,CAACG,UAAU,GAAG,CAAC,CAAC,EAAE;cAChE5C,YAAY,CAAC8C,MAAM,CAACtE,sBAAsB,CAAC;cAC3C,OAAOyB,KAAK;YACd;YAEA,IAAM8C,aAAa,GACjBN,YAAY,CAACG,UAAU,GAAG,CAAC,IAC3BH,YAAY,CAACI,IAAI,OAAAN,cAAA,GAAKpC,MAAM,CAAC0B,MAAM,cAAAU,cAAA,uBAAbA,cAAA,CAAeM,IAAI,KACzCJ,YAAY,CAACC,YAAY,KAAKvC,MAAM,CAACR,YAAY;YAGnD,IAAIoD,aAAa,EAAE;cAKjB/C,YAAY,CAAC8C,MAAM,CAACtE,sBAAsB,GAAG,CAAC,CAAC;YACjD,CAAC,MAAM;cAGLwB,YAAY,CAAC8C,MAAM,CAAC,CAAC,CAAC;cAEtB,IAAME,UAAU,GAAGhD,YAAY,CAACoC,WAAW,CAACK,YAAY,CAACG,UAAU,CAAa;cAChF,IAAMK,QAAQ,GAAG,IAAAC,6BAAW,EAACF,UAAU,EAAEjE,OAAO,CAAC;cACjDoB,MAAM,CAACd,UAAU,CAAC8D,IAAI,CAACF,QAAQ,CAAC;cAEhC9C,MAAM,CAACR,YAAY,EAAE;cACrBQ,MAAM,CAACb,QAAQ,CAACI,IAAI,GAAGS,MAAM,CAACR,YAAY,GAAG,CAAC;YAChD;UACF;UAEA,IAAIK,YAAY,CAACoD,KAAK,EAAE;YACtBnD,KAAK,GAAGxB,KAAK,CAACG,GAAG;UACnB;UAEA,OAAOqB,KAAK;QAEd;UACEA,KAAK,GAAGxB,KAAK,CAACI,KAAK;UACnBsB,MAAM,CAACE,KAAK,2BAAAgD,MAAA,CAA2BpD,KAAK,CAAE;UAC9C,OAAOA,KAAK;MAChB;IACF,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdJ,KAAK,GAAGxB,KAAK,CAACI,KAAK;MACnBsB,MAAM,CAACE,KAAK,0BAAAgD,MAAA,CAA2BhD,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAYiD,OAAO,CAAE;MACjE,OAAOrD,KAAK;IACd;EACF;AACF"}