{"version":3,"file":"parse-gltf.js","names":["parseJSON","sliceArrayBuffer","ImageLoader","BasisLoader","selectSupportedBasisFormat","assert","isGLB","parseGLBSync","resolveUrl","getTypedArrayForBufferView","preprocessExtensions","decodeExtensions","normalizeGLTFV1","isGLTF","arrayBuffer","options","byteOffset","parseGLTF","gltf","arrayBufferOrString","_options$gltf","_options$gltf2","_options$gltf3","arguments","length","undefined","context","parseGLTFContainerSync","normalize","promises","loadBuffers","json","buffers","loadImages","promise","push","Promise","all","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","glb","type","concat","_glb","Array","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","_context$fetch","_response$arrayBuffer","fetch","response","call","imageIndices","getReferencesImageIndices","imageIndex","loadImage","Set","textures","texture","source","add","from","sort","image","index","parse","hasOwnProperty","bufferView","Number","isFinite","array","parsedImage","mimeType","basis","format","compressed","mipmaps","width","height"],"sources":["../../../../src/lib/parsers/parse-gltf.ts"],"sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\nimport type {GLB} from '../types/glb-types';\nimport type {ParseGLBOptions} from './parse-glb';\n\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\n\nimport {assert} from '../utils/assert';\nimport {isGLB, parseGLBSync} from './parse-glb';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\n\n/**  */\nexport type ParseGLTFOptions = ParseGLBOptions & {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  excludeExtensions?: string[];\n\n  /** @deprecated not supported in v4. `postProcessGLTF()` must be called by the application */\n  postProcess?: false;\n};\n\n/** Check if an array buffer appears to contain GLTF data */\nexport function isGLTF(arrayBuffer: ArrayBuffer, options?: ParseGLTFOptions): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<GLTFWithBuffers> {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  return gltf;\n}\n\n/**\n *\n * @param gltf\n * @param data - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\n * @param byteOffset\n * @param options\n */\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n"],"mappings":"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"}