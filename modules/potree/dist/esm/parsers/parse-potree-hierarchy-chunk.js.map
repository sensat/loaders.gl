{"version":3,"file":"parse-potree-hierarchy-chunk.js","names":["parsePotreeHierarchyChunk","arrayBuffer","tileHeaders","parseBinaryChunk","buildHierarchy","byteOffset","arguments","length","undefined","dataView","DataView","stack","topTileHeader","decodeRow","push","snode","shift","mask","i","header","childMask","tileHeader","name","childCount","byteLength","getUint8","pointCount","getUint32","options","DEFAULT_OPTIONS","spacing","topNode","nodes","index","parseInt","charAt","parentName","substring","parentNode","level","hasChildren","children","childrenByIndex","Array","fill","Math","pow"],"sources":["../../../src/parsers/parse-potree-hierarchy-chunk.ts"],"sourcesContent":["// This file is derived from the Cesium code base under BSD 2-clause license\n// See LICENSE.md and https://github.com/potree/potree/blob/develop/LICENSE\n\n// Potree Hierarchy Chunk file format\n// https://github.com/potree/potree/blob/develop/docs/potree-file-format.md#index-files\n\n/*\n### Hierarchy Chunk Files\n\nAs mentioned in the former section, the `.hrc` files contain the index structure\nmeaning a list of all the files stored within the directory tree.\n\nAn index file contains a list of tuple values with the first being a `uint8`\n\"mask\" and the second being `uint32` \"number of points\" of a hierarchy level\nin a [breadth first level order][breadth-first].\n\nPer hierarchy level we have 8 possible nodes. To indicate whether a node exists\na simple binary mask is used:\n\n| Position | Mask | [Binary][bin] |\n|----------|------|---------------|\n| 0        | 1    | 0b00000001    |\n| 1        | 2    | 0b00000010    |\n| 2        | 4    | 0b00000100    |\n| 3        | 8    | 0b00001000    |\n| 4        | 16   | 0b00010000    |\n| 5        | 32   | 0b00100000    |\n| 6        | 64   | 0b01000000    |\n| 7        | 128  | 0b10000000    |\n\nSo if in a hierarchy the child node 3 and node 7 exist then the hierarchies\nmask has to be `0b00001000 | 0b10000000` â†’ `0b10001000` (=136).\n\n_Example:_ A simple, non-realistic tree:\n\n```\n|- r1\n|  |\n|  \\- r14 (2 Points)\n|\n\\- r3\n   |\n   \\- r36 (1 Point)\n```\n\nWould have an index looking like this:\n\n| name | mask               | points |\n|------|--------------------|--------|\n| r    | `0b00001010` (=10) | `3`    |\n| r1   | `0b00010000` (=16) | `2`    |\n| r3   | `0b01000000` (=64) | `1`    |\n| r14  | `0b00000000` (=0)  | `2`    |\n| r36  | `0b00000000` (=0)  | `1`    |\n*/\n\n// @ts-nocheck\n\n// load hierarchy\nexport default function parsePotreeHierarchyChunk(arrayBuffer: ArrayBuffer) {\n  const tileHeaders = parseBinaryChunk(arrayBuffer);\n  return buildHierarchy(tileHeaders);\n}\n\n// Parses the binary rows\nfunction parseBinaryChunk(arrayBuffer: ArrayBuffer, byteOffset = 0) {\n  const dataView = new DataView(arrayBuffer);\n\n  const stack = [];\n\n  // Get root mask\n  const topTileHeader = {};\n  byteOffset = decodeRow(dataView, byteOffset, topTileHeader);\n\n  stack.push(topTileHeader);\n\n  const tileHeaders = [];\n\n  while (stack.length > 0) {\n    const snode = stack.shift();\n    let mask = 1;\n\n    for (let i = 0; i < 8; i++) {\n      if (snode && (snode.header.childMask & mask) !== 0) {\n        const tileHeader = {};\n        byteOffset = decodeRow(dataView, byteOffset, tileHeader);\n        tileHeader.name = snode.name + i;\n\n        stack.push(tileHeader);\n        tileHeaders.push(tileHeader);\n        snode.header.childCount++;\n      }\n      mask = mask * 2;\n    }\n\n    if (byteOffset === dataView.byteLength) {\n      break;\n    }\n  }\n\n  return tileHeaders;\n}\n\nfunction decodeRow(dataView, byteOffset, tileHeader) {\n  tileHeader.header = tileHeader.header || {};\n  tileHeader.header.childMask = dataView.getUint8(byteOffset);\n  tileHeader.header.childCount = 0;\n  tileHeader.pointCount = dataView.getUint32(byteOffset + 1, true);\n  tileHeader.name = '';\n  byteOffset += 5;\n  return byteOffset;\n}\n\n// Resolves the binary rows into a hierarchy (tree structure)\nfunction buildHierarchy(tileHeaders, options = {}) {\n  const DEFAULT_OPTIONS = {spacing: 100}; // TODO assert instead of default?\n  options = {...DEFAULT_OPTIONS, ...options};\n\n  const topNode = tileHeaders[0];\n  const nodes = {};\n\n  for (const tileHeader of tileHeaders) {\n    const {name} = tileHeader;\n\n    const index = parseInt(name.charAt(name.length - 1), 10);\n    const parentName = name.substring(0, name.length - 1);\n    const parentNode = nodes[parentName];\n    const level = name.length - 1;\n    // assert(parentNode && level >= 0);\n\n    tileHeader.level = level;\n    tileHeader.hasChildren = tileHeader.header.childCount;\n    tileHeader.children = [];\n    tileHeader.childrenByIndex = new Array(8).fill(null);\n    tileHeader.spacing = options.spacing / Math.pow(2, level);\n    // tileHeader.boundingVolume = Utils.createChildAABB(parentNode.boundingBox, index);\n\n    if (parentNode) {\n      parentNode.children.push(tileHeader);\n      parentNode.childrenByIndex[index] = tileHeader;\n    }\n\n    // Add the node to the map\n    nodes[name] = tileHeader;\n  }\n\n  // First node is the root\n  return topNode;\n}\n"],"mappings":"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"}