(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // src/potree-loader.ts
  var VERSION, PotreeLoader;
  var init_potree_loader = __esm({
    "src/potree-loader.ts"() {
      VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      PotreeLoader = {
        name: "potree",
        id: "potree",
        module: "potree",
        version: VERSION,
        extensions: ["json"],
        mimeTypes: ["application/json"],
        testText: (text) => text.indexOf("octreeDir") >= 0,
        parseTextSync: (text) => JSON.parse(text),
        options: {
          potree: {}
        }
      };
    }
  });

  // src/parsers/parse-potree-hierarchy-chunk.ts
  function parsePotreeHierarchyChunk(arrayBuffer) {
    const tileHeaders = parseBinaryChunk(arrayBuffer);
    return buildHierarchy(tileHeaders);
  }
  function parseBinaryChunk(arrayBuffer, byteOffset = 0) {
    const dataView = new DataView(arrayBuffer);
    const stack = [];
    const topTileHeader = {};
    byteOffset = decodeRow(dataView, byteOffset, topTileHeader);
    stack.push(topTileHeader);
    const tileHeaders = [];
    while (stack.length > 0) {
      const snode = stack.shift();
      let mask = 1;
      for (let i = 0; i < 8; i++) {
        if (snode && (snode.header.childMask & mask) !== 0) {
          const tileHeader = {};
          byteOffset = decodeRow(dataView, byteOffset, tileHeader);
          tileHeader.name = snode.name + i;
          stack.push(tileHeader);
          tileHeaders.push(tileHeader);
          snode.header.childCount++;
        }
        mask = mask * 2;
      }
      if (byteOffset === dataView.byteLength) {
        break;
      }
    }
    return tileHeaders;
  }
  function decodeRow(dataView, byteOffset, tileHeader) {
    tileHeader.header = tileHeader.header || {};
    tileHeader.header.childMask = dataView.getUint8(byteOffset);
    tileHeader.header.childCount = 0;
    tileHeader.pointCount = dataView.getUint32(byteOffset + 1, true);
    tileHeader.name = "";
    byteOffset += 5;
    return byteOffset;
  }
  function buildHierarchy(tileHeaders, options = {}) {
    const DEFAULT_OPTIONS = { spacing: 100 };
    options = { ...DEFAULT_OPTIONS, ...options };
    const topNode = tileHeaders[0];
    const nodes = {};
    for (const tileHeader of tileHeaders) {
      const { name } = tileHeader;
      const index = parseInt(name.charAt(name.length - 1), 10);
      const parentName = name.substring(0, name.length - 1);
      const parentNode = nodes[parentName];
      const level = name.length - 1;
      tileHeader.level = level;
      tileHeader.hasChildren = tileHeader.header.childCount;
      tileHeader.children = [];
      tileHeader.childrenByIndex = new Array(8).fill(null);
      tileHeader.spacing = options.spacing / Math.pow(2, level);
      if (parentNode) {
        parentNode.children.push(tileHeader);
        parentNode.childrenByIndex[index] = tileHeader;
      }
      nodes[name] = tileHeader;
    }
    return topNode;
  }
  var init_parse_potree_hierarchy_chunk = __esm({
    "src/parsers/parse-potree-hierarchy-chunk.ts"() {
    }
  });

  // src/potree-hierarchy-chunk-loader.ts
  function parseSync(arrayBuffer) {
    return parsePotreeHierarchyChunk(arrayBuffer);
  }
  var PotreeHierarchyChunkLoader;
  var init_potree_hierarchy_chunk_loader = __esm({
    "src/potree-hierarchy-chunk-loader.ts"() {
      init_parse_potree_hierarchy_chunk();
      PotreeHierarchyChunkLoader = {
        id: "potree",
        name: "potree Hierarchy Chunk",
        extensions: ["hrc"],
        mimeTypes: ["application/octet-stream"],
        parse: async (arrayBuffer, options) => await parseSync(arrayBuffer),
        parseSync,
        binary: true
      };
    }
  });

  // src/parsers/parse-potree-bin.ts
  function parsePotreeBin(arrayBuffer, byteOffset, options, index) {
    return null;
  }
  var init_parse_potree_bin = __esm({
    "src/parsers/parse-potree-bin.ts"() {
    }
  });

  // src/potree-bin-loader.ts
  function parseSync2(arrayBuffer, options) {
    const index = {};
    const byteOffset = 0;
    parsePotreeBin(arrayBuffer, byteOffset, options, index);
    return index;
  }
  var PotreeBinLoader;
  var init_potree_bin_loader = __esm({
    "src/potree-bin-loader.ts"() {
      init_parse_potree_bin();
      PotreeBinLoader = {
        name: "potree Binary Point Attributes",
        id: "potree",
        extensions: ["bin"],
        mimeTypes: ["application/octet-stream"],
        parseSync: parseSync2,
        binary: true
      };
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    PotreeBinLoader: () => PotreeBinLoader,
    PotreeHierarchyChunkLoader: () => PotreeHierarchyChunkLoader,
    PotreeLoader: () => PotreeLoader
  });
  var init_src = __esm({
    "src/index.ts"() {
      init_potree_loader();
      init_potree_hierarchy_chunk_loader();
      init_potree_bin_loader();
    }
  });

  // src/bundle.ts
  var require_bundle = __commonJS({
    "src/bundle.ts"(exports, module) {
      var moduleExports = (init_src(), src_exports);
      globalThis.loaders = globalThis.loaders || {};
      module.exports = Object.assign(globalThis.loaders, moduleExports);
    }
  });
  require_bundle();
})();
