{"version":3,"file":"omexml.js","names":["_fastXmlParser","_interopRequireDefault","require","_tiffUtils","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty2","default","getOwnPropertyDescriptors","defineProperties","defineProperty","PARSER_OPTIONS","attributeNamePrefix","attrNodeName","parseNodeValue","parseAttributeValue","ignoreAttributes","parse","str","parser","fromString","res","OME","Error","ensureArray","Image","map","img","Channels","Pixels","Channel","c","attr","Color","intToRgba","_img$AquisitionDate","AquisitionDate","_img$Description","Description","image","format","sizes","name","size","concat","unit","join","SizeX","SizeY","Type","SizeZ","SizeT","SizeC"],"sources":["../../../../src/lib/ome/omexml.ts"],"sourcesContent":["import parser from 'fast-xml-parser';\nimport {ensureArray, intToRgba} from '../utils/tiff-utils';\n\n// WARNING: Changes to the parser options _will_ effect the types in types/omexml.d.ts.\nconst PARSER_OPTIONS = {\n  // Nests attributes withtout prefix under 'attr' key for each node\n  attributeNamePrefix: '',\n  attrNodeName: 'attr',\n\n  // Parses numbers for both attributes and nodes\n  parseNodeValue: true,\n  parseAttributeValue: true,\n\n  // Forces attributes to be parsed\n  ignoreAttributes: false\n};\n\nconst parse = (str: string): Root => parser.parse(str, PARSER_OPTIONS);\n\nexport function fromString(str: string) {\n  const res = parse(str);\n  if (!res.OME) {\n    throw Error('Failed to parse OME-XML metadata.');\n  }\n  return ensureArray(res.OME.Image).map((img) => {\n    const Channels = ensureArray(img.Pixels.Channel).map((c) => {\n      if ('Color' in c.attr) {\n        return {...c.attr, Color: intToRgba(c.attr.Color)};\n      }\n      return {...c.attr};\n    });\n    const {AquisitionDate = '', Description = ''} = img;\n    const image = {\n      ...img.attr,\n      AquisitionDate,\n      Description,\n      Pixels: {\n        ...img.Pixels.attr,\n        Channels\n      }\n    };\n    return {\n      ...image,\n      format() {\n        const {Pixels} = image;\n\n        const sizes = (['X', 'Y', 'Z'] as const)\n          .map((name) => {\n            const size = Pixels[`PhysicalSize${name}` as const];\n            const unit = Pixels[`PhysicalSize${name}Unit` as const];\n            return size && unit ? `${size} ${unit}` : '-';\n          })\n          .join(' x ');\n\n        return {\n          'Acquisition Date': image.AquisitionDate,\n          'Dimensions (XY)': `${Pixels.SizeX} x ${Pixels.SizeY}`,\n          'Pixels Type': Pixels.Type,\n          'Pixels Size (XYZ)': sizes,\n          'Z-sections/Timepoints': `${Pixels.SizeZ} x ${Pixels.SizeT}`,\n          Channels: Pixels.SizeC\n        };\n      }\n    };\n  });\n}\n\nexport type OMEXML = ReturnType<typeof fromString>;\nexport type DimensionOrder = 'XYZCT' | 'XYZTC' | 'XYCTZ' | 'XYCZT' | 'XYTCZ' | 'XYTZC';\n\n// Structure of node is determined by the PARSER_OPTIONS.\ntype Node<T, A> = T & {attr: A};\ntype Attrs<Fields extends string, T = string> = {[K in Fields]: T};\n\ntype OMEAttrs = Attrs<'xmlns' | 'xmlns:xsi' | 'xsi:schemaLocation'>;\ntype OME = Node<{Insturment: Insturment; Image: Image | Image[]}, OMEAttrs>;\n\ntype Insturment = Node<\n  {Objective: Node<{}, Attrs<'ID' | 'Model' | 'NominalMagnification'>>},\n  Attrs<'ID'>\n>;\n\ninterface ImageNodes {\n  AquisitionDate?: string;\n  Description?: string;\n  Pixels: Pixels;\n  InstrumentRef: Node<{}, {ID: string}>;\n  ObjectiveSettings: Node<{}, {ID: string}>;\n}\ntype Image = Node<ImageNodes, Attrs<'ID' | 'Name'>>;\n\ntype PixelType =\n  | 'int8'\n  | 'int16'\n  | 'int32'\n  | 'uint8'\n  | 'uint16'\n  | 'uint32'\n  | 'float'\n  | 'bit'\n  | 'double'\n  | 'complex'\n  | 'double-complex';\n\nexport type UnitsLength =\n  | 'Ym'\n  | 'Zm'\n  | 'Em'\n  | 'Pm'\n  | 'Tm'\n  | 'Gm'\n  | 'Mm'\n  | 'km'\n  | 'hm'\n  | 'dam'\n  | 'm'\n  | 'dm'\n  | 'cm'\n  | 'mm'\n  | 'µm'\n  | 'nm'\n  | 'pm'\n  | 'fm'\n  | 'am'\n  | 'zm'\n  | 'ym'\n  | 'Å'\n  | 'thou'\n  | 'li'\n  | 'in'\n  | 'ft'\n  | 'yd'\n  | 'mi'\n  | 'ua'\n  | 'ly'\n  | 'pc'\n  | 'pt'\n  | 'pixel'\n  | 'reference frame';\n\ntype PhysicalSize<Name extends string> = `PhysicalSize${Name}`;\ntype PhysicalSizeUnit<Name extends string> = `PhysicalSize${Name}Unit`;\ntype Size<Names extends string> = `Size${Names}`;\n\ntype PixelAttrs = Attrs<\n  PhysicalSize<'X' | 'Y' | 'Z'> | 'SignificantBits' | Size<'T' | 'C' | 'Z' | 'Y' | 'X'>,\n  number\n> &\n  Attrs<PhysicalSizeUnit<'X' | 'Y' | 'Z'>, UnitsLength> &\n  Attrs<'BigEndian' | 'Interleaved', boolean> & {\n    ID: string;\n    DimensionOrder: DimensionOrder;\n    Type: PixelType;\n  };\n\ntype Pixels = Node<\n  {\n    Channel: Channel | Channel[];\n    TiffData: Node<{}, Attrs<'IFD' | 'PlaneCount'>>;\n  },\n  PixelAttrs\n>;\n\ntype ChannelAttrs =\n  | {\n      ID: string;\n      SamplesPerPixel: number;\n      Name?: string;\n    }\n  | {\n      ID: string;\n      SamplesPerPixel: number;\n      Name?: string;\n      Color: number;\n    };\n\ntype Channel = Node<{}, ChannelAttrs>;\n\ntype Root = {OME: OME};\n"],"mappings":"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"}