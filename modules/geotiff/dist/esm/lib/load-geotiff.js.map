{"version":3,"file":"load-geotiff.js","names":["fromUrl","fromBlob","GeoTIFF","createOffsetsProxy","checkProxies","loadOmeTiff","isOmeTiff","loadGeoTiff","source","opts","arguments","length","undefined","headers","offsets","tiff","firstImage","getImage","Error"],"sources":["../../../src/lib/load-geotiff.ts"],"sourcesContent":["import {fromUrl, fromBlob, GeoTIFF} from 'geotiff';\n\nimport {\n  // createPoolProxy,\n  createOffsetsProxy,\n  checkProxies\n} from './utils/proxies';\n// import Pool from './lib/Pool';\n\nimport {loadOmeTiff, isOmeTiff} from './ome/load-ome-tiff';\nimport type TiffPixelSource from './tiff-pixel-source';\n\n/** Options for initializing a tiff pixel source. */\ninterface GeoTIFFOptions {\n  /** Headers passed to each underlying request. */\n  headers?: Record<string, unknown>;\n  /** Performance enhancment to index the remote tiff source using pre-computed byte-offsets. Generated via https://github.com/ilan-gold/generate-tiff-offsets */\n  offsets?: number[];\n  /** Indicates whether a multi-threaded pool of image decoders should be used to decode tiles. */\n  pool?: boolean;\n}\n\ninterface GeoTIFFData {\n  data: TiffPixelSource<string[]>[];\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Opens an OME-TIFF via URL and returns data source and associated metadata for first image.\n *\n * @param source url string, File/Blob object, or GeoTIFF object\n * @param opts options for initializing a tiff pixel source.\n *  - `opts.headers` are passed to each underlying fetch request.\n *  - `opts.offsets` are a performance enhancment to index the remote tiff source using pre-computed byte-offsets.\n *  - `opts.pool` indicates whether a multi-threaded pool of image decoders should be used to decode tiles (default = true).\n * @return data source and associated OME-Zarr metadata.\n */\nexport async function loadGeoTiff(\n  source: string | Blob | GeoTIFF,\n  opts: GeoTIFFOptions = {}\n): Promise<GeoTIFFData> {\n  const {headers, offsets} = opts;\n\n  // Create tiff source\n  let tiff: GeoTIFF;\n  if (source instanceof GeoTIFF) {\n    tiff = source;\n  } else if (typeof source === 'string') {\n    tiff = await fromUrl(source, headers);\n  } else {\n    tiff = await fromBlob(source);\n  }\n\n  // if (pool) {\n  /*\n   * Creates a worker pool to decode tiff tiles. Wraps tiff\n   * in a Proxy that injects 'pool' into `tiff.readRasters`.\n   */\n  // tiff = createPoolProxy(tiff, new Pool());\n  // }\n\n  if (offsets) {\n    /*\n     * Performance enhancement. If offsets are provided, we\n     * create a proxy that intercepts calls to `tiff.getImage`\n     * and injects the pre-computed offsets.\n     */\n    tiff = createOffsetsProxy(tiff, offsets);\n  }\n\n  /*\n   * Inspect tiff source for our performance enhancing proxies.\n   * Prints warnings to console if `offsets` or `pool` are missing.\n   */\n  checkProxies(tiff);\n\n  const firstImage = await tiff.getImage(0);\n\n  if (isOmeTiff(firstImage)) {\n    return loadOmeTiff(tiff, firstImage);\n  }\n\n  throw new Error('GeoTIFF not recognized.');\n}\n"],"mappings":"AAAA,SAAQA,OAAO,EAAEC,QAAQ,EAAEC,OAAO,QAAO,SAAS;AAElD,SAEEC,kBAAkB,EAClBC,YAAY,QACP,iBAAiB;AAGxB,SAAQC,WAAW,EAAEC,SAAS,QAAO,qBAAqB;AA4B1D,OAAO,eAAeC,WAAWA,CAC/BC,MAA+B,EAET;EAAA,IADtBC,IAAoB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAEzB,MAAM;IAACG,OAAO;IAAEC;EAAO,CAAC,GAAGL,IAAI;EAG/B,IAAIM,IAAa;EACjB,IAAIP,MAAM,YAAYN,OAAO,EAAE;IAC7Ba,IAAI,GAAGP,MAAM;EACf,CAAC,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACrCO,IAAI,GAAG,MAAMf,OAAO,CAACQ,MAAM,EAAEK,OAAO,CAAC;EACvC,CAAC,MAAM;IACLE,IAAI,GAAG,MAAMd,QAAQ,CAACO,MAAM,CAAC;EAC/B;EAUA,IAAIM,OAAO,EAAE;IAMXC,IAAI,GAAGZ,kBAAkB,CAACY,IAAI,EAAED,OAAO,CAAC;EAC1C;EAMAV,YAAY,CAACW,IAAI,CAAC;EAElB,MAAMC,UAAU,GAAG,MAAMD,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC;EAEzC,IAAIX,SAAS,CAACU,UAAU,CAAC,EAAE;IACzB,OAAOX,WAAW,CAACU,IAAI,EAAEC,UAAU,CAAC;EACtC;EAEA,MAAM,IAAIE,KAAK,CAAC,yBAAyB,CAAC;AAC5C"}